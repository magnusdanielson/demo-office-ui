(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~6a2f6fc3"],{

/***/ "+vuT":
/*!********************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ComboBox/VirtualizedComboBox.js ***!
  \********************************************************************************************/
/*! exports provided: VirtualizedComboBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VirtualizedComboBox\", function() { return VirtualizedComboBox; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ComboBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComboBox */ \"ihU0\");\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../List */ \"bSH+\");\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\n\n\n\n\n\nvar VirtualizedComboBox = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(VirtualizedComboBox, _super);\n    function VirtualizedComboBox(props) {\n        var _this = _super.call(this, props) || this;\n        /** The combo box element */\n        _this._comboBox = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /** The virtualized list element */\n        _this._list = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        _this._onRenderList = function (props) {\n            var onRenderItem = props.onRenderItem;\n            // Render virtualized list\n            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_List__WEBPACK_IMPORTED_MODULE_3__[\"List\"], { componentRef: _this._list, role: \"listbox\", items: props.options, \n                // eslint-disable-next-line react/jsx-no-bind\n                onRenderCell: onRenderItem ? function (item) { return onRenderItem(item); } : function () { return null; } }));\n        };\n        _this._onScrollToItem = function (itemIndex) {\n            // We are using the List component, call scrollToIndex\n            _this._list.current && _this._list.current.scrollToIndex(itemIndex);\n        };\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_4__[\"initializeComponentRef\"])(_this);\n        return _this;\n    }\n    Object.defineProperty(VirtualizedComboBox.prototype, \"selectedOptions\", {\n        /**\n         * All selected options\n         */\n        get: function () {\n            if (this._comboBox.current) {\n                return this._comboBox.current.selectedOptions;\n            }\n            return [];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VirtualizedComboBox.prototype.dismissMenu = function () {\n        if (this._comboBox.current) {\n            return this._comboBox.current.dismissMenu();\n        }\n    };\n    VirtualizedComboBox.prototype.focus = function (shouldOpenOnFocus, useFocusAsync) {\n        if (this._comboBox.current) {\n            this._comboBox.current.focus(shouldOpenOnFocus, useFocusAsync);\n            return true;\n        }\n        return false;\n    };\n    VirtualizedComboBox.prototype.render = function () {\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_ComboBox__WEBPACK_IMPORTED_MODULE_2__[\"ComboBox\"], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.props, { componentRef: this._comboBox, onRenderList: this._onRenderList, onScrollToItem: this._onScrollToItem })));\n    };\n    return VirtualizedComboBox;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\n\n//# sourceMappingURL=VirtualizedComboBox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiK3Z1VC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbWJvQm94L1ZpcnR1YWxpemVkQ29tYm9Cb3guanM/ZmFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb21ib0JveCB9IGZyb20gJy4vQ29tYm9Cb3gnO1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gJy4uLy4uL0xpc3QnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUNvbXBvbmVudFJlZiB9IGZyb20gJy4uLy4uL1V0aWxpdGllcyc7XG52YXIgVmlydHVhbGl6ZWRDb21ib0JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlydHVhbGl6ZWRDb21ib0JveCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsaXplZENvbWJvQm94KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICAvKiogVGhlIGNvbWJvIGJveCBlbGVtZW50ICovXG4gICAgICAgIF90aGlzLl9jb21ib0JveCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAvKiogVGhlIHZpcnR1YWxpemVkIGxpc3QgZWxlbWVudCAqL1xuICAgICAgICBfdGhpcy5fbGlzdCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5fb25SZW5kZXJMaXN0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgb25SZW5kZXJJdGVtID0gcHJvcHMub25SZW5kZXJJdGVtO1xuICAgICAgICAgICAgLy8gUmVuZGVyIHZpcnR1YWxpemVkIGxpc3RcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0LCB7IGNvbXBvbmVudFJlZjogX3RoaXMuX2xpc3QsIHJvbGU6IFwibGlzdGJveFwiLCBpdGVtczogcHJvcHMub3B0aW9ucywgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1uby1iaW5kXG4gICAgICAgICAgICAgICAgb25SZW5kZXJDZWxsOiBvblJlbmRlckl0ZW0gPyBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gb25SZW5kZXJJdGVtKGl0ZW0pOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vblNjcm9sbFRvSXRlbSA9IGZ1bmN0aW9uIChpdGVtSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSB1c2luZyB0aGUgTGlzdCBjb21wb25lbnQsIGNhbGwgc2Nyb2xsVG9JbmRleFxuICAgICAgICAgICAgX3RoaXMuX2xpc3QuY3VycmVudCAmJiBfdGhpcy5fbGlzdC5jdXJyZW50LnNjcm9sbFRvSW5kZXgoaXRlbUluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudFJlZihfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxpemVkQ29tYm9Cb3gucHJvdG90eXBlLCBcInNlbGVjdGVkT3B0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tYm9Cb3guY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21ib0JveC5jdXJyZW50LnNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlydHVhbGl6ZWRDb21ib0JveC5wcm90b3R5cGUuZGlzbWlzc01lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21ib0JveC5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tYm9Cb3guY3VycmVudC5kaXNtaXNzTWVudSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsaXplZENvbWJvQm94LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIChzaG91bGRPcGVuT25Gb2N1cywgdXNlRm9jdXNBc3luYykge1xuICAgICAgICBpZiAodGhpcy5fY29tYm9Cb3guY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fY29tYm9Cb3guY3VycmVudC5mb2N1cyhzaG91bGRPcGVuT25Gb2N1cywgdXNlRm9jdXNBc3luYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBWaXJ0dWFsaXplZENvbWJvQm94LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21ib0JveCwgX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgY29tcG9uZW50UmVmOiB0aGlzLl9jb21ib0JveCwgb25SZW5kZXJMaXN0OiB0aGlzLl9vblJlbmRlckxpc3QsIG9uU2Nyb2xsVG9JdGVtOiB0aGlzLl9vblNjcm9sbFRvSXRlbSB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpcnR1YWxpemVkQ29tYm9Cb3g7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0IHsgVmlydHVhbGl6ZWRDb21ib0JveCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlydHVhbGl6ZWRDb21ib0JveC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///+vuT\n");

/***/ }),

/***/ "FaLo":
/*!******************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ComboBox/index.js ***!
  \******************************************************************************/
/*! exports provided: SelectableOptionMenuItemType, ComboBox, VirtualizedComboBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_selectableOption_SelectableOption_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/selectableOption/SelectableOption.types */ \"AqBJ\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SelectableOptionMenuItemType\", function() { return _utilities_selectableOption_SelectableOption_types__WEBPACK_IMPORTED_MODULE_0__[\"SelectableOptionMenuItemType\"]; });\n\n/* harmony import */ var _ComboBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox */ \"ihU0\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ComboBox\", function() { return _ComboBox__WEBPACK_IMPORTED_MODULE_1__[\"ComboBox\"]; });\n\n/* harmony import */ var _VirtualizedComboBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VirtualizedComboBox */ \"+vuT\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VirtualizedComboBox\", function() { return _VirtualizedComboBox__WEBPACK_IMPORTED_MODULE_2__[\"VirtualizedComboBox\"]; });\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmFMby5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbWJvQm94L2luZGV4LmpzPzE1YTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZSB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9zZWxlY3RhYmxlT3B0aW9uL1NlbGVjdGFibGVPcHRpb24udHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21ib0JveCc7XG5leHBvcnQgKiBmcm9tICcuL1ZpcnR1YWxpemVkQ29tYm9Cb3gnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///FaLo\n");

/***/ }),

/***/ "Nszo":
/*!********************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorSlider/ColorSlider.base.js ***!
  \********************************************************************************************************/
/*! exports provided: ColorSliderBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorSliderBase\", function() { return ColorSliderBase; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n/* harmony import */ var _utilities_color_clamp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utilities/color/clamp */ \"aMma\");\n/* harmony import */ var _utilities_color_consts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utilities/color/consts */ \"dp4Y\");\n\n\n\n\n\nvar getClassNames = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"classNamesFunction\"])();\n/**\n * {@docCategory ColorPicker}\n */\nvar ColorSliderBase = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ColorSliderBase, _super);\n    function ColorSliderBase(props) {\n        var _this = _super.call(this, props) || this;\n        _this._disposables = [];\n        _this._root = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        _this._onKeyDown = function (ev) {\n            var currentValue = _this.value;\n            var maxValue = _this._maxValue;\n            var increment = ev.shiftKey ? 10 : 1;\n            // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n            // and getting all the math and styles flipped correctly is tricky\n            switch (ev.which) {\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].left: {\n                    currentValue -= increment;\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].right: {\n                    currentValue += increment;\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].home: {\n                    currentValue = 0;\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].end: {\n                    currentValue = maxValue;\n                    break;\n                }\n                default: {\n                    return;\n                }\n            }\n            _this._updateValue(ev, Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(currentValue, maxValue));\n        };\n        _this._onMouseDown = function (ev) {\n            var win = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"getWindow\"])(_this);\n            if (win) {\n                _this._disposables.push(Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"on\"])(win, 'mousemove', _this._onMouseMove, true), Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"on\"])(win, 'mouseup', _this._disposeListeners, true));\n            }\n            _this._onMouseMove(ev);\n        };\n        _this._onMouseMove = function (ev) {\n            if (!_this._root.current) {\n                return;\n            }\n            var maxValue = _this._maxValue;\n            var rectSize = _this._root.current.getBoundingClientRect();\n            var currentPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n            var newValue = Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(Math.round(currentPercentage * maxValue), maxValue);\n            _this._updateValue(ev, newValue);\n        };\n        _this._disposeListeners = function () {\n            _this._disposables.forEach(function (dispose) { return dispose(); });\n            _this._disposables = [];\n        };\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"initializeComponentRef\"])(_this);\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"warnDeprecations\"])('ColorSlider', props, {\n            thumbColor: 'styles.sliderThumb',\n            overlayStyle: 'overlayColor',\n            isAlpha: 'type',\n            maxValue: 'type',\n            minValue: 'type',\n        });\n        // eslint-disable-next-line deprecation/deprecation\n        if (_this._type !== 'hue' && !(props.overlayColor || props.overlayStyle)) {\n            Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"warn\"])(\"ColorSlider: 'overlayColor' is required when 'type' is \\\"alpha\\\" or \\\"transparency\\\"\");\n        }\n        _this.state = {\n            currentValue: props.value || 0,\n        };\n        return _this;\n    }\n    Object.defineProperty(ColorSliderBase.prototype, \"value\", {\n        get: function () {\n            return this.state.currentValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorSliderBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n        // if props changed (as opposed to a state update), set the value\n        // TODO: switch to strict controlled pattern instead\n        if (prevProps !== this.props && this.props.value !== undefined) {\n            this.setState({ currentValue: this.props.value });\n        }\n    };\n    ColorSliderBase.prototype.componentWillUnmount = function () {\n        this._disposeListeners();\n    };\n    ColorSliderBase.prototype.render = function () {\n        var type = this._type;\n        var maxValue = this._maxValue;\n        var _a = this.props, \n        // eslint-disable-next-line deprecation/deprecation\n        overlayStyle = _a.overlayStyle, overlayColor = _a.overlayColor, theme = _a.theme, className = _a.className, styles = _a.styles, _b = _a.ariaLabel, ariaLabel = _b === void 0 ? type : _b;\n        var currentValue = this.value;\n        var classNames = getClassNames(styles, {\n            theme: theme,\n            className: className,\n            type: type,\n        });\n        var currentPercentage = (100 * currentValue) / maxValue;\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { ref: this._root, className: classNames.root, tabIndex: 0, onKeyDown: this._onKeyDown, onMouseDown: this._onMouseDown, role: \"slider\", \"aria-valuenow\": currentValue, \"aria-valuetext\": String(currentValue), \"aria-valuemin\": 0, \"aria-valuemax\": maxValue, \"aria-label\": ariaLabel, \"data-is-focusable\": true },\n            !!(overlayColor || overlayStyle) && (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.sliderOverlay, \n                // this isn't included in getStyles because it may change frequently\n                style: overlayColor\n                    ? {\n                        background: type === 'transparency'\n                            ? \"linear-gradient(to right, #\" + overlayColor + \", transparent)\"\n                            : \"linear-gradient(to right, transparent, #\" + overlayColor + \")\",\n                    }\n                    : overlayStyle })),\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.sliderThumb, style: { left: currentPercentage + '%' } })));\n    };\n    Object.defineProperty(ColorSliderBase.prototype, \"_type\", {\n        get: function () {\n            // eslint-disable-next-line deprecation/deprecation\n            var _a = this.props, isAlpha = _a.isAlpha, _b = _a.type, type = _b === void 0 ? isAlpha ? 'alpha' : 'hue' : _b;\n            return type;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ColorSliderBase.prototype, \"_maxValue\", {\n        get: function () {\n            return this._type === 'hue' ? _utilities_color_consts__WEBPACK_IMPORTED_MODULE_4__[\"MAX_COLOR_HUE\"] : _utilities_color_consts__WEBPACK_IMPORTED_MODULE_4__[\"MAX_COLOR_ALPHA\"];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorSliderBase.prototype._updateValue = function (ev, newValue) {\n        if (newValue === this.value) {\n            return;\n        }\n        var onChange = this.props.onChange;\n        if (onChange) {\n            onChange(ev, newValue);\n        }\n        if (!ev.defaultPrevented) {\n            this.setState({\n                currentValue: newValue,\n            });\n            ev.preventDefault();\n        }\n    };\n    ColorSliderBase.defaultProps = {\n        value: 0,\n    };\n    return ColorSliderBase;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\n\n//# sourceMappingURL=ColorSlider.base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnN6by5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yU2xpZGVyL0NvbG9yU2xpZGVyLmJhc2UuanM/MzZjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsYXNzTmFtZXNGdW5jdGlvbiwgaW5pdGlhbGl6ZUNvbXBvbmVudFJlZiwgb24sIEtleUNvZGVzLCBnZXRXaW5kb3csIHdhcm5EZXByZWNhdGlvbnMsIHdhcm4sIH0gZnJvbSAnLi4vLi4vLi4vVXRpbGl0aWVzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL2NvbG9yL2NsYW1wJztcbmltcG9ydCB7IE1BWF9DT0xPUl9IVUUsIE1BWF9DT0xPUl9BTFBIQSB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9jb2xvci9jb25zdHMnO1xudmFyIGdldENsYXNzTmFtZXMgPSBjbGFzc05hbWVzRnVuY3Rpb24oKTtcbi8qKlxuICoge0Bkb2NDYXRlZ29yeSBDb2xvclBpY2tlcn1cbiAqL1xudmFyIENvbG9yU2xpZGVyQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sb3JTbGlkZXJCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbG9yU2xpZGVyQmFzZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzID0gW107XG4gICAgICAgIF90aGlzLl9yb290ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBfdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IF90aGlzLl9tYXhWYWx1ZTtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBldi5zaGlmdEtleSA/IDEwIDogMTtcbiAgICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgRE8gTk9UIGZsaXAgdGhlIGNvbG9yIHBpY2tlciBpbiBSVEw6IGl0cyBvcmllbnRhdGlvbiBpcyBub3QgdmVyeSBtZWFuaW5nZnVsLFxuICAgICAgICAgICAgLy8gYW5kIGdldHRpbmcgYWxsIHRoZSBtYXRoIGFuZCBzdHlsZXMgZmxpcHBlZCBjb3JyZWN0bHkgaXMgdHJpY2t5XG4gICAgICAgICAgICBzd2l0Y2ggKGV2LndoaWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlDb2Rlcy5sZWZ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSAtPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLnJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLmhvbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgS2V5Q29kZXMuZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IG1heFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVZhbHVlKGV2LCBjbGFtcChjdXJyZW50VmFsdWUsIG1heFZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHdpbiA9IGdldFdpbmRvdyhfdGhpcyk7XG4gICAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzLnB1c2gob24od2luLCAnbW91c2Vtb3ZlJywgX3RoaXMuX29uTW91c2VNb3ZlLCB0cnVlKSwgb24od2luLCAnbW91c2V1cCcsIF90aGlzLl9kaXNwb3NlTGlzdGVuZXJzLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fb25Nb3VzZU1vdmUoZXYpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX3Jvb3QuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IF90aGlzLl9tYXhWYWx1ZTtcbiAgICAgICAgICAgIHZhciByZWN0U2l6ZSA9IF90aGlzLl9yb290LmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBlcmNlbnRhZ2UgPSAoZXYuY2xpZW50WCAtIHJlY3RTaXplLmxlZnQpIC8gcmVjdFNpemUud2lkdGg7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjbGFtcChNYXRoLnJvdW5kKGN1cnJlbnRQZXJjZW50YWdlICogbWF4VmFsdWUpLCBtYXhWYWx1ZSk7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlVmFsdWUoZXYsIG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2Rpc3Bvc2VMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGlzcG9zYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlzcG9zZSkgeyByZXR1cm4gZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgIF90aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50UmVmKF90aGlzKTtcbiAgICAgICAgd2FybkRlcHJlY2F0aW9ucygnQ29sb3JTbGlkZXInLCBwcm9wcywge1xuICAgICAgICAgICAgdGh1bWJDb2xvcjogJ3N0eWxlcy5zbGlkZXJUaHVtYicsXG4gICAgICAgICAgICBvdmVybGF5U3R5bGU6ICdvdmVybGF5Q29sb3InLFxuICAgICAgICAgICAgaXNBbHBoYTogJ3R5cGUnLFxuICAgICAgICAgICAgbWF4VmFsdWU6ICd0eXBlJyxcbiAgICAgICAgICAgIG1pblZhbHVlOiAndHlwZScsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgaWYgKF90aGlzLl90eXBlICE9PSAnaHVlJyAmJiAhKHByb3BzLm92ZXJsYXlDb2xvciB8fCBwcm9wcy5vdmVybGF5U3R5bGUpKSB7XG4gICAgICAgICAgICB3YXJuKFwiQ29sb3JTbGlkZXI6ICdvdmVybGF5Q29sb3InIGlzIHJlcXVpcmVkIHdoZW4gJ3R5cGUnIGlzIFxcXCJhbHBoYVxcXCIgb3IgXFxcInRyYW5zcGFyZW5jeVxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IHByb3BzLnZhbHVlIHx8IDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yU2xpZGVyQmFzZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29sb3JTbGlkZXJCYXNlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgLy8gaWYgcHJvcHMgY2hhbmdlZCAoYXMgb3Bwb3NlZCB0byBhIHN0YXRlIHVwZGF0ZSksIHNldCB0aGUgdmFsdWVcbiAgICAgICAgLy8gVE9ETzogc3dpdGNoIHRvIHN0cmljdCBjb250cm9sbGVkIHBhdHRlcm4gaW5zdGVhZFxuICAgICAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzICYmIHRoaXMucHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnJlbnRWYWx1ZTogdGhpcy5wcm9wcy52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sb3JTbGlkZXJCYXNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZUxpc3RlbmVycygpO1xuICAgIH07XG4gICAgQ29sb3JTbGlkZXJCYXNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdGhpcy5fbWF4VmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgb3ZlcmxheVN0eWxlID0gX2Eub3ZlcmxheVN0eWxlLCBvdmVybGF5Q29sb3IgPSBfYS5vdmVybGF5Q29sb3IsIHRoZW1lID0gX2EudGhlbWUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgc3R5bGVzID0gX2Euc3R5bGVzLCBfYiA9IF9hLmFyaWFMYWJlbCwgYXJpYUxhYmVsID0gX2IgPT09IHZvaWQgMCA/IHR5cGUgOiBfYjtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gZ2V0Q2xhc3NOYW1lcyhzdHlsZXMsIHtcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50UGVyY2VudGFnZSA9ICgxMDAgKiBjdXJyZW50VmFsdWUpIC8gbWF4VmFsdWU7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5fcm9vdCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnJvb3QsIHRhYkluZGV4OiAwLCBvbktleURvd246IHRoaXMuX29uS2V5RG93biwgb25Nb3VzZURvd246IHRoaXMuX29uTW91c2VEb3duLCByb2xlOiBcInNsaWRlclwiLCBcImFyaWEtdmFsdWVub3dcIjogY3VycmVudFZhbHVlLCBcImFyaWEtdmFsdWV0ZXh0XCI6IFN0cmluZyhjdXJyZW50VmFsdWUpLCBcImFyaWEtdmFsdWVtaW5cIjogMCwgXCJhcmlhLXZhbHVlbWF4XCI6IG1heFZhbHVlLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCBcImRhdGEtaXMtZm9jdXNhYmxlXCI6IHRydWUgfSxcbiAgICAgICAgICAgICEhKG92ZXJsYXlDb2xvciB8fCBvdmVybGF5U3R5bGUpICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnNsaWRlck92ZXJsYXksIFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgaW5jbHVkZWQgaW4gZ2V0U3R5bGVzIGJlY2F1c2UgaXQgbWF5IGNoYW5nZSBmcmVxdWVudGx5XG4gICAgICAgICAgICAgICAgc3R5bGU6IG92ZXJsYXlDb2xvclxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHR5cGUgPT09ICd0cmFuc3BhcmVuY3knXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImxpbmVhci1ncmFkaWVudCh0byByaWdodCwgI1wiICsgb3ZlcmxheUNvbG9yICsgXCIsIHRyYW5zcGFyZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImxpbmVhci1ncmFkaWVudCh0byByaWdodCwgdHJhbnNwYXJlbnQsICNcIiArIG92ZXJsYXlDb2xvciArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogb3ZlcmxheVN0eWxlIH0pKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuc2xpZGVyVGh1bWIsIHN0eWxlOiB7IGxlZnQ6IGN1cnJlbnRQZXJjZW50YWdlICsgJyUnIH0gfSkpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclNsaWRlckJhc2UucHJvdG90eXBlLCBcIl90eXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGlzQWxwaGEgPSBfYS5pc0FscGhhLCBfYiA9IF9hLnR5cGUsIHR5cGUgPSBfYiA9PT0gdm9pZCAwID8gaXNBbHBoYSA/ICdhbHBoYScgOiAnaHVlJyA6IF9iO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclNsaWRlckJhc2UucHJvdG90eXBlLCBcIl9tYXhWYWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09ICdodWUnID8gTUFYX0NPTE9SX0hVRSA6IE1BWF9DT0xPUl9BTFBIQTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29sb3JTbGlkZXJCYXNlLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoZXYsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbkNoYW5nZSA9IHRoaXMucHJvcHMub25DaGFuZ2U7XG4gICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgb25DaGFuZ2UoZXYsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yU2xpZGVyQmFzZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHZhbHVlOiAwLFxuICAgIH07XG4gICAgcmV0dXJuIENvbG9yU2xpZGVyQmFzZTtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnQgeyBDb2xvclNsaWRlckJhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yU2xpZGVyLmJhc2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///Nszo\n");

/***/ }),

/***/ "WXXX":
/*!***************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorSlider/ColorSlider.js ***!
  \***************************************************************************************************/
/*! exports provided: ColorSlider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorSlider\", function() { return ColorSlider; });\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n/* harmony import */ var _ColorSlider_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorSlider.base */ \"Nszo\");\n/* harmony import */ var _ColorSlider_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColorSlider.styles */ \"a/K1\");\n\n\n\nvar ColorSlider = Object(_Utilities__WEBPACK_IMPORTED_MODULE_0__[\"styled\"])(_ColorSlider_base__WEBPACK_IMPORTED_MODULE_1__[\"ColorSliderBase\"], _ColorSlider_styles__WEBPACK_IMPORTED_MODULE_2__[\"getStyles\"], undefined, { scope: 'ColorSlider' });\n//# sourceMappingURL=ColorSlider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV1hYWC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yU2xpZGVyL0NvbG9yU2xpZGVyLmpzPzU5NzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSAnLi4vLi4vLi4vVXRpbGl0aWVzJztcbmltcG9ydCB7IENvbG9yU2xpZGVyQmFzZSB9IGZyb20gJy4vQ29sb3JTbGlkZXIuYmFzZSc7XG5pbXBvcnQgeyBnZXRTdHlsZXMgfSBmcm9tICcuL0NvbG9yU2xpZGVyLnN0eWxlcyc7XG5leHBvcnQgdmFyIENvbG9yU2xpZGVyID0gc3R5bGVkKENvbG9yU2xpZGVyQmFzZSwgZ2V0U3R5bGVzLCB1bmRlZmluZWQsIHsgc2NvcGU6ICdDb2xvclNsaWRlcicgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclNsaWRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///WXXX\n");

/***/ }),

/***/ "a/K1":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorSlider/ColorSlider.styles.js ***!
  \**********************************************************************************************************/
/*! exports provided: getStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyles\", function() { return getStyles; });\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n\nvar hueStyle = {\n    background: \"linear-gradient(\" + [\n        'to left',\n        'red 0',\n        '#f09 10%',\n        '#cd00ff 20%',\n        '#3200ff 30%',\n        '#06f 40%',\n        '#00fffd 50%',\n        '#0f6 60%',\n        '#35ff00 70%',\n        '#cdff00 80%',\n        '#f90 90%',\n        'red 100%',\n    ].join(',') + \")\",\n};\nvar alphaStyle = {\n    backgroundImage: 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAJUlEQVQYV2N89erVfwY0ICYmxoguxjgUFKI7GsTH5m4M3w1ChQC1/Ca8i2n1WgAAAABJRU5ErkJggg==)',\n};\nvar getStyles = function (props) {\n    var _a;\n    // eslint-disable-next-line deprecation/deprecation\n    var theme = props.theme, className = props.className, _b = props.type, type = _b === void 0 ? 'hue' : _b, _c = props.isAlpha, useAlphaBackground = _c === void 0 ? type !== 'hue' : _c;\n    var palette = theme.palette, effects = theme.effects;\n    return {\n        root: [\n            'ms-ColorPicker-slider',\n            {\n                position: 'relative',\n                height: 20,\n                marginBottom: 8,\n                border: \"1px solid \" + palette.neutralLight,\n                borderRadius: effects.roundedCorner2,\n                boxSizing: 'border-box',\n                outline: 'none',\n                selectors: (_a = {},\n                    _a[\".\" + _Utilities__WEBPACK_IMPORTED_MODULE_0__[\"IsFocusVisibleClassName\"] + \" &:focus\"] = {\n                        outline: \"1px solid \" + palette.neutralSecondary,\n                    },\n                    _a),\n            },\n            useAlphaBackground ? alphaStyle : hueStyle,\n            className,\n        ],\n        sliderOverlay: [\n            'ms-ColorPicker-sliderOverlay',\n            {\n                content: '',\n                position: 'absolute',\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0,\n            },\n        ],\n        sliderThumb: [\n            'ms-ColorPicker-thumb',\n            'is-slider',\n            {\n                position: 'absolute',\n                width: 20,\n                height: 20,\n                background: 'white',\n                border: \"1px solid \" + palette.neutralSecondaryAlt,\n                borderRadius: '50%',\n                boxShadow: effects.elevation8,\n                transform: 'translate(-50%, -50%)',\n                top: '50%',\n            },\n        ],\n    };\n};\n//# sourceMappingURL=ColorSlider.styles.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYS9LMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yU2xpZGVyL0NvbG9yU2xpZGVyLnN0eWxlcy5qcz82YmYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElzRm9jdXNWaXNpYmxlQ2xhc3NOYW1lIH0gZnJvbSAnLi4vLi4vLi4vVXRpbGl0aWVzJztcbnZhciBodWVTdHlsZSA9IHtcbiAgICBiYWNrZ3JvdW5kOiBcImxpbmVhci1ncmFkaWVudChcIiArIFtcbiAgICAgICAgJ3RvIGxlZnQnLFxuICAgICAgICAncmVkIDAnLFxuICAgICAgICAnI2YwOSAxMCUnLFxuICAgICAgICAnI2NkMDBmZiAyMCUnLFxuICAgICAgICAnIzMyMDBmZiAzMCUnLFxuICAgICAgICAnIzA2ZiA0MCUnLFxuICAgICAgICAnIzAwZmZmZCA1MCUnLFxuICAgICAgICAnIzBmNiA2MCUnLFxuICAgICAgICAnIzM1ZmYwMCA3MCUnLFxuICAgICAgICAnI2NkZmYwMCA4MCUnLFxuICAgICAgICAnI2Y5MCA5MCUnLFxuICAgICAgICAncmVkIDEwMCUnLFxuICAgIF0uam9pbignLCcpICsgXCIpXCIsXG59O1xudmFyIGFscGhhU3R5bGUgPSB7XG4gICAgYmFja2dyb3VuZEltYWdlOiAndXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQW9BQUFBS0NBWUFBQUNOTXMrOUFBQUFKVWxFUVZRWVYyTjg5ZXJWZndZMElDWW14b2d1eGpnVUZLSTdHc1RINW00TTN3MUNoUUMxL0NhOGkybjFXZ0FBQUFCSlJVNUVya0pnZ2c9PSknLFxufTtcbmV4cG9ydCB2YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHZhciB0aGVtZSA9IHByb3BzLnRoZW1lLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIF9iID0gcHJvcHMudHlwZSwgdHlwZSA9IF9iID09PSB2b2lkIDAgPyAnaHVlJyA6IF9iLCBfYyA9IHByb3BzLmlzQWxwaGEsIHVzZUFscGhhQmFja2dyb3VuZCA9IF9jID09PSB2b2lkIDAgPyB0eXBlICE9PSAnaHVlJyA6IF9jO1xuICAgIHZhciBwYWxldHRlID0gdGhlbWUucGFsZXR0ZSwgZWZmZWN0cyA9IHRoZW1lLmVmZmVjdHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDogW1xuICAgICAgICAgICAgJ21zLUNvbG9yUGlja2VyLXNsaWRlcicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IDgsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIiArIHBhbGV0dGUubmV1dHJhbExpZ2h0LFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogZWZmZWN0cy5yb3VuZGVkQ29ybmVyMixcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgX2FbXCIuXCIgKyBJc0ZvY3VzVmlzaWJsZUNsYXNzTmFtZSArIFwiICY6Zm9jdXNcIl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCBcIiArIHBhbGV0dGUubmV1dHJhbFNlY29uZGFyeSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2EpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZUFscGhhQmFja2dyb3VuZCA/IGFscGhhU3R5bGUgOiBodWVTdHlsZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgXSxcbiAgICAgICAgc2xpZGVyT3ZlcmxheTogW1xuICAgICAgICAgICAgJ21zLUNvbG9yUGlja2VyLXNsaWRlck92ZXJsYXknLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHNsaWRlclRodW1iOiBbXG4gICAgICAgICAgICAnbXMtQ29sb3JQaWNrZXItdGh1bWInLFxuICAgICAgICAgICAgJ2lzLXNsaWRlcicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiICsgcGFsZXR0ZS5uZXV0cmFsU2Vjb25kYXJ5QWx0LFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBlZmZlY3RzLmVsZXZhdGlvbjgsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcbiAgICAgICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yU2xpZGVyLnN0eWxlcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a/K1\n");

/***/ }),

/***/ "bdA+":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorRectangle/ColorRectangle.js ***!
  \*********************************************************************************************************/
/*! exports provided: ColorRectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorRectangle\", function() { return ColorRectangle; });\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n/* harmony import */ var _ColorRectangle_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorRectangle.base */ \"tFdE\");\n/* harmony import */ var _ColorRectangle_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColorRectangle.styles */ \"eaVR\");\n\n\n\nvar ColorRectangle = Object(_Utilities__WEBPACK_IMPORTED_MODULE_0__[\"styled\"])(_ColorRectangle_base__WEBPACK_IMPORTED_MODULE_1__[\"ColorRectangleBase\"], _ColorRectangle_styles__WEBPACK_IMPORTED_MODULE_2__[\"getStyles\"], undefined, { scope: 'ColorRectangle' });\n//# sourceMappingURL=ColorRectangle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmRBKy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUmVjdGFuZ2xlL0NvbG9yUmVjdGFuZ2xlLmpzPzZkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSAnLi4vLi4vLi4vVXRpbGl0aWVzJztcbmltcG9ydCB7IENvbG9yUmVjdGFuZ2xlQmFzZSB9IGZyb20gJy4vQ29sb3JSZWN0YW5nbGUuYmFzZSc7XG5pbXBvcnQgeyBnZXRTdHlsZXMgfSBmcm9tICcuL0NvbG9yUmVjdGFuZ2xlLnN0eWxlcyc7XG5leHBvcnQgdmFyIENvbG9yUmVjdGFuZ2xlID0gc3R5bGVkKENvbG9yUmVjdGFuZ2xlQmFzZSwgZ2V0U3R5bGVzLCB1bmRlZmluZWQsIHsgc2NvcGU6ICdDb2xvclJlY3RhbmdsZScgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclJlY3RhbmdsZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///bdA+\n");

/***/ }),

/***/ "eaVR":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorRectangle/ColorRectangle.styles.js ***!
  \****************************************************************************************************************/
/*! exports provided: getStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyles\", function() { return getStyles; });\n/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Styling */ \"PKiz\");\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n/* harmony import */ var _uifabric_styling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @uifabric/styling */ \"tqYG\");\n\n\n\nvar getStyles = function (props) {\n    var _a;\n    var className = props.className, theme = props.theme, minSize = props.minSize;\n    var palette = theme.palette, effects = theme.effects;\n    return {\n        root: [\n            'ms-ColorPicker-colorRect',\n            {\n                position: 'relative',\n                marginBottom: 8,\n                border: \"1px solid \" + palette.neutralLighter,\n                borderRadius: effects.roundedCorner2,\n                minWidth: minSize,\n                minHeight: minSize,\n                outline: 'none',\n                selectors: (_a = {},\n                    _a[_Styling__WEBPACK_IMPORTED_MODULE_0__[\"HighContrastSelector\"]] = {\n                        MsHighContrastAdjust: 'none',\n                    },\n                    _a[\".\" + _Utilities__WEBPACK_IMPORTED_MODULE_1__[\"IsFocusVisibleClassName\"] + \" &:focus\"] = {\n                        outline: \"1px solid \" + palette.neutralSecondary,\n                    },\n                    _a),\n            },\n            className,\n        ],\n        light: [\n            'ms-ColorPicker-light',\n            {\n                position: 'absolute',\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0,\n                // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n                // and getting all the math and styles flipped correctly is tricky\n                background: 'linear-gradient(to right, white 0%, transparent 100%) /*@noflip*/',\n            },\n        ],\n        dark: [\n            'ms-ColorPicker-dark',\n            {\n                position: 'absolute',\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0,\n                background: 'linear-gradient(to bottom, transparent 0, #000 100%)',\n            },\n        ],\n        thumb: [\n            'ms-ColorPicker-thumb',\n            {\n                position: 'absolute',\n                width: 20,\n                height: 20,\n                background: 'white',\n                border: \"1px solid \" + palette.neutralSecondaryAlt,\n                borderRadius: '50%',\n                boxShadow: effects.elevation8,\n                transform: 'translate(-50%, -50%)',\n                selectors: {\n                    ':before': {\n                        position: 'absolute',\n                        left: 0,\n                        right: 0,\n                        top: 0,\n                        bottom: 0,\n                        border: \"2px solid \" + palette.white,\n                        borderRadius: '50%',\n                        boxSizing: 'border-box',\n                        content: '\"\"',\n                    },\n                },\n            },\n        ],\n        description: _uifabric_styling__WEBPACK_IMPORTED_MODULE_2__[\"hiddenContentStyle\"],\n    };\n};\n//# sourceMappingURL=ColorRectangle.styles.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWFWUi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUmVjdGFuZ2xlL0NvbG9yUmVjdGFuZ2xlLnN0eWxlcy5qcz83OWE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhpZ2hDb250cmFzdFNlbGVjdG9yIH0gZnJvbSAnLi4vLi4vLi4vU3R5bGluZyc7XG5pbXBvcnQgeyBJc0ZvY3VzVmlzaWJsZUNsYXNzTmFtZSB9IGZyb20gJy4uLy4uLy4uL1V0aWxpdGllcyc7XG5pbXBvcnQgeyBoaWRkZW5Db250ZW50U3R5bGUgfSBmcm9tICdAdWlmYWJyaWMvc3R5bGluZyc7XG5leHBvcnQgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCB0aGVtZSA9IHByb3BzLnRoZW1lLCBtaW5TaXplID0gcHJvcHMubWluU2l6ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IHRoZW1lLnBhbGV0dGUsIGVmZmVjdHMgPSB0aGVtZS5lZmZlY3RzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IFtcbiAgICAgICAgICAgICdtcy1Db2xvclBpY2tlci1jb2xvclJlY3QnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogOCxcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiICsgcGFsZXR0ZS5uZXV0cmFsTGlnaHRlcixcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGVmZmVjdHMucm91bmRlZENvcm5lcjIsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IG1pblNpemUsXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiBtaW5TaXplLFxuICAgICAgICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBfYVtcIi5cIiArIElzRm9jdXNWaXNpYmxlQ2xhc3NOYW1lICsgXCIgJjpmb2N1c1wiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IHNvbGlkIFwiICsgcGFsZXR0ZS5uZXV0cmFsU2Vjb25kYXJ5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBfYSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBdLFxuICAgICAgICBsaWdodDogW1xuICAgICAgICAgICAgJ21zLUNvbG9yUGlja2VyLWxpZ2h0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBETyBOT1QgZmxpcCB0aGUgY29sb3IgcGlja2VyIGluIFJUTDogaXRzIG9yaWVudGF0aW9uIGlzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGdldHRpbmcgYWxsIHRoZSBtYXRoIGFuZCBzdHlsZXMgZmxpcHBlZCBjb3JyZWN0bHkgaXMgdHJpY2t5XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCh0byByaWdodCwgd2hpdGUgMCUsIHRyYW5zcGFyZW50IDEwMCUpIC8qQG5vZmxpcCovJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRhcms6IFtcbiAgICAgICAgICAgICdtcy1Db2xvclBpY2tlci1kYXJrJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHRyYW5zcGFyZW50IDAsICMwMDAgMTAwJSknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgdGh1bWI6IFtcbiAgICAgICAgICAgICdtcy1Db2xvclBpY2tlci10aHVtYicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiICsgcGFsZXR0ZS5uZXV0cmFsU2Vjb25kYXJ5QWx0LFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiBlZmZlY3RzLmVsZXZhdGlvbjgsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJzpiZWZvcmUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCIycHggc29saWQgXCIgKyBwYWxldHRlLndoaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkZXNjcmlwdGlvbjogaGlkZGVuQ29udGVudFN0eWxlLFxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JSZWN0YW5nbGUuc3R5bGVzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///eaVR\n");

/***/ }),

/***/ "ihU0":
/*!*********************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ComboBox/ComboBox.js ***!
  \*********************************************************************************/
/*! exports provided: ComboBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComboBox\", function() { return ComboBox; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Autofill_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Autofill/index */ \"W+ks\");\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\n/* harmony import */ var _Callout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Callout */ \"zwhP\");\n/* harmony import */ var _Checkbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Checkbox */ \"+Uuy\");\n/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Button */ \"Fx5H\");\n/* harmony import */ var _common_DirectionalHint__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/DirectionalHint */ \"aupw\");\n/* harmony import */ var _ComboBox_styles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ComboBox.styles */ \"l5g6\");\n/* harmony import */ var _ComboBox_classNames__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ComboBox.classNames */ \"m9Am\");\n/* harmony import */ var _KeytipData__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../KeytipData */ \"i0Ub\");\n/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../Label */ \"4ApC\");\n/* harmony import */ var _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/selectableOption/index */ \"t2Eu\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar SearchDirection;\n(function (SearchDirection) {\n    SearchDirection[SearchDirection[\"backward\"] = -1] = \"backward\";\n    SearchDirection[SearchDirection[\"none\"] = 0] = \"none\";\n    SearchDirection[SearchDirection[\"forward\"] = 1] = \"forward\";\n})(SearchDirection || (SearchDirection = {}));\nvar HoverStatus;\n(function (HoverStatus) {\n    /** Used when the user was hovering and has since moused out of the menu items */\n    HoverStatus[HoverStatus[\"clearAll\"] = -2] = \"clearAll\";\n    /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n    HoverStatus[HoverStatus[\"default\"] = -1] = \"default\";\n})(HoverStatus || (HoverStatus = {}));\nvar ScrollIdleDelay = 250; /* ms */\nvar TouchIdleDelay = 500; /* ms */\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nvar ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n/**\n * Internal class that is used to wrap all ComboBox options.\n * This is used to customize when we want to rerender components,\n * so we don't rerender every option every time render is executed.\n */\nvar ComboBoxOptionWrapper = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ComboBoxOptionWrapper, _super);\n    function ComboBoxOptionWrapper() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ComboBoxOptionWrapper.prototype.render = function () {\n        return this.props.render();\n    };\n    ComboBoxOptionWrapper.prototype.shouldComponentUpdate = function (newProps) {\n        // The render function will always be different, so we ignore that prop\n        return !Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"shallowCompare\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.props), { render: undefined }), Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, newProps), { render: undefined }));\n    };\n    return ComboBoxOptionWrapper;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\nvar COMPONENT_NAME = 'ComboBox';\nvar ComboBox = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ComboBox, _super);\n    function ComboBox(props) {\n        var _this = _super.call(this, props) || this;\n        _this._root = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /** The input aspect of the comboBox */\n        _this._autofill = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /** The wrapping div of the input and button */\n        _this._comboBoxWrapper = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /** The callout element */\n        _this._comboBoxMenu = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /** The menu item element that is currently selected */\n        _this._selectedElement = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        /**\n         * {@inheritdoc}\n         */\n        _this.focus = function (shouldOpenOnFocus, useFocusAsync) {\n            if (_this._autofill.current) {\n                if (useFocusAsync) {\n                    Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"focusAsync\"])(_this._autofill.current);\n                }\n                else {\n                    _this._autofill.current.focus();\n                }\n                if (shouldOpenOnFocus) {\n                    _this.setState({\n                        isOpen: true,\n                    });\n                }\n            }\n            // Programatically setting focus means that there is nothing else that needs to be done\n            // Focus is now contained\n            if (!_this._hasFocus()) {\n                _this.setState({ focusState: 'focused' });\n            }\n        };\n        /**\n         * Close menu callout if it is open\n         */\n        _this.dismissMenu = function () {\n            var isOpen = _this.state.isOpen;\n            isOpen && _this.setState({ isOpen: false });\n        };\n        /**\n         * componentWillReceiveProps handler for the auto fill component\n         * Checks/updates the iput value to set, if needed\n         * @param defaultVisibleValue - the defaultVisibleValue that got passed\n         *  in to the auto fill's componentWillReceiveProps\n         * @returns - the updated value to set, if needed\n         */\n        _this._onUpdateValueInAutofillWillReceiveProps = function () {\n            var comboBox = _this._autofill.current;\n            if (!comboBox) {\n                return null;\n            }\n            if (comboBox.value === null || comboBox.value === undefined) {\n                return null;\n            }\n            var visibleValue = _this._normalizeToString(_this._currentVisibleValue);\n            if (comboBox.value !== visibleValue) {\n                // If visibleValue is empty, ensure that the empty string is used\n                return visibleValue || '';\n            }\n            return comboBox.value;\n        };\n        _this._renderComboBoxWrapper = function (multiselectAccessibleText, errorMessageId, keytipAttributes) {\n            if (keytipAttributes === void 0) { keytipAttributes = {}; }\n            var _a = _this.props, label = _a.label, disabled = _a.disabled, ariaLabel = _a.ariaLabel, ariaDescribedBy = _a.ariaDescribedBy, required = _a.required, errorMessage = _a.errorMessage, allowFreeform = _a.allowFreeform, buttonIconProps = _a.buttonIconProps, _b = _a.isButtonAriaHidden, isButtonAriaHidden = _b === void 0 ? true : _b, title = _a.title, placeholderProp = _a.placeholder, tabIndex = _a.tabIndex, autofill = _a.autofill, iconButtonProps = _a.iconButtonProps;\n            var _c = _this.state, isOpen = _c.isOpen, suggestedDisplayValue = _c.suggestedDisplayValue;\n            // If the combobox has focus, is multiselect, and has a display string, then use that placeholder\n            // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n            // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n            // should be removed and the multiselect combobox should behave like a picker.\n            var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText\n                ? multiselectAccessibleText\n                : placeholderProp;\n            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { \"data-ktp-target\": keytipAttributes['data-ktp-target'], ref: _this._comboBoxWrapper, id: _this._id + 'wrapper', className: _this._classNames.root },\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Autofill_index__WEBPACK_IMPORTED_MODULE_2__[\"Autofill\"], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target'], \"data-is-interactable\": !disabled, componentRef: _this._autofill, id: _this._id + '-input', className: _this._classNames.input, type: \"text\", onFocus: _this._onFocus, onBlur: _this._onBlur, onKeyDown: _this._onInputKeyDown, onKeyUp: _this._onInputKeyUp, onClick: _this._onAutofillClick, onTouchStart: _this._onTouchStart, onInputValueChange: _this._onInputChange, \"aria-expanded\": isOpen, \"aria-autocomplete\": _this._getAriaAutoCompleteValue(), role: \"combobox\", readOnly: disabled || !allowFreeform, \"aria-labelledby\": label && _this._id + '-label', \"aria-label\": ariaLabel && !label ? ariaLabel : undefined, \"aria-describedby\": errorMessage !== undefined\n                        ? Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"mergeAriaAttributeValues\"])(ariaDescribedBy, keytipAttributes['aria-describedby'], errorMessageId)\n                        : Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"mergeAriaAttributeValues\"])(ariaDescribedBy, keytipAttributes['aria-describedby']), \"aria-activedescendant\": _this._getAriaActiveDescendantValue(), \"aria-required\": required, \"aria-disabled\": disabled, \"aria-owns\": isOpen ? _this._id + '-list' : undefined, spellCheck: false, defaultVisibleValue: _this._currentVisibleValue, suggestedDisplayValue: suggestedDisplayValue, updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps, shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate, title: title, preventValueSelection: !_this._hasFocus(), placeholder: placeholder, tabIndex: tabIndex }, autofill)),\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Button__WEBPACK_IMPORTED_MODULE_6__[\"IconButton\"], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ className: 'ms-ComboBox-CaretDown-button', styles: _this._getCaretButtonStyles(), role: \"presentation\", \"aria-hidden\": isButtonAriaHidden, \"data-is-focusable\": false, tabIndex: -1, onClick: _this._onComboBoxClick, onBlur: _this._onBlur, iconProps: buttonIconProps, disabled: disabled, checked: isOpen }, iconButtonProps))));\n        };\n        /**\n         * componentDidUpdate handler for the auto fill component\n         *\n         * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n         * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n         * @returns - should the full value of the input be selected?\n         * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n         */\n        _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function () {\n            return _this._currentVisibleValue === _this.state.suggestedDisplayValue;\n        };\n        /**\n         * Get the correct value to pass to the input\n         * to show to the user based off of the current props and state\n         * @returns the value to pass to the input\n         */\n        _this._getVisibleValue = function () {\n            var _a = _this.props, text = _a.text, allowFreeform = _a.allowFreeform, autoComplete = _a.autoComplete;\n            var _b = _this.state, selectedIndices = _b.selectedIndices, currentPendingValueValidIndex = _b.currentPendingValueValidIndex, currentOptions = _b.currentOptions, currentPendingValue = _b.currentPendingValue, suggestedDisplayValue = _b.suggestedDisplayValue, isOpen = _b.isOpen;\n            var currentPendingIndexValid = _this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n            // If the user passed is a value prop, use that\n            // unless we are open and have a valid current pending index\n            if (!(isOpen && currentPendingIndexValid) &&\n                text &&\n                (currentPendingValue === null || currentPendingValue === undefined)) {\n                return text;\n            }\n            if (_this.props.multiSelect) {\n                // Multi-select\n                if (_this._hasFocus()) {\n                    var index = -1;\n                    if (autoComplete === 'on' && currentPendingIndexValid) {\n                        index = currentPendingValueValidIndex;\n                    }\n                    return _this._getPendingString(currentPendingValue, currentOptions, index);\n                }\n                else {\n                    return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n                }\n            }\n            else {\n                // Single-select\n                var index = _this._getFirstSelectedIndex();\n                if (allowFreeform) {\n                    // If we are allowing freeform and autocomplete is also true\n                    // and we've got a pending value that matches an option, remember\n                    // the matched option's index\n                    if (autoComplete === 'on' && currentPendingIndexValid) {\n                        index = currentPendingValueValidIndex;\n                    }\n                    // Since we are allowing freeform, if there is currently a pending value, use that\n                    // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n                    return _this._getPendingString(currentPendingValue, currentOptions, index);\n                }\n                else {\n                    // If we are not allowing freeform and have a\n                    // valid index that matches the pending value,\n                    // we know we will need some version of the pending value\n                    if (currentPendingIndexValid && autoComplete === 'on') {\n                        // If autoComplete is on, return the\n                        // raw pending value, otherwise remember\n                        // the matched option's index\n                        index = currentPendingValueValidIndex;\n                        return _this._normalizeToString(currentPendingValue);\n                    }\n                    else if (!_this.state.isOpen && currentPendingValue) {\n                        return _this._indexWithinBounds(currentOptions, index)\n                            ? currentPendingValue\n                            : _this._normalizeToString(suggestedDisplayValue);\n                    }\n                    else {\n                        return _this._indexWithinBounds(currentOptions, index)\n                            ? currentOptions[index].text\n                            : _this._normalizeToString(suggestedDisplayValue);\n                    }\n                }\n            }\n        };\n        /**\n         * Handler for typing changes on the input\n         * @param updatedValue - the newly changed value\n         */\n        _this._onInputChange = function (updatedValue) {\n            if (_this.props.disabled) {\n                _this._handleInputWhenDisabled(null /* event */);\n                return;\n            }\n            _this.props.allowFreeform\n                ? _this._processInputChangeWithFreeform(updatedValue)\n                : _this._processInputChangeWithoutFreeform(updatedValue);\n        };\n        /**\n         * Focus (and select) the content of the input\n         * and set the focused state\n         */\n        _this._onFocus = function () {\n            if (_this._autofill.current && _this._autofill.current.inputElement) {\n                _this._autofill.current.inputElement.select();\n            }\n            if (!_this._hasFocus()) {\n                _this.setState({ focusState: 'focusing' });\n            }\n        };\n        /**\n         * Callback issued when the options should be resolved, if they have been updated or\n         * if they need to be passed in the first time. This only does work if an onResolveOptions\n         * callback was passed in\n         */\n        _this._onResolveOptions = function () {\n            if (_this.props.onResolveOptions) {\n                // get the options\n                var newOptions = _this.props.onResolveOptions(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spreadArrays\"])(_this.state.currentOptions));\n                // Check to see if the returned value is an array, if it is update the state\n                // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n                // If it is then resolve it asynchronously.\n                if (Array.isArray(newOptions)) {\n                    _this.setState({\n                        currentOptions: newOptions,\n                    });\n                }\n                else if (newOptions && newOptions.then) {\n                    // Ensure that the promise will only use the callback if it was the most recent one\n                    // and update the state when the promise returns\n                    var promise_1 = (_this._currentPromise = newOptions);\n                    promise_1.then(function (newOptionsFromPromise) {\n                        if (promise_1 === _this._currentPromise) {\n                            _this.setState({\n                                currentOptions: newOptionsFromPromise,\n                            });\n                        }\n                    });\n                }\n            }\n        };\n        /**\n         * OnBlur handler. Set the focused state to false\n         * and submit any pending value\n         */\n        // eslint-disable-next-line deprecation/deprecation\n        _this._onBlur = function (event) {\n            // Do nothing if the blur is coming from something\n            // inside the comboBox root or the comboBox menu since\n            // it we are not really bluring from the whole comboBox\n            var relatedTarget = event.relatedTarget;\n            if (event.relatedTarget === null) {\n                // In IE11, due to lack of support, event.relatedTarget is always\n                // null making every onBlur call to be \"outside\" of the ComboBox\n                // even when it's not. Using document.activeElement is another way\n                // for us to be able to get what the relatedTarget without relying\n                // on the event\n                relatedTarget = document.activeElement;\n            }\n            if (relatedTarget &&\n                // when event coming from withing the comboBox title\n                ((_this._root.current && _this._root.current.contains(relatedTarget)) ||\n                    // when event coming from within the comboBox list menu\n                    (_this._comboBoxMenu.current &&\n                        (_this._comboBoxMenu.current.contains(relatedTarget) ||\n                            // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the\n                            // Callout is clicked) checks if the relatedTarget is a parent of _comboBoxMenu\n                            Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"findElementRecursive\"])(_this._comboBoxMenu.current, function (element) { return element === relatedTarget; }))))) {\n                event.preventDefault();\n                event.stopPropagation();\n                return;\n            }\n            if (_this._hasFocus()) {\n                _this.setState({ focusState: 'none' });\n                if (!_this.props.multiSelect || _this.props.allowFreeform) {\n                    _this._submitPendingValue(event);\n                }\n            }\n        };\n        // Render Callout container and pass in list\n        _this._onRenderContainer = function (props) {\n            var onRenderList = props.onRenderList, calloutProps = props.calloutProps, dropdownWidth = props.dropdownWidth, dropdownMaxWidth = props.dropdownMaxWidth, _a = props.onRenderUpperContent, onRenderUpperContent = _a === void 0 ? _this._onRenderUpperContent : _a, _b = props.onRenderLowerContent, onRenderLowerContent = _b === void 0 ? _this._onRenderLowerContent : _b, useComboBoxAsMenuWidth = props.useComboBoxAsMenuWidth, persistMenu = props.persistMenu, _c = props.shouldRestoreFocus, shouldRestoreFocus = _c === void 0 ? true : _c;\n            var isOpen = _this.state.isOpen;\n            var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current\n                ? _this._comboBoxWrapper.current.clientWidth + 2\n                : undefined;\n            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Callout__WEBPACK_IMPORTED_MODULE_4__[\"Callout\"], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHint: _common_DirectionalHint__WEBPACK_IMPORTED_MODULE_7__[\"DirectionalHint\"].bottomLeftEdge, directionalHintFixed: false }, calloutProps, { onLayerMounted: _this._onLayerMounted, className: Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"css\"])(_this._classNames.callout, calloutProps ? calloutProps.className : undefined), target: _this._comboBoxWrapper.current, onDismiss: _this._onDismiss, onMouseDown: _this._onCalloutMouseDown, onScroll: _this._onScroll, setInitialFocus: false, calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current\n                    ? comboBoxMenuWidth && comboBoxMenuWidth\n                    : dropdownWidth, calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth, hidden: persistMenu ? !isOpen : undefined, shouldRestoreFocus: shouldRestoreFocus }),\n                onRenderUpperContent(_this.props, _this._onRenderUpperContent),\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: _this._classNames.optionsContainerWrapper, ref: _this._comboBoxMenu }, onRenderList(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, props), _this._onRenderList)),\n                onRenderLowerContent(_this.props, _this._onRenderLowerContent)));\n        };\n        _this._onLayerMounted = function () {\n            _this._onCalloutLayerMounted();\n            if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {\n                _this.props.calloutProps.onLayerMounted();\n            }\n        };\n        _this._onRenderLabel = function (onRenderLabelProps) {\n            var _a = onRenderLabelProps.props, label = _a.label, disabled = _a.disabled, required = _a.required;\n            if (label) {\n                return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Label__WEBPACK_IMPORTED_MODULE_11__[\"Label\"], { id: _this._id + '-label', disabled: disabled, required: required, className: _this._classNames.label },\n                    label,\n                    onRenderLabelProps.multiselectAccessibleText && (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"span\", { className: _this._classNames.screenReaderText }, onRenderLabelProps.multiselectAccessibleText))));\n            }\n            return null;\n        };\n        // Render List of items\n        _this._onRenderList = function (props) {\n            var onRenderItem = props.onRenderItem, options = props.options;\n            var id = _this._id;\n            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { id: id + '-list', className: _this._classNames.optionsContainer, \"aria-labelledby\": id + '-label', role: \"listbox\" }, options.map(function (item) { return onRenderItem(item, _this._onRenderItem); })));\n        };\n        // Render items\n        _this._onRenderItem = function (item) {\n            switch (item.itemType) {\n                case _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider:\n                    return _this._renderSeparator(item);\n                case _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header:\n                    return _this._renderHeader(item);\n                default:\n                    return _this._renderOption(item);\n            }\n        };\n        // Default _onRenderLowerContent function returns nothing\n        _this._onRenderLowerContent = function () {\n            return null;\n        };\n        // Default _onRenderUpperContent function returns nothing\n        _this._onRenderUpperContent = function () {\n            return null;\n        };\n        _this._renderOption = function (item) {\n            var _a = _this.props.onRenderOption, onRenderOption = _a === void 0 ? _this._onRenderOptionContent : _a;\n            var id = _this._id;\n            var isSelected = _this._isOptionSelected(item.index);\n            var isChecked = _this._isOptionChecked(item.index);\n            var optionStyles = _this._getCurrentOptionStyles(item);\n            var optionClassNames = Object(_ComboBox_classNames__WEBPACK_IMPORTED_MODULE_9__[\"getComboBoxOptionClassNames\"])(_this._getCurrentOptionStyles(item));\n            var title = _this._getPreviewText(item);\n            var onRenderCheckboxLabel = function () { return onRenderOption(item, _this._onRenderOptionContent); };\n            var getOptionComponent = function () {\n                return !_this.props.multiSelect ? (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Button__WEBPACK_IMPORTED_MODULE_6__[\"CommandButton\"], { id: id + '-list' + item.index, key: item.key, \"data-index\": item.index, styles: optionStyles, checked: isSelected, className: 'ms-ComboBox-option', onClick: _this._onItemClick(item), \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index), \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onMouseMove: _this._onOptionMouseMove.bind(_this, item.index), onMouseLeave: _this._onOptionMouseLeave, role: \"option\", \"aria-selected\": isSelected ? 'true' : 'false', ariaLabel: _this._getPreviewText(item), disabled: item.disabled, title: title }, react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"span\", { className: optionClassNames.optionTextWrapper, ref: isSelected ? _this._selectedElement : undefined }, onRenderOption(item, _this._onRenderOptionContent)))) : (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_Checkbox__WEBPACK_IMPORTED_MODULE_5__[\"Checkbox\"], { id: id + '-list' + item.index, ariaLabel: _this._getPreviewText(item), key: item.key, \"data-index\": item.index, styles: optionStyles, className: 'ms-ComboBox-option', \"data-is-focusable\": true, onChange: _this._onItemClick(item), label: item.text, role: \"option\", checked: isChecked, title: title, disabled: item.disabled, \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onRenderLabel: onRenderCheckboxLabel, inputProps: {\n                        'aria-selected': isSelected ? 'true' : 'false',\n                    } }));\n            };\n            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](ComboBoxOptionWrapper, { key: item.key, index: item.index, disabled: item.disabled, isSelected: isSelected, isChecked: isChecked, text: item.text, \n                // eslint-disable-next-line react/jsx-no-bind\n                render: getOptionComponent, data: item.data }));\n        };\n        /**\n         * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n         */\n        _this._onCalloutMouseDown = function (ev) {\n            ev.preventDefault();\n        };\n        /**\n         * Scroll handler for the callout to make sure the mouse events\n         * for updating focus are not interacting during scroll\n         */\n        _this._onScroll = function () {\n            if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n                _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n                _this._scrollIdleTimeoutId = undefined;\n            }\n            else {\n                _this._isScrollIdle = false;\n            }\n            _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n                _this._isScrollIdle = true;\n            }, ScrollIdleDelay);\n        };\n        _this._onRenderOptionContent = function (item) {\n            var optionClassNames = Object(_ComboBox_classNames__WEBPACK_IMPORTED_MODULE_9__[\"getComboBoxOptionClassNames\"])(_this._getCurrentOptionStyles(item));\n            return react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"span\", { className: optionClassNames.optionText }, item.text);\n        };\n        /**\n         * Handles dismissing (cancelling) the menu\n         */\n        _this._onDismiss = function () {\n            var onMenuDismiss = _this.props.onMenuDismiss;\n            if (onMenuDismiss) {\n                onMenuDismiss();\n            }\n            // In persistMode we need to simulate callout layer mount\n            // since that only happens once. We do it on dismiss since\n            // it works either way.\n            if (_this.props.persistMenu) {\n                _this._onCalloutLayerMounted();\n            }\n            // close the menu\n            _this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n            // reset the selected index\n            // to the last value state\n            _this._resetSelectedIndex();\n        };\n        _this._onAfterClearPendingInfo = function () {\n            _this._processingClearPendingInfo = false;\n        };\n        /**\n         * Handle keydown on the input\n         * @param ev - The keyboard event that was fired\n         */\n        _this._onInputKeyDown = function (ev) {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform, autoComplete = _a.autoComplete;\n            var _b = _this.state, isOpen = _b.isOpen, currentOptions = _b.currentOptions, currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover;\n            // Take note if we are processing an alt (option) or meta (command) keydown.\n            // See comment in _onInputKeyUp for reasoning.\n            _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n            if (disabled) {\n                _this._handleInputWhenDisabled(ev);\n                return;\n            }\n            var index = _this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n            switch (ev.which) {\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].enter:\n                    if (_this._autofill.current && _this._autofill.current.inputElement) {\n                        _this._autofill.current.inputElement.select();\n                    }\n                    _this._submitPendingValue(ev);\n                    if (_this.props.multiSelect && isOpen) {\n                        _this.setState({\n                            currentPendingValueValidIndex: index,\n                        });\n                    }\n                    else {\n                        // On enter submit the pending value\n                        if (isOpen ||\n                            ((!allowFreeform ||\n                                _this.state.currentPendingValue === undefined ||\n                                _this.state.currentPendingValue === null ||\n                                _this.state.currentPendingValue.length <= 0) &&\n                                _this.state.currentPendingValueValidIndex < 0)) {\n                            // if we are open or\n                            // if we are not allowing freeform or\n                            // our we have no pending value\n                            // and no valid pending index\n                            // flip the open state\n                            _this.setState({\n                                isOpen: !isOpen,\n                            });\n                        }\n                    }\n                    break;\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].tab:\n                    // On enter submit the pending value\n                    if (!_this.props.multiSelect) {\n                        _this._submitPendingValue(ev);\n                    }\n                    // If we are not allowing freeform\n                    // or the comboBox is open, flip the open state\n                    if (isOpen) {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n                    }\n                    // Allow TAB to propigate\n                    return;\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].escape:\n                    // reset the selected index\n                    _this._resetSelectedIndex();\n                    // Close the menu if opened\n                    if (isOpen) {\n                        _this.setState({\n                            isOpen: false,\n                        });\n                    }\n                    else {\n                        return;\n                    }\n                    break;\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].up:\n                    // if we are in clearAll state (e.g. the user as hovering\n                    // and has since mousedOut of the menu items),\n                    // go to the last index\n                    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n                        index = _this.state.currentOptions.length;\n                    }\n                    if (ev.altKey || ev.metaKey) {\n                        // Close the menu if it is open and break so\n                        // that the event get stopPropagation and prevent default.\n                        // Otherwise, we need to let the event continue to propagate\n                        if (isOpen) {\n                            _this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n                            break;\n                        }\n                        return;\n                    }\n                    // Go to the previous option\n                    _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n                    break;\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].down:\n                    // Expand the comboBox on ALT + DownArrow\n                    if (ev.altKey || ev.metaKey) {\n                        _this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n                    }\n                    else {\n                        // if we are in clearAll state (e.g. the user as hovering\n                        // and has since mousedOut of the menu items),\n                        // go to the first index\n                        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n                            index = -1;\n                        }\n                        // Got to the next option\n                        _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n                    }\n                    break;\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].home:\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].end:\n                    if (allowFreeform) {\n                        return;\n                    }\n                    // Set the initial values to respond to HOME\n                    // which goes to the first selectable option\n                    index = -1;\n                    var directionToSearch = SearchDirection.forward;\n                    // If end, update the values to respond to END\n                    // which goes to the last selectable option\n                    if (ev.which === _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].end) {\n                        index = currentOptions.length;\n                        directionToSearch = SearchDirection.backward;\n                    }\n                    _this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n                    break;\n                /* eslint-disable no-fallthrough */\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].space:\n                    // event handled in _onComboBoxKeyUp\n                    if (!allowFreeform && autoComplete === 'off') {\n                        break;\n                    }\n                default:\n                    /* eslint-enable no-fallthrough */\n                    // are we processing a function key? if so bail out\n                    if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n                        return;\n                    }\n                    // If we get here and we got either and ALT key\n                    // or meta key, let the event propagate\n                    if (ev.keyCode === _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].alt || ev.key === 'Meta' /* && isOpen */) {\n                        return;\n                    }\n                    // If we are not allowing freeform and\n                    // allowing autoComplete, handle the input here\n                    // since we have marked the input as readonly\n                    if (!allowFreeform && autoComplete === 'on') {\n                        _this._onInputChange(ev.key);\n                        break;\n                    }\n                    // allow the key to propagate by default\n                    return;\n            }\n            ev.stopPropagation();\n            ev.preventDefault();\n        };\n        /**\n         * Handle keyup on the input\n         * @param ev - the keyboard event that was fired\n         */\n        _this._onInputKeyUp = function (ev) {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform, autoComplete = _a.autoComplete;\n            var isOpen = _this.state.isOpen;\n            // We close the menu on key up only if ALL of the following are true:\n            // - Most recent key down was alt or meta (command)\n            // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n            //   expand/collapse the menu)\n            // - We're not on a Mac (or iOS)\n            // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n            // closing any open context menus. There is not a similar behavior on Macs.\n            var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n            _this._lastKeyDownWasAltOrMeta = false;\n            var shouldHandleKey = keyPressIsAltOrMetaAlone && !(Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"isMac\"])() || Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"isIOS\"])());\n            if (disabled) {\n                _this._handleInputWhenDisabled(ev);\n                return;\n            }\n            switch (ev.which) {\n                case _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].space:\n                    // If we are not allowing freeform and are not autoComplete\n                    // make space expand/collapse the comboBox\n                    // and allow the event to propagate\n                    if (!allowFreeform && autoComplete === 'off') {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n                    }\n                    return;\n                default:\n                    if (shouldHandleKey && isOpen) {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n                    }\n                    else {\n                        if (_this.state.focusState === 'focusing' && _this.props.openOnKeyboardFocus) {\n                            _this.setState({ isOpen: true });\n                        }\n                        if (_this.state.focusState !== 'focused') {\n                            _this.setState({ focusState: 'focused' });\n                        }\n                    }\n                    return;\n            }\n        };\n        _this._onOptionMouseLeave = function () {\n            if (_this._shouldIgnoreMouseEvent()) {\n                return;\n            }\n            // Ignore the event in persistMenu mode if the callout has\n            // closed. This is to avoid clearing the visuals on item click.\n            if (_this.props.persistMenu && !_this.state.isOpen) {\n                return;\n            }\n            _this.setState({\n                currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n            });\n        };\n        /**\n         * Click handler for the button of the comboBox\n         * and the input when not allowing freeform. This\n         * toggles the expand/collapse state of the comboBox (if enbled)\n         */\n        _this._onComboBoxClick = function () {\n            var disabled = _this.props.disabled;\n            var isOpen = _this.state.isOpen;\n            if (!disabled) {\n                _this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n                _this.setState({ focusState: 'focused' });\n            }\n        };\n        /**\n         * Click handler for the autofill.\n         */\n        _this._onAutofillClick = function () {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform;\n            if (allowFreeform && !disabled) {\n                _this.focus(_this.state.isOpen || _this._processingTouch);\n            }\n            else {\n                _this._onComboBoxClick();\n            }\n        };\n        _this._onTouchStart = function () {\n            if (_this._comboBoxWrapper.current && !('onpointerdown' in _this._comboBoxWrapper)) {\n                _this._handleTouchAndPointerEvent();\n            }\n        };\n        _this._onPointerDown = function (ev) {\n            if (ev.pointerType === 'touch') {\n                _this._handleTouchAndPointerEvent();\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n            }\n        };\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"initializeComponentRef\"])(_this);\n        _this._async = new _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"Async\"](_this);\n        _this._events = new _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"EventGroup\"](_this);\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"warnMutuallyExclusive\"])(COMPONENT_NAME, props, {\n            defaultSelectedKey: 'selectedKey',\n            text: 'defaultSelectedKey',\n            selectedKey: 'value',\n            dropdownWidth: 'useComboBoxAsMenuWidth',\n        });\n        _this._id = props.id || Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"getId\"])('ComboBox');\n        var selectedKeys = _this._buildDefaultSelectedKeys(props.defaultSelectedKey, props.selectedKey);\n        _this._isScrollIdle = true;\n        _this._processingTouch = false;\n        _this._gotMouseMove = false;\n        _this._processingClearPendingInfo = false;\n        var initialSelectedIndices = _this._getSelectedIndices(props.options, selectedKeys);\n        _this.state = {\n            isOpen: false,\n            selectedIndices: initialSelectedIndices,\n            focusState: 'none',\n            suggestedDisplayValue: undefined,\n            currentOptions: _this.props.options,\n            currentPendingValueValidIndex: -1,\n            currentPendingValue: undefined,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        };\n        return _this;\n    }\n    Object.defineProperty(ComboBox.prototype, \"selectedOptions\", {\n        /**\n         * All selected options\n         */\n        get: function () {\n            var _a = this.state, currentOptions = _a.currentOptions, selectedIndices = _a.selectedIndices;\n            return Object(_utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"getAllSelectedOptions\"])(currentOptions, selectedIndices);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ComboBox.prototype.componentDidMount = function () {\n        if (this._comboBoxWrapper.current && !this.props.disabled) {\n            // hook up resolving the options if needed on focus\n            this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n            if ('onpointerdown' in this._comboBoxWrapper.current) {\n                // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n                // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n                // does not support Pointer events yet.\n                this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n            }\n        }\n    };\n    ComboBox.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n        // Update the selectedIndex and currentOptions state if\n        // the selectedKey, value, or options have changed\n        if (newProps.selectedKey !== this.props.selectedKey ||\n            newProps.text !== this.props.text ||\n            newProps.options !== this.props.options) {\n            var selectedKeys = this._buildSelectedKeys(newProps.selectedKey);\n            var indices = this._getSelectedIndices(newProps.options, selectedKeys);\n            this.setState({\n                selectedIndices: indices,\n                currentOptions: newProps.options,\n            });\n            if (newProps.selectedKey === null) {\n                this.setState({\n                    suggestedDisplayValue: undefined,\n                });\n            }\n        }\n    };\n    ComboBox.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _this = this;\n        var _a = this.props, allowFreeform = _a.allowFreeform, text = _a.text, onMenuOpen = _a.onMenuOpen, onMenuDismissed = _a.onMenuDismissed;\n        var _b = this.state, isOpen = _b.isOpen, selectedIndices = _b.selectedIndices, currentPendingValueValidIndex = _b.currentPendingValueValidIndex;\n        // If we are newly open or are open and the pending valid index changed,\n        // make sure the currently selected/pending option is scrolled into view\n        if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n            // Need this timeout so that the selectedElement ref is correctly updated\n            this._async.setTimeout(function () { return _this._scrollIntoView(); }, 0);\n        }\n        // if an action is taken that put focus in the ComboBox\n        // and If we are open or we are just closed, shouldFocusAfterClose is set,\n        // but we are not the activeElement set focus on the input\n        if (this._hasFocus() &&\n            (isOpen ||\n                (prevState.isOpen &&\n                    !isOpen &&\n                    this._focusInputAfterClose &&\n                    this._autofill.current &&\n                    document.activeElement !== this._autofill.current.inputElement))) {\n            this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n        }\n        // If we should focusAfterClose AND\n        //   just opened/closed the menu OR\n        //   are focused AND\n        //     updated the selectedIndex with the menu closed OR\n        //     are not allowing freeform OR\n        //     the value changed\n        // we need to set selection\n        if (this._focusInputAfterClose &&\n            ((prevState.isOpen && !isOpen) ||\n                (this._hasFocus() &&\n                    ((!isOpen &&\n                        !this.props.multiSelect &&\n                        prevState.selectedIndices &&\n                        selectedIndices &&\n                        prevState.selectedIndices[0] !== selectedIndices[0]) ||\n                        !allowFreeform ||\n                        text !== prevProps.text)))) {\n            this._onFocus();\n        }\n        this._notifyPendingValueChanged(prevState);\n        if (isOpen && !prevState.isOpen && onMenuOpen) {\n            onMenuOpen();\n        }\n        if (!isOpen && prevState.isOpen && onMenuDismissed) {\n            onMenuDismissed();\n        }\n    };\n    ComboBox.prototype.componentWillUnmount = function () {\n        this._async.dispose();\n        this._events.dispose();\n    };\n    // Primary Render\n    ComboBox.prototype.render = function () {\n        var _this = this;\n        var id = this._id;\n        var errorMessageId = id + '-error';\n        var _a = this.props, className = _a.className, disabled = _a.disabled, required = _a.required, errorMessage = _a.errorMessage, _b = _a.onRenderContainer, onRenderContainer = _b === void 0 ? this._onRenderContainer : _b, _c = _a.onRenderLabel, onRenderLabel = _c === void 0 ? this._onRenderLabel : _c, _d = _a.onRenderList, onRenderList = _d === void 0 ? this._onRenderList : _d, _e = _a.onRenderItem, onRenderItem = _e === void 0 ? this._onRenderItem : _e, _f = _a.onRenderOption, onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f, allowFreeform = _a.allowFreeform, customStyles = _a.styles, theme = _a.theme, keytipProps = _a.keytipProps, persistMenu = _a.persistMenu, multiSelect = _a.multiSelect;\n        var _g = this.state, isOpen = _g.isOpen, suggestedDisplayValue = _g.suggestedDisplayValue;\n        this._currentVisibleValue = this._getVisibleValue();\n        // Single select is already accessible since the whole text is selected\n        // when focus enters the input. Since multiselect appears to clear the input\n        // it needs special accessible text\n        var multiselectAccessibleText = multiSelect\n            ? this._getMultiselectDisplayString(this.state.selectedIndices, this.state.currentOptions, suggestedDisplayValue)\n            : undefined;\n        var divProps = Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"getNativeProps\"])(this.props, _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"divProperties\"], [\n            'onChange',\n            'value',\n        ]);\n        var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n        this._classNames = this.props.getClassNames\n            ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className)\n            : Object(_ComboBox_classNames__WEBPACK_IMPORTED_MODULE_9__[\"getClassNames\"])(Object(_ComboBox_styles__WEBPACK_IMPORTED_MODULE_8__[\"getStyles\"])(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);\n        var comboBoxWrapper = keytipProps ? (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_KeytipData__WEBPACK_IMPORTED_MODULE_10__[\"KeytipData\"], { keytipProps: keytipProps, disabled: disabled }, function (keytipAttributes) {\n            return _this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId, keytipAttributes);\n        })) : (this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId));\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, divProps, { ref: this._root, className: this._classNames.container }),\n            onRenderLabel({ props: this.props, multiselectAccessibleText: multiselectAccessibleText }, this._onRenderLabel),\n            comboBoxWrapper,\n            (persistMenu || isOpen) &&\n                onRenderContainer(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.props), { onRenderList: onRenderList,\n                    onRenderItem: onRenderItem,\n                    onRenderOption: onRenderOption, options: this.state.currentOptions.map(function (item, index) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, item), { index: index })); }), onDismiss: this._onDismiss }), this._onRenderContainer),\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { role: \"region\", \"aria-live\": \"polite\", \"aria-atomic\": \"true\", id: errorMessageId, className: hasErrorMessage ? this._classNames.errorMessage : '' }, errorMessage !== undefined ? errorMessage : '')));\n    };\n    ComboBox.prototype._getPendingString = function (currentPendingValue, currentOptions, index) {\n        return currentPendingValue !== null && currentPendingValue !== undefined\n            ? currentPendingValue\n            : this._indexWithinBounds(currentOptions, index)\n                ? currentOptions[index].text\n                : '';\n    };\n    /**\n     * Returns a string that concatenates all of the selected values\n     * for multiselect combobox.\n     */\n    ComboBox.prototype._getMultiselectDisplayString = function (selectedIndices, currentOptions, suggestedDisplayValue) {\n        var displayValues = [];\n        for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n            var index = selectedIndices[idx];\n            displayValues.push(this._indexWithinBounds(currentOptions, index)\n                ? currentOptions[index].text\n                : this._normalizeToString(suggestedDisplayValue));\n        }\n        var _a = this.props.multiSelectDelimiter, multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n        return displayValues.join(multiSelectDelimiter);\n    };\n    /**\n     * Is the index within the bounds of the array?\n     * @param options - options to check if the index is valid for\n     * @param index - the index to check\n     * @returns - true if the index is valid for the given options, false otherwise\n     */\n    ComboBox.prototype._indexWithinBounds = function (options, index) {\n        if (!options) {\n            return false;\n        }\n        return index >= 0 && index < options.length;\n    };\n    /**\n     * Process the new input's new value when the comboBox\n     * allows freeform entry\n     * @param updatedValue - the input's newly changed value\n     */\n    ComboBox.prototype._processInputChangeWithFreeform = function (updatedValue) {\n        var _this = this;\n        var currentOptions = this.state.currentOptions;\n        var newCurrentPendingValueValidIndex = -1;\n        // if the new value is empty, see if we have an exact match\n        // and then set the pending info\n        if (updatedValue === '') {\n            var items = currentOptions\n                .map(function (item, index) {\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, item), { index: index });\n            })\n                .filter(function (option) {\n                return option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header &&\n                    option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider;\n            })\n                .filter(function (option) { return _this._getPreviewText(option) === updatedValue; });\n            // if we found a match remember the index\n            if (items.length === 1) {\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n            this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n            return;\n        }\n        // Remember the original value and then,\n        // make the value lowercase for comparison\n        var originalUpdatedValue = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase();\n        var newSuggestedDisplayValue = '';\n        // If autoComplete is on, attempt to find a match from the available options\n        if (this.props.autoComplete === 'on') {\n            // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n            var items = currentOptions\n                .map(function (item, index) {\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, item), { index: index });\n            })\n                .filter(function (option) {\n                return option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header &&\n                    option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider;\n            })\n                .filter(function (option) {\n                return _this._getPreviewText(option)\n                    .toLocaleLowerCase()\n                    .indexOf(updatedValue) === 0;\n            });\n            if (items.length > 0) {\n                // use ariaLabel as the value when the option is set\n                var text = this._getPreviewText(items[0]);\n                // If the user typed out the complete option text, we don't need any suggested display text anymore\n                newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\n                // remember the index of the match we found\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n        }\n        else {\n            // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n            var items = currentOptions\n                .map(function (item, index) {\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, item), { index: index });\n            })\n                .filter(function (option) {\n                return option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header &&\n                    option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider;\n            })\n                .filter(function (option) { return _this._getPreviewText(option).toLocaleLowerCase() === updatedValue; });\n            // if we found a match remember the index\n            if (items.length === 1) {\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n        }\n        // Set the updated state\n        this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n    };\n    /**\n     * Process the new input's new value when the comboBox\n     * does not allow freeform entry\n     * @param updatedValue - the input's newly changed value\n     */\n    ComboBox.prototype._processInputChangeWithoutFreeform = function (updatedValue) {\n        var _this = this;\n        var _a = this.state, currentPendingValue = _a.currentPendingValue, currentPendingValueValidIndex = _a.currentPendingValueValidIndex, currentOptions = _a.currentOptions;\n        if (this.props.autoComplete === 'on') {\n            // If autoComplete is on while allow freeform is off,\n            // we will remember the keypresses and build up a string to attempt to match\n            // as long as characters are typed within a the timeout span of each other,\n            // otherwise we will clear the string and start building a new one on the next keypress.\n            // Also, only do this processing if we have a non-empty value\n            if (updatedValue !== '') {\n                // If we have a pending autocomplete clearing task,\n                // we know that the user is typing with keypresses happening\n                // within the timeout of each other so remove the clearing task\n                // and continue building the pending value with the udpated value\n                if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\n                    this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\n                    this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n                    updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;\n                }\n                var originalUpdatedValue = updatedValue;\n                updatedValue = updatedValue.toLocaleLowerCase();\n                // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n                var items = currentOptions\n                    .map(function (item, i) {\n                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, item), { index: i });\n                })\n                    .filter(function (option) {\n                    return option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header &&\n                        option.itemType !== _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider;\n                })\n                    .filter(function (option) { return option.text.toLocaleLowerCase().indexOf(updatedValue) === 0; });\n                // If we found a match, udpdate the state\n                if (items.length > 0) {\n                    this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\n                }\n                // Schedule a timeout to clear the pending value after the timeout span\n                this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(function () {\n                    _this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n                }, ReadOnlyPendingAutoCompleteTimeout);\n                return;\n            }\n        }\n        // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n        // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n        // use that; otherwise use the selectedIndex\n        var index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n        // Since we are not allowing freeform, we need to\n        // set both the pending and suggested values/index\n        // to allow us to select all content in the input to\n        // give the illusion that we are readonly (e.g. freeform off)\n        this._setPendingInfoFromIndex(index);\n    };\n    ComboBox.prototype._getFirstSelectedIndex = function () {\n        return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;\n    };\n    /**\n     * Walk along the options starting at the index, stepping by the delta (positive or negative)\n     * looking for the next valid selectable index (e.g. skipping headings and dividers)\n     * @param index - the index to get the next selectable index from\n     * @param delta - optional delta to step by when finding the next index, defaults to 0\n     * @returns - the next valid selectable index. If the new index is outside of the bounds,\n     * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n     */\n    ComboBox.prototype._getNextSelectableIndex = function (index, searchDirection) {\n        var currentOptions = this.state.currentOptions;\n        var newIndex = index + searchDirection;\n        newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n        if (!this._indexWithinBounds(currentOptions, newIndex)) {\n            return -1;\n        }\n        var option = currentOptions[newIndex];\n        if (option.itemType === _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Header ||\n            option.itemType === _utilities_selectableOption_index__WEBPACK_IMPORTED_MODULE_12__[\"SelectableOptionMenuItemType\"].Divider ||\n            option.hidden === true) {\n            // Should we continue looking for an index to select?\n            if (searchDirection !== SearchDirection.none &&\n                ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n                    (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))) {\n                newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n            }\n            else {\n                // If we cannot perform a useful search just return the index we were given\n                return index;\n            }\n        }\n        // We have the next valid selectable index, return it\n        return newIndex;\n    };\n    /**\n     * Set the selected index. Note, this is\n     * the \"real\" selected index, not the pending selected index\n     * @param index - the index to set (or the index to set from if a search direction is provided)\n     * @param searchDirection - the direction to search along the options from the given index\n     */\n    ComboBox.prototype._setSelectedIndex = function (index, submitPendingValueEvent, searchDirection) {\n        var _this = this;\n        if (searchDirection === void 0) { searchDirection = SearchDirection.none; }\n        var _a = this.props, onChange = _a.onChange, onPendingValueChanged = _a.onPendingValueChanged;\n        var currentOptions = this.state.currentOptions;\n        var initialIndices = this.state.selectedIndices;\n        // Clone selectedIndices so we don't mutate state\n        var selectedIndices = initialIndices ? initialIndices.slice() : [];\n        // Find the next selectable index, if searchDirection is none\n        // we will get our starting index back\n        index = this._getNextSelectableIndex(index, searchDirection);\n        if (!this._indexWithinBounds(currentOptions, index)) {\n            return;\n        }\n        // Are we at a new index? If so, update the state, otherwise\n        // there is nothing to do\n        if (this.props.multiSelect ||\n            selectedIndices.length < 1 ||\n            (selectedIndices.length === 1 && selectedIndices[0] !== index)) {\n            var option_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, currentOptions[index]);\n            // if option doesn't existing, or option is disabled, we noop\n            if (!option_1 || option_1.disabled) {\n                return;\n            }\n            if (this.props.multiSelect) {\n                // Setting the initial state of option.selected in Multi-select combobox by checking the\n                // selectedIndices array and overriding the undefined issue\n                option_1.selected = option_1.selected !== undefined ? !option_1.selected : selectedIndices.indexOf(index) < 0;\n                if (option_1.selected && selectedIndices.indexOf(index) < 0) {\n                    selectedIndices.push(index);\n                }\n                else if (!option_1.selected && selectedIndices.indexOf(index) >= 0) {\n                    selectedIndices = selectedIndices.filter(function (value) { return value !== index; });\n                }\n            }\n            else {\n                selectedIndices[0] = index;\n            }\n            submitPendingValueEvent.persist();\n            // Only setstate if combobox is uncontrolled.\n            if (this.props.selectedKey || this.props.selectedKey === null) {\n                // If ComboBox value is changed, revert preview first\n                if (this._hasPendingValue && onPendingValueChanged) {\n                    onPendingValueChanged();\n                    this._hasPendingValue = false;\n                }\n                if (onChange) {\n                    onChange(submitPendingValueEvent, option_1, index, undefined);\n                }\n            }\n            else {\n                // Update current options\n                var changedOptions = currentOptions.slice();\n                changedOptions[index] = option_1;\n                // Call onChange after state is updated\n                this.setState({\n                    selectedIndices: selectedIndices,\n                    currentOptions: changedOptions,\n                }, function () {\n                    // If ComboBox value is changed, revert preview first\n                    if (_this._hasPendingValue && onPendingValueChanged) {\n                        onPendingValueChanged();\n                        _this._hasPendingValue = false;\n                    }\n                    if (onChange) {\n                        onChange(submitPendingValueEvent, option_1, index, undefined);\n                    }\n                });\n            }\n        }\n        if (this.props.multiSelect && this.state.isOpen) {\n            return;\n        }\n        // clear all of the pending info\n        this._clearPendingInfo();\n    };\n    /**\n     * Submit a pending value if there is one\n     */\n    ComboBox.prototype._submitPendingValue = function (submitPendingValueEvent) {\n        var _a = this.props, onChange = _a.onChange, allowFreeform = _a.allowFreeform, autoComplete = _a.autoComplete;\n        var _b = this.state, currentPendingValue = _b.currentPendingValue, currentPendingValueValidIndex = _b.currentPendingValueValidIndex, currentOptions = _b.currentOptions, currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover;\n        var selectedIndices = this.state.selectedIndices;\n        // Do not submit any pending value if we\n        // have already initiated clearing the pending info\n        if (this._processingClearPendingInfo) {\n            return;\n        }\n        // If we allow freeform we need to handle that\n        if (allowFreeform) {\n            // if currentPendingValue is null or undefined the user did not submit anything\n            // (not even empty because we would have stored that as the pending value)\n            if (currentPendingValue === null || currentPendingValue === undefined) {\n                // if a user did not type anything they may just hovered over an item\n                if (currentPendingValueValidIndexOnHover >= 0) {\n                    this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n                    this._clearPendingInfo();\n                }\n                return;\n            }\n            // Check to see if the user typed an exact match\n            if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n                var pendingOptionText = this._getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\n                // By exact match, that means: our pending value is the same as the pending option text OR\n                // the pending option starts with the pending value and we have an \"autoComplete\" selection\n                // where the total length is equal to pending option length OR\n                // the live value in the underlying input matches the pending option; update the state\n                if (currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\n                    (autoComplete &&\n                        pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\n                        this._autofill.current &&\n                        this._autofill.current.isValueSelected &&\n                        currentPendingValue.length +\n                            (this._autofill.current.selectionEnd - this._autofill.current.selectionStart) ===\n                            pendingOptionText.length) ||\n                    (this._autofill.current &&\n                        this._autofill.current.inputElement &&\n                        this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText)) {\n                    this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n                    if (this.props.multiSelect && this.state.isOpen) {\n                        return;\n                    }\n                    this._clearPendingInfo();\n                    return;\n                }\n            }\n            if (onChange) {\n                if (onChange) {\n                    // trigger onChange to clear value\n                    onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n                }\n            }\n            else {\n                // If we are not controlled, create a new selected option\n                var newOption = {\n                    key: currentPendingValue || Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"getId\"])(),\n                    text: this._normalizeToString(currentPendingValue),\n                };\n                // If it's multiselect, set selected state to true\n                if (this.props.multiSelect) {\n                    newOption.selected = true;\n                }\n                var newOptions = currentOptions.concat([newOption]);\n                if (selectedIndices) {\n                    if (!this.props.multiSelect) {\n                        selectedIndices = [];\n                    }\n                    selectedIndices.push(newOptions.length - 1);\n                }\n                this.setState({\n                    currentOptions: newOptions,\n                    selectedIndices: selectedIndices,\n                });\n            }\n        }\n        else if (currentPendingValueValidIndex >= 0) {\n            // Since we are not allowing freeform, we must have a matching\n            // to be able to update state\n            this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n        }\n        else if (currentPendingValueValidIndexOnHover >= 0) {\n            // If all else failed and we were hovering over an item, select it\n            this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n        }\n        // Finally, clear the pending info\n        this._clearPendingInfo();\n    };\n    ComboBox.prototype._onCalloutLayerMounted = function () {\n        // In persistMenu mode _onLayerMounted is only called once for the lifetime\n        // of the component. Any functionality required for callout \"on mount\" can\n        // go here so that we can also call it again during callout dismissal to reset\n        // object state.\n        this._gotMouseMove = false;\n    };\n    // Render separator\n    ComboBox.prototype._renderSeparator = function (item) {\n        var index = item.index, key = item.key;\n        if (index && index > 0) {\n            return react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { role: \"separator\", key: key, className: this._classNames.divider });\n        }\n        return null;\n    };\n    ComboBox.prototype._renderHeader = function (item) {\n        var _a = this.props.onRenderOption, onRenderOption = _a === void 0 ? this._onRenderOptionContent : _a;\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { key: item.key, className: this._classNames.header }, onRenderOption(item, this._onRenderOptionContent)));\n    };\n    /**\n     * If we are coming from a mouseOut:\n     * there is no visible selected option.\n     *\n     * Else if We are hovering over an item:\n     * that gets the selected look.\n     *\n     * Else:\n     * Use the current valid pending index if it exists OR\n     * we do not have a valid index and we currently have a pending input value,\n     * otherwise use the selected index\n     * */\n    ComboBox.prototype._isOptionSelected = function (index) {\n        var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover;\n        // If the hover state is set to clearAll, don't show a selected index.\n        // Note, this happens when the user moused out of the menu items\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            return false;\n        }\n        return this._getPendingSelectedIndex(true /* includePendingValue */) === index ? true : false;\n    };\n    ComboBox.prototype._isOptionChecked = function (index) {\n        if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {\n            var idxOfSelectedIndex = -1;\n            idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\n            return idxOfSelectedIndex >= 0;\n        }\n        return false;\n    };\n    /**\n     * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n     * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n     * finding the index\n     */\n    ComboBox.prototype._getPendingSelectedIndex = function (includeCurrentPendingValue) {\n        var _a = this.state, currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover, currentPendingValueValidIndex = _a.currentPendingValueValidIndex, currentPendingValue = _a.currentPendingValue;\n        return currentPendingValueValidIndexOnHover >= 0\n            ? currentPendingValueValidIndexOnHover\n            : currentPendingValueValidIndex >= 0 ||\n                (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n                ? currentPendingValueValidIndex\n                : this.props.multiSelect\n                    ? 0\n                    : this._getFirstSelectedIndex();\n    };\n    /**\n     * Scroll the selected element into view\n     */\n    ComboBox.prototype._scrollIntoView = function () {\n        var _a = this.props, onScrollToItem = _a.onScrollToItem, scrollSelectedToTop = _a.scrollSelectedToTop;\n        var _b = this.state, currentPendingValueValidIndex = _b.currentPendingValueValidIndex, currentPendingValue = _b.currentPendingValue;\n        if (onScrollToItem) {\n            // Use the custom scroll handler\n            onScrollToItem(currentPendingValueValidIndex >= 0 || currentPendingValue !== ''\n                ? currentPendingValueValidIndex\n                : this._getFirstSelectedIndex());\n        }\n        else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n            // We are using refs, scroll the ref into view\n            if (scrollSelectedToTop) {\n                this._selectedElement.current.offsetParent.scrollIntoView(true);\n            }\n            else {\n                var alignToTop = true;\n                if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n                    var scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n                    var selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\n                    // If we are completely in view then we do not need to scroll\n                    if (scrollableParentRect.top <= selectedElementRect.top &&\n                        scrollableParentRect.top + scrollableParentRect.height >=\n                            selectedElementRect.top + selectedElementRect.height) {\n                        return;\n                    }\n                    // If we are lower than the scrollable parent viewport then we should align to the bottom\n                    if (scrollableParentRect.top + scrollableParentRect.height <=\n                        selectedElementRect.top + selectedElementRect.height) {\n                        alignToTop = false;\n                    }\n                }\n                this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n            }\n        }\n    };\n    /**\n     * Click handler for the menu items\n     * to select the item and also close the menu\n     * @param index - the index of the item that was clicked\n     */\n    ComboBox.prototype._onItemClick = function (item) {\n        var _this = this;\n        var onItemClick = this.props.onItemClick;\n        var index = item.index;\n        return function (ev) {\n            onItemClick && onItemClick(ev, item, index);\n            _this._setSelectedIndex(index, ev);\n            // only close the callout when it's in single-select mode\n            if (!_this.props.multiSelect) {\n                // ensure that focus returns to the input, not the button\n                _this._autofill.current && _this._autofill.current.focus();\n                _this.setState({\n                    isOpen: false,\n                });\n            }\n        };\n    };\n    /**\n     * Get the indices of the options that are marked as selected\n     * @param options - the comboBox options\n     * @param selectedKeys - the known selected keys to find\n     * @returns - an array of the indices of the selected options, empty array if nothing is selected\n     */\n    ComboBox.prototype._getSelectedIndices = function (options, selectedKeys) {\n        if (!options || !selectedKeys) {\n            return [];\n        }\n        var selectedIndices = {};\n        options.forEach(function (option, index) {\n            if (option.selected) {\n                selectedIndices[index] = true;\n            }\n        });\n        var _loop_1 = function (selectedKey) {\n            var index = Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"findIndex\"])(options, function (option) { return option.key === selectedKey; });\n            if (index > -1) {\n                selectedIndices[index] = true;\n            }\n        };\n        for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {\n            var selectedKey = selectedKeys_1[_i];\n            _loop_1(selectedKey);\n        }\n        return Object.keys(selectedIndices)\n            .map(Number)\n            .sort();\n    };\n    /**\n     * Reset the selected index by clearing the\n     * input (of any pending text), clearing the pending state,\n     * and setting the suggested display value to the last\n     * selected state text\n     */\n    ComboBox.prototype._resetSelectedIndex = function () {\n        var currentOptions = this.state.currentOptions;\n        this._clearPendingInfo();\n        var selectedIndex = this._getFirstSelectedIndex();\n        if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n            this.setState({\n                suggestedDisplayValue: currentOptions[selectedIndex].text,\n            });\n        }\n        else if (this.props.text) {\n            // If we had a value initially, restore it\n            this.setState({\n                suggestedDisplayValue: this.props.text,\n            });\n        }\n    };\n    /**\n     * Clears the pending info state\n     */\n    ComboBox.prototype._clearPendingInfo = function () {\n        this._processingClearPendingInfo = true;\n        this.setState({\n            currentPendingValue: undefined,\n            currentPendingValueValidIndex: -1,\n            suggestedDisplayValue: undefined,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        }, this._onAfterClearPendingInfo);\n    };\n    /**\n     * Set the pending info\n     * @param currentPendingValue - new pending value to set\n     * @param currentPendingValueValidIndex - new pending value index to set\n     * @param suggestedDisplayValue - new suggest display value to set\n     */\n    ComboBox.prototype._setPendingInfo = function (currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {\n        if (currentPendingValueValidIndex === void 0) { currentPendingValueValidIndex = -1; }\n        if (this._processingClearPendingInfo) {\n            return;\n        }\n        this.setState({\n            currentPendingValue: this._normalizeToString(currentPendingValue),\n            currentPendingValueValidIndex: currentPendingValueValidIndex,\n            suggestedDisplayValue: suggestedDisplayValue,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        });\n    };\n    /**\n     * Set the pending info from the given index\n     * @param index - the index to set the pending info from\n     */\n    ComboBox.prototype._setPendingInfoFromIndex = function (index) {\n        var currentOptions = this.state.currentOptions;\n        if (index >= 0 && index < currentOptions.length) {\n            var option = currentOptions[index];\n            this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\n        }\n        else {\n            this._clearPendingInfo();\n        }\n    };\n    /**\n     * Sets the pending info for the comboBox\n     * @param index - the index to search from\n     * @param searchDirection - the direction to search\n     */\n    ComboBox.prototype._setPendingInfoFromIndexAndDirection = function (index, searchDirection) {\n        var currentOptions = this.state.currentOptions;\n        // update index to allow content to wrap\n        if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n            index = -1;\n        }\n        else if (searchDirection === SearchDirection.backward && index <= 0) {\n            index = currentOptions.length;\n        }\n        // get the next \"valid\" index\n        var indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n        // if the two indicies are equal we didn't move and\n        // we should attempt to get  get the first/last \"valid\" index to use\n        // (Note, this takes care of the potential cases where the first/last\n        // item is not focusable), otherwise use the updated index\n        if (index === indexUpdate) {\n            if (searchDirection === SearchDirection.forward) {\n                index = this._getNextSelectableIndex(-1, searchDirection);\n            }\n            else if (searchDirection === SearchDirection.backward) {\n                index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n            }\n        }\n        else {\n            index = indexUpdate;\n        }\n        if (this._indexWithinBounds(currentOptions, index)) {\n            this._setPendingInfoFromIndex(index);\n        }\n    };\n    ComboBox.prototype._notifyPendingValueChanged = function (prevState) {\n        var onPendingValueChanged = this.props.onPendingValueChanged;\n        if (!onPendingValueChanged) {\n            return;\n        }\n        var _a = this.state, currentPendingValue = _a.currentPendingValue, currentOptions = _a.currentOptions, currentPendingValueValidIndex = _a.currentPendingValueValidIndex, currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover;\n        var newPendingIndex = undefined;\n        var newPendingValue = undefined;\n        if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n            this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\n            // Set new pending index if hover index was changed\n            newPendingIndex = currentPendingValueValidIndexOnHover;\n        }\n        else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n            this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n            // Set new pending index if currentPendingValueValidIndex was changed\n            newPendingIndex = currentPendingValueValidIndex;\n        }\n        else if (currentPendingValue !== prevState.currentPendingValue) {\n            // Set pendingValue in the case it was changed and no index was changed\n            newPendingValue = currentPendingValue;\n        }\n        // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n        if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n            onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\n            this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n        }\n    };\n    /**\n     * Sets the isOpen state and updates focusInputAfterClose\n     */\n    ComboBox.prototype._setOpenStateAndFocusOnClose = function (isOpen, focusInputAfterClose) {\n        this._focusInputAfterClose = focusInputAfterClose;\n        this.setState({\n            isOpen: isOpen,\n        });\n    };\n    /**\n     * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n     */\n    ComboBox.prototype._isAltOrMeta = function (ev) {\n        return ev.which === _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].alt || ev.key === 'Meta';\n    };\n    ComboBox.prototype._onOptionMouseEnter = function (index) {\n        if (this._shouldIgnoreMouseEvent()) {\n            return;\n        }\n        this.setState({\n            currentPendingValueValidIndexOnHover: index,\n        });\n    };\n    ComboBox.prototype._onOptionMouseMove = function (index) {\n        this._gotMouseMove = true;\n        if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n            return;\n        }\n        this.setState({\n            currentPendingValueValidIndexOnHover: index,\n        });\n    };\n    ComboBox.prototype._shouldIgnoreMouseEvent = function () {\n        return !this._isScrollIdle || !this._gotMouseMove;\n    };\n    /**\n     * Handle dismissing the menu and\n     * eating the required key event when disabled\n     * @param ev - the keyboard event that was fired\n     */\n    ComboBox.prototype._handleInputWhenDisabled = function (ev) {\n        // If we are disabled, close the menu (if needed)\n        // and eat all keystokes other than TAB or ESC\n        if (this.props.disabled) {\n            if (this.state.isOpen) {\n                this.setState({ isOpen: false });\n            }\n            // When disabled stop propagation and prevent default\n            // of the event unless we have a tab, escape, or function key\n            if (ev !== null &&\n                ev.which !== _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].tab &&\n                ev.which !== _Utilities__WEBPACK_IMPORTED_MODULE_3__[\"KeyCodes\"].escape &&\n                (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */) {\n                ev.stopPropagation();\n                ev.preventDefault();\n            }\n        }\n    };\n    ComboBox.prototype._handleTouchAndPointerEvent = function () {\n        var _this = this;\n        // If we already have an existing timeeout from a previous touch and pointer event\n        // cancel that timeout so we can set a nwe one.\n        if (this._lastTouchTimeoutId !== undefined) {\n            this._async.clearTimeout(this._lastTouchTimeoutId);\n            this._lastTouchTimeoutId = undefined;\n        }\n        this._processingTouch = true;\n        this._lastTouchTimeoutId = this._async.setTimeout(function () {\n            _this._processingTouch = false;\n            _this._lastTouchTimeoutId = undefined;\n        }, TouchIdleDelay);\n    };\n    /**\n     * Get the styles for the current option.\n     * @param item - Item props for the current option\n     */\n    ComboBox.prototype._getCaretButtonStyles = function () {\n        var customCaretDownButtonStyles = this.props.caretDownButtonStyles;\n        return Object(_ComboBox_styles__WEBPACK_IMPORTED_MODULE_8__[\"getCaretDownButtonStyles\"])(this.props.theme, customCaretDownButtonStyles);\n    };\n    /**\n     * Get the styles for the current option.\n     * @param item - Item props for the current option\n     */\n    ComboBox.prototype._getCurrentOptionStyles = function (item) {\n        var customStylesForAllOptions = this.props.comboBoxOptionStyles;\n        var customStylesForCurrentOption = item.styles;\n        return Object(_ComboBox_styles__WEBPACK_IMPORTED_MODULE_8__[\"getOptionStyles\"])(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden);\n    };\n    /**\n     * Get the aria-activedescendant value for the comboxbox.\n     * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n     * null otherwise\n     */\n    ComboBox.prototype._getAriaActiveDescendantValue = function () {\n        var descendantText = this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length > 0\n            ? this._id + '-list' + this.state.selectedIndices[0]\n            : undefined;\n        if (this.state.isOpen && this._hasFocus() && this.state.currentPendingValueValidIndex !== -1) {\n            descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;\n        }\n        return descendantText;\n    };\n    /**\n     * Get the aria autocomplete value for the Combobox\n     * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n     * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n     */\n    ComboBox.prototype._getAriaAutoCompleteValue = function () {\n        var autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n        return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\n    };\n    ComboBox.prototype._isPendingOption = function (item) {\n        return item && item.index === this.state.currentPendingValueValidIndex;\n    };\n    /**\n     * Given default selected key(s) and selected key(s), return the selected keys(s).\n     * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n     *\n     * @returns No matter what specific types the input parameters are, always return an array of\n     *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\n     */\n    ComboBox.prototype._buildDefaultSelectedKeys = function (defaultSelectedKey, selectedKey) {\n        var selectedKeys = this._buildSelectedKeys(defaultSelectedKey);\n        if (selectedKeys.length) {\n            return selectedKeys;\n        }\n        return this._buildSelectedKeys(selectedKey);\n    };\n    ComboBox.prototype._buildSelectedKeys = function (selectedKey) {\n        if (selectedKey === undefined) {\n            return [];\n        }\n        // need to cast here so typescript does not complain\n        return (selectedKey instanceof Array ? selectedKey : [selectedKey]);\n    };\n    // For scenarios where the option's text prop contains embedded styles, we use the option's\n    // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\n    // when the useAriaLabelAsText prop is set to true\n    ComboBox.prototype._getPreviewText = function (item) {\n        return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n    };\n    ComboBox.prototype._normalizeToString = function (value) {\n        return value || '';\n    };\n    /**\n     * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n     */\n    ComboBox.prototype._hasFocus = function () {\n        return this.state.focusState !== 'none';\n    };\n    ComboBox.defaultProps = {\n        options: [],\n        allowFreeform: false,\n        autoComplete: 'on',\n        buttonIconProps: { iconName: 'ChevronDown' },\n    };\n    ComboBox = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"])([\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_3__[\"customizable\"])('ComboBox', ['theme', 'styles'], true)\n    ], ComboBox);\n    return ComboBox;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\n\n//# sourceMappingURL=ComboBox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWhVMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbWJvQm94L0NvbWJvQm94LmpzPzhhMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fZGVjb3JhdGUsIF9fZXh0ZW5kcywgX19zcHJlYWRBcnJheXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEF1dG9maWxsIH0gZnJvbSAnLi4vQXV0b2ZpbGwvaW5kZXgnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUNvbXBvbmVudFJlZiwgY3NzLCBjdXN0b21pemFibGUsIGRpdlByb3BlcnRpZXMsIGZpbmRFbGVtZW50UmVjdXJzaXZlLCBmaW5kSW5kZXgsIGZvY3VzQXN5bmMsIGdldElkLCBnZXROYXRpdmVQcm9wcywgaXNJT1MsIGlzTWFjLCBLZXlDb2Rlcywgc2hhbGxvd0NvbXBhcmUsIG1lcmdlQXJpYUF0dHJpYnV0ZVZhbHVlcywgd2Fybk11dHVhbGx5RXhjbHVzaXZlLCBBc3luYywgRXZlbnRHcm91cCwgfSBmcm9tICcuLi8uLi9VdGlsaXRpZXMnO1xuaW1wb3J0IHsgQ2FsbG91dCB9IGZyb20gJy4uLy4uL0NhbGxvdXQnO1xuaW1wb3J0IHsgQ2hlY2tib3ggfSBmcm9tICcuLi8uLi9DaGVja2JveCc7XG5pbXBvcnQgeyBDb21tYW5kQnV0dG9uLCBJY29uQnV0dG9uIH0gZnJvbSAnLi4vLi4vQnV0dG9uJztcbmltcG9ydCB7IERpcmVjdGlvbmFsSGludCB9IGZyb20gJy4uLy4uL2NvbW1vbi9EaXJlY3Rpb25hbEhpbnQnO1xuaW1wb3J0IHsgZ2V0Q2FyZXREb3duQnV0dG9uU3R5bGVzLCBnZXRPcHRpb25TdHlsZXMsIGdldFN0eWxlcyB9IGZyb20gJy4vQ29tYm9Cb3guc3R5bGVzJztcbmltcG9ydCB7IGdldENsYXNzTmFtZXMsIGdldENvbWJvQm94T3B0aW9uQ2xhc3NOYW1lcyB9IGZyb20gJy4vQ29tYm9Cb3guY2xhc3NOYW1lcyc7XG5pbXBvcnQgeyBLZXl0aXBEYXRhIH0gZnJvbSAnLi4vLi4vS2V5dGlwRGF0YSc7XG5pbXBvcnQgeyBMYWJlbCB9IGZyb20gJy4uLy4uL0xhYmVsJztcbmltcG9ydCB7IFNlbGVjdGFibGVPcHRpb25NZW51SXRlbVR5cGUsIGdldEFsbFNlbGVjdGVkT3B0aW9ucyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9zZWxlY3RhYmxlT3B0aW9uL2luZGV4JztcbnZhciBTZWFyY2hEaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNlYXJjaERpcmVjdGlvbikge1xuICAgIFNlYXJjaERpcmVjdGlvbltTZWFyY2hEaXJlY3Rpb25bXCJiYWNrd2FyZFwiXSA9IC0xXSA9IFwiYmFja3dhcmRcIjtcbiAgICBTZWFyY2hEaXJlY3Rpb25bU2VhcmNoRGlyZWN0aW9uW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgU2VhcmNoRGlyZWN0aW9uW1NlYXJjaERpcmVjdGlvbltcImZvcndhcmRcIl0gPSAxXSA9IFwiZm9yd2FyZFwiO1xufSkoU2VhcmNoRGlyZWN0aW9uIHx8IChTZWFyY2hEaXJlY3Rpb24gPSB7fSkpO1xudmFyIEhvdmVyU3RhdHVzO1xuKGZ1bmN0aW9uIChIb3ZlclN0YXR1cykge1xuICAgIC8qKiBVc2VkIHdoZW4gdGhlIHVzZXIgd2FzIGhvdmVyaW5nIGFuZCBoYXMgc2luY2UgbW91c2VkIG91dCBvZiB0aGUgbWVudSBpdGVtcyAqL1xuICAgIEhvdmVyU3RhdHVzW0hvdmVyU3RhdHVzW1wiY2xlYXJBbGxcIl0gPSAtMl0gPSBcImNsZWFyQWxsXCI7XG4gICAgLyoqIERlZmF1bHQgXCJub3JtYWxcIiBzdGF0ZSwgd2hlbiBubyBob3ZlciBoYXMgaGFwcGVuZWQgb3IgYSBob3ZlciBpcyBpbiBwcm9ncmVzcyAqL1xuICAgIEhvdmVyU3RhdHVzW0hvdmVyU3RhdHVzW1wiZGVmYXVsdFwiXSA9IC0xXSA9IFwiZGVmYXVsdFwiO1xufSkoSG92ZXJTdGF0dXMgfHwgKEhvdmVyU3RhdHVzID0ge30pKTtcbnZhciBTY3JvbGxJZGxlRGVsYXkgPSAyNTA7IC8qIG1zICovXG52YXIgVG91Y2hJZGxlRGVsYXkgPSA1MDA7IC8qIG1zICovXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgcGVuZGluZyBhdXRvY29tcGxldGUgdGV4dCAodXNlZCB3aGVuIGF1dG9jb21wbGV0ZSBpcyB0cnVlIGFuZFxuICogYWxsb3dGcmVlZm9ybSBpcyBmYWxzZSlcbiAqL1xudmFyIFJlYWRPbmx5UGVuZGluZ0F1dG9Db21wbGV0ZVRpbWVvdXQgPSAxMDAwOyAvKiBtcyAqL1xuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gd3JhcCBhbGwgQ29tYm9Cb3ggb3B0aW9ucy5cbiAqIFRoaXMgaXMgdXNlZCB0byBjdXN0b21pemUgd2hlbiB3ZSB3YW50IHRvIHJlcmVuZGVyIGNvbXBvbmVudHMsXG4gKiBzbyB3ZSBkb24ndCByZXJlbmRlciBldmVyeSBvcHRpb24gZXZlcnkgdGltZSByZW5kZXIgaXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBDb21ib0JveE9wdGlvbldyYXBwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbWJvQm94T3B0aW9uV3JhcHBlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21ib0JveE9wdGlvbldyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29tYm9Cb3hPcHRpb25XcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnJlbmRlcigpO1xuICAgIH07XG4gICAgQ29tYm9Cb3hPcHRpb25XcmFwcGVyLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICAgICAgLy8gVGhlIHJlbmRlciBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBkaWZmZXJlbnQsIHNvIHdlIGlnbm9yZSB0aGF0IHByb3BcbiAgICAgICAgcmV0dXJuICFzaGFsbG93Q29tcGFyZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcyksIHsgcmVuZGVyOiB1bmRlZmluZWQgfSksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBuZXdQcm9wcyksIHsgcmVuZGVyOiB1bmRlZmluZWQgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJvQm94T3B0aW9uV3JhcHBlcjtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG52YXIgQ09NUE9ORU5UX05BTUUgPSAnQ29tYm9Cb3gnO1xudmFyIENvbWJvQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21ib0JveCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21ib0JveChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Jvb3QgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgLyoqIFRoZSBpbnB1dCBhc3BlY3Qgb2YgdGhlIGNvbWJvQm94ICovXG4gICAgICAgIF90aGlzLl9hdXRvZmlsbCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAvKiogVGhlIHdyYXBwaW5nIGRpdiBvZiB0aGUgaW5wdXQgYW5kIGJ1dHRvbiAqL1xuICAgICAgICBfdGhpcy5fY29tYm9Cb3hXcmFwcGVyID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIC8qKiBUaGUgY2FsbG91dCBlbGVtZW50ICovXG4gICAgICAgIF90aGlzLl9jb21ib0JveE1lbnUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgLyoqIFRoZSBtZW51IGl0ZW0gZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZCAqL1xuICAgICAgICBfdGhpcy5fc2VsZWN0ZWRFbGVtZW50ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7QGluaGVyaXRkb2N9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5mb2N1cyA9IGZ1bmN0aW9uIChzaG91bGRPcGVuT25Gb2N1cywgdXNlRm9jdXNBc3luYykge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9hdXRvZmlsbC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZUZvY3VzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBc3luYyhfdGhpcy5fYXV0b2ZpbGwuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXV0b2ZpbGwuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT3Blbk9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9ncmFtYXRpY2FsbHkgc2V0dGluZyBmb2N1cyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vdGhpbmcgZWxzZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcbiAgICAgICAgICAgIC8vIEZvY3VzIGlzIG5vdyBjb250YWluZWRcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2hhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvY3VzU3RhdGU6ICdmb2N1c2VkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlIG1lbnUgY2FsbG91dCBpZiBpdCBpcyBvcGVuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kaXNtaXNzTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpc09wZW4gPSBfdGhpcy5zdGF0ZS5pc09wZW47XG4gICAgICAgICAgICBpc09wZW4gJiYgX3RoaXMuc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYW5kbGVyIGZvciB0aGUgYXV0byBmaWxsIGNvbXBvbmVudFxuICAgICAgICAgKiBDaGVja3MvdXBkYXRlcyB0aGUgaXB1dCB2YWx1ZSB0byBzZXQsIGlmIG5lZWRlZFxuICAgICAgICAgKiBAcGFyYW0gZGVmYXVsdFZpc2libGVWYWx1ZSAtIHRoZSBkZWZhdWx0VmlzaWJsZVZhbHVlIHRoYXQgZ290IHBhc3NlZFxuICAgICAgICAgKiAgaW4gdG8gdGhlIGF1dG8gZmlsbCdzIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICAgICAgICogQHJldHVybnMgLSB0aGUgdXBkYXRlZCB2YWx1ZSB0byBzZXQsIGlmIG5lZWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uVXBkYXRlVmFsdWVJbkF1dG9maWxsV2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21ib0JveCA9IF90aGlzLl9hdXRvZmlsbC5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFjb21ib0JveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbWJvQm94LnZhbHVlID09PSBudWxsIHx8IGNvbWJvQm94LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aXNpYmxlVmFsdWUgPSBfdGhpcy5fbm9ybWFsaXplVG9TdHJpbmcoX3RoaXMuX2N1cnJlbnRWaXNpYmxlVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvbWJvQm94LnZhbHVlICE9PSB2aXNpYmxlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2aXNpYmxlVmFsdWUgaXMgZW1wdHksIGVuc3VyZSB0aGF0IHRoZSBlbXB0eSBzdHJpbmcgaXMgdXNlZFxuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpYmxlVmFsdWUgfHwgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tYm9Cb3gudmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9yZW5kZXJDb21ib0JveFdyYXBwZXIgPSBmdW5jdGlvbiAobXVsdGlzZWxlY3RBY2Nlc3NpYmxlVGV4dCwgZXJyb3JNZXNzYWdlSWQsIGtleXRpcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXl0aXBBdHRyaWJ1dGVzID09PSB2b2lkIDApIHsga2V5dGlwQXR0cmlidXRlcyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgbGFiZWwgPSBfYS5sYWJlbCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgYXJpYUxhYmVsID0gX2EuYXJpYUxhYmVsLCBhcmlhRGVzY3JpYmVkQnkgPSBfYS5hcmlhRGVzY3JpYmVkQnksIHJlcXVpcmVkID0gX2EucmVxdWlyZWQsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZSwgYWxsb3dGcmVlZm9ybSA9IF9hLmFsbG93RnJlZWZvcm0sIGJ1dHRvbkljb25Qcm9wcyA9IF9hLmJ1dHRvbkljb25Qcm9wcywgX2IgPSBfYS5pc0J1dHRvbkFyaWFIaWRkZW4sIGlzQnV0dG9uQXJpYUhpZGRlbiA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIHRpdGxlID0gX2EudGl0bGUsIHBsYWNlaG9sZGVyUHJvcCA9IF9hLnBsYWNlaG9sZGVyLCB0YWJJbmRleCA9IF9hLnRhYkluZGV4LCBhdXRvZmlsbCA9IF9hLmF1dG9maWxsLCBpY29uQnV0dG9uUHJvcHMgPSBfYS5pY29uQnV0dG9uUHJvcHM7XG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgaXNPcGVuID0gX2MuaXNPcGVuLCBzdWdnZXN0ZWREaXNwbGF5VmFsdWUgPSBfYy5zdWdnZXN0ZWREaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29tYm9ib3ggaGFzIGZvY3VzLCBpcyBtdWx0aXNlbGVjdCwgYW5kIGhhcyBhIGRpc3BsYXkgc3RyaW5nLCB0aGVuIHVzZSB0aGF0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBzZWxlY3RlZCBpdGVtcyBkb24ndCBhcHBlYXIgdG8gdmFuaXNoLiBUaGlzIGlzIG5vdCBpZGVhbCBidXQgaXQncyB0aGUgb25seSByZWFzb25hYmxlIHdheVxuICAgICAgICAgICAgLy8gdG8gY29ycmVjdCB0aGUgYmVoYXZpb3Igd2hlcmUgdGhlIGlucHV0IGlzIGNsZWFyZWQgc28gdGhlIHVzZXIgY2FuIHR5cGUuIElmIGEgZnVsbCByZWZhY3RvciBpcyBkb25lLCB0aGVuIHRoaXNcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbXVsdGlzZWxlY3QgY29tYm9ib3ggc2hvdWxkIGJlaGF2ZSBsaWtlIGEgcGlja2VyLlxuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gX3RoaXMuX2hhc0ZvY3VzKCkgJiYgX3RoaXMucHJvcHMubXVsdGlTZWxlY3QgJiYgbXVsdGlzZWxlY3RBY2Nlc3NpYmxlVGV4dFxuICAgICAgICAgICAgICAgID8gbXVsdGlzZWxlY3RBY2Nlc3NpYmxlVGV4dFxuICAgICAgICAgICAgICAgIDogcGxhY2Vob2xkZXJQcm9wO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLWt0cC10YXJnZXRcIjoga2V5dGlwQXR0cmlidXRlc1snZGF0YS1rdHAtdGFyZ2V0J10sIHJlZjogX3RoaXMuX2NvbWJvQm94V3JhcHBlciwgaWQ6IF90aGlzLl9pZCArICd3cmFwcGVyJywgY2xhc3NOYW1lOiBfdGhpcy5fY2xhc3NOYW1lcy5yb290IH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBdXRvZmlsbCwgX19hc3NpZ24oeyBcImRhdGEta3RwLWV4ZWN1dGUtdGFyZ2V0XCI6IGtleXRpcEF0dHJpYnV0ZXNbJ2RhdGEta3RwLWV4ZWN1dGUtdGFyZ2V0J10sIFwiZGF0YS1pcy1pbnRlcmFjdGFibGVcIjogIWRpc2FibGVkLCBjb21wb25lbnRSZWY6IF90aGlzLl9hdXRvZmlsbCwgaWQ6IF90aGlzLl9pZCArICctaW5wdXQnLCBjbGFzc05hbWU6IF90aGlzLl9jbGFzc05hbWVzLmlucHV0LCB0eXBlOiBcInRleHRcIiwgb25Gb2N1czogX3RoaXMuX29uRm9jdXMsIG9uQmx1cjogX3RoaXMuX29uQmx1ciwgb25LZXlEb3duOiBfdGhpcy5fb25JbnB1dEtleURvd24sIG9uS2V5VXA6IF90aGlzLl9vbklucHV0S2V5VXAsIG9uQ2xpY2s6IF90aGlzLl9vbkF1dG9maWxsQ2xpY2ssIG9uVG91Y2hTdGFydDogX3RoaXMuX29uVG91Y2hTdGFydCwgb25JbnB1dFZhbHVlQ2hhbmdlOiBfdGhpcy5fb25JbnB1dENoYW5nZSwgXCJhcmlhLWV4cGFuZGVkXCI6IGlzT3BlbiwgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBfdGhpcy5fZ2V0QXJpYUF1dG9Db21wbGV0ZVZhbHVlKCksIHJvbGU6IFwiY29tYm9ib3hcIiwgcmVhZE9ubHk6IGRpc2FibGVkIHx8ICFhbGxvd0ZyZWVmb3JtLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbCAmJiBfdGhpcy5faWQgKyAnLWxhYmVsJywgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCAmJiAhbGFiZWwgPyBhcmlhTGFiZWwgOiB1bmRlZmluZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBlcnJvck1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXJnZUFyaWFBdHRyaWJ1dGVWYWx1ZXMoYXJpYURlc2NyaWJlZEJ5LCBrZXl0aXBBdHRyaWJ1dGVzWydhcmlhLWRlc2NyaWJlZGJ5J10sIGVycm9yTWVzc2FnZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXJnZUFyaWFBdHRyaWJ1dGVWYWx1ZXMoYXJpYURlc2NyaWJlZEJ5LCBrZXl0aXBBdHRyaWJ1dGVzWydhcmlhLWRlc2NyaWJlZGJ5J10pLCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBfdGhpcy5fZ2V0QXJpYUFjdGl2ZURlc2NlbmRhbnRWYWx1ZSgpLCBcImFyaWEtcmVxdWlyZWRcIjogcmVxdWlyZWQsIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCwgXCJhcmlhLW93bnNcIjogaXNPcGVuID8gX3RoaXMuX2lkICsgJy1saXN0JyA6IHVuZGVmaW5lZCwgc3BlbGxDaGVjazogZmFsc2UsIGRlZmF1bHRWaXNpYmxlVmFsdWU6IF90aGlzLl9jdXJyZW50VmlzaWJsZVZhbHVlLCBzdWdnZXN0ZWREaXNwbGF5VmFsdWU6IHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSwgdXBkYXRlVmFsdWVJbldpbGxSZWNlaXZlUHJvcHM6IF90aGlzLl9vblVwZGF0ZVZhbHVlSW5BdXRvZmlsbFdpbGxSZWNlaXZlUHJvcHMsIHNob3VsZFNlbGVjdEZ1bGxJbnB1dFZhbHVlSW5Db21wb25lbnREaWRVcGRhdGU6IF90aGlzLl9vblNob3VsZFNlbGVjdEZ1bGxJbnB1dFZhbHVlSW5BdXRvZmlsbENvbXBvbmVudERpZFVwZGF0ZSwgdGl0bGU6IHRpdGxlLCBwcmV2ZW50VmFsdWVTZWxlY3Rpb246ICFfdGhpcy5faGFzRm9jdXMoKSwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCB0YWJJbmRleDogdGFiSW5kZXggfSwgYXV0b2ZpbGwpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIF9fYXNzaWduKHsgY2xhc3NOYW1lOiAnbXMtQ29tYm9Cb3gtQ2FyZXREb3duLWJ1dHRvbicsIHN0eWxlczogX3RoaXMuX2dldENhcmV0QnV0dG9uU3R5bGVzKCksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIFwiYXJpYS1oaWRkZW5cIjogaXNCdXR0b25BcmlhSGlkZGVuLCBcImRhdGEtaXMtZm9jdXNhYmxlXCI6IGZhbHNlLCB0YWJJbmRleDogLTEsIG9uQ2xpY2s6IF90aGlzLl9vbkNvbWJvQm94Q2xpY2ssIG9uQmx1cjogX3RoaXMuX29uQmx1ciwgaWNvblByb3BzOiBidXR0b25JY29uUHJvcHMsIGRpc2FibGVkOiBkaXNhYmxlZCwgY2hlY2tlZDogaXNPcGVuIH0sIGljb25CdXR0b25Qcm9wcykpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlciBmb3IgdGhlIGF1dG8gZmlsbCBjb21wb25lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRlZmF1bHRWaXNpYmxlVmFsdWUgLSB0aGUgY3VycmVudCBkZWZhdWx0VmlzaWJsZVZhbHVlIGluIHRoZSBhdXRvIGZpbGwncyBjb21wb25lbnREaWRVcGRhdGVcbiAgICAgICAgICogQHBhcmFtIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSAtIHRoZSBjdXJyZW50IHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSBpbiB0aGUgYXV0byBmaWxsJ3MgY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICAqIEByZXR1cm5zIC0gc2hvdWxkIHRoZSBmdWxsIHZhbHVlIG9mIHRoZSBpbnB1dCBiZSBzZWxlY3RlZD9cbiAgICAgICAgICogVHJ1ZSBpZiB0aGUgZGVmYXVsdFZpc2libGVWYWx1ZSBlcXVhbHMgdGhlIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25TaG91bGRTZWxlY3RGdWxsSW5wdXRWYWx1ZUluQXV0b2ZpbGxDb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2N1cnJlbnRWaXNpYmxlVmFsdWUgPT09IF90aGlzLnN0YXRlLnN1Z2dlc3RlZERpc3BsYXlWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29ycmVjdCB2YWx1ZSB0byBwYXNzIHRvIHRoZSBpbnB1dFxuICAgICAgICAgKiB0byBzaG93IHRvIHRoZSB1c2VyIGJhc2VkIG9mZiBvZiB0aGUgY3VycmVudCBwcm9wcyBhbmQgc3RhdGVcbiAgICAgICAgICogQHJldHVybnMgdGhlIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZ2V0VmlzaWJsZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHRleHQgPSBfYS50ZXh0LCBhbGxvd0ZyZWVmb3JtID0gX2EuYWxsb3dGcmVlZm9ybSwgYXV0b0NvbXBsZXRlID0gX2EuYXV0b0NvbXBsZXRlO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMuc3RhdGUsIHNlbGVjdGVkSW5kaWNlcyA9IF9iLnNlbGVjdGVkSW5kaWNlcywgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggPSBfYi5jdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCwgY3VycmVudE9wdGlvbnMgPSBfYi5jdXJyZW50T3B0aW9ucywgY3VycmVudFBlbmRpbmdWYWx1ZSA9IF9iLmN1cnJlbnRQZW5kaW5nVmFsdWUsIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSA9IF9iLnN1Z2dlc3RlZERpc3BsYXlWYWx1ZSwgaXNPcGVuID0gX2IuaXNPcGVuO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQZW5kaW5nSW5kZXhWYWxpZCA9IF90aGlzLl9pbmRleFdpdGhpbkJvdW5kcyhjdXJyZW50T3B0aW9ucywgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgcGFzc2VkIGlzIGEgdmFsdWUgcHJvcCwgdXNlIHRoYXRcbiAgICAgICAgICAgIC8vIHVubGVzcyB3ZSBhcmUgb3BlbiBhbmQgaGF2ZSBhIHZhbGlkIGN1cnJlbnQgcGVuZGluZyBpbmRleFxuICAgICAgICAgICAgaWYgKCEoaXNPcGVuICYmIGN1cnJlbnRQZW5kaW5nSW5kZXhWYWxpZCkgJiZcbiAgICAgICAgICAgICAgICB0ZXh0ICYmXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQZW5kaW5nVmFsdWUgPT09IG51bGwgfHwgY3VycmVudFBlbmRpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktc2VsZWN0XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b0NvbXBsZXRlID09PSAnb24nICYmIGN1cnJlbnRQZW5kaW5nSW5kZXhWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldFBlbmRpbmdTdHJpbmcoY3VycmVudFBlbmRpbmdWYWx1ZSwgY3VycmVudE9wdGlvbnMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0TXVsdGlzZWxlY3REaXNwbGF5U3RyaW5nKHNlbGVjdGVkSW5kaWNlcywgY3VycmVudE9wdGlvbnMsIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLXNlbGVjdFxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dGcmVlZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxsb3dpbmcgZnJlZWZvcm0gYW5kIGF1dG9jb21wbGV0ZSBpcyBhbHNvIHRydWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlJ3ZlIGdvdCBhIHBlbmRpbmcgdmFsdWUgdGhhdCBtYXRjaGVzIGFuIG9wdGlvbiwgcmVtZW1iZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1hdGNoZWQgb3B0aW9uJ3MgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9Db21wbGV0ZSA9PT0gJ29uJyAmJiBjdXJyZW50UGVuZGluZ0luZGV4VmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIGFsbG93aW5nIGZyZWVmb3JtLCBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBwZW5kaW5nIHZhbHVlLCB1c2UgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBpbmRleCBkZXRlcm1pbmVkIGFib3ZlIChmYWxsaW5nIGJhY2sgdG8gJycgaWYgd2UgZGlkIG5vdCBnZXQgYSB2YWxpZCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRQZW5kaW5nU3RyaW5nKGN1cnJlbnRQZW5kaW5nVmFsdWUsIGN1cnJlbnRPcHRpb25zLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtIGFuZCBoYXZlIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWQgaW5kZXggdGhhdCBtYXRjaGVzIHRoZSBwZW5kaW5nIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHdlIHdpbGwgbmVlZCBzb21lIHZlcnNpb24gb2YgdGhlIHBlbmRpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZW5kaW5nSW5kZXhWYWxpZCAmJiBhdXRvQ29tcGxldGUgPT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGF1dG9Db21wbGV0ZSBpcyBvbiwgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF3IHBlbmRpbmcgdmFsdWUsIG90aGVyd2lzZSByZW1lbWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1hdGNoZWQgb3B0aW9uJ3MgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX25vcm1hbGl6ZVRvU3RyaW5nKGN1cnJlbnRQZW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFfdGhpcy5zdGF0ZS5pc09wZW4gJiYgY3VycmVudFBlbmRpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9pbmRleFdpdGhpbkJvdW5kcyhjdXJyZW50T3B0aW9ucywgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50UGVuZGluZ1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5fbm9ybWFsaXplVG9TdHJpbmcoc3VnZ2VzdGVkRGlzcGxheVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5faW5kZXhXaXRoaW5Cb3VuZHMoY3VycmVudE9wdGlvbnMsIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudE9wdGlvbnNbaW5kZXhdLnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLl9ub3JtYWxpemVUb1N0cmluZyhzdWdnZXN0ZWREaXNwbGF5VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlciBmb3IgdHlwaW5nIGNoYW5nZXMgb24gdGhlIGlucHV0XG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGVkVmFsdWUgLSB0aGUgbmV3bHkgY2hhbmdlZCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAodXBkYXRlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlSW5wdXRXaGVuRGlzYWJsZWQobnVsbCAvKiBldmVudCAqLyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMuYWxsb3dGcmVlZm9ybVxuICAgICAgICAgICAgICAgID8gX3RoaXMuX3Byb2Nlc3NJbnB1dENoYW5nZVdpdGhGcmVlZm9ybSh1cGRhdGVkVmFsdWUpXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5fcHJvY2Vzc0lucHV0Q2hhbmdlV2l0aG91dEZyZWVmb3JtKHVwZGF0ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1cyAoYW5kIHNlbGVjdCkgdGhlIGNvbnRlbnQgb2YgdGhlIGlucHV0XG4gICAgICAgICAqIGFuZCBzZXQgdGhlIGZvY3VzZWQgc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9hdXRvZmlsbC5jdXJyZW50ICYmIF90aGlzLl9hdXRvZmlsbC5jdXJyZW50LmlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hdXRvZmlsbC5jdXJyZW50LmlucHV0RWxlbWVudC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3RoaXMuX2hhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvY3VzU3RhdGU6ICdmb2N1c2luZycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBpc3N1ZWQgd2hlbiB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcmVzb2x2ZWQsIGlmIHRoZXkgaGF2ZSBiZWVuIHVwZGF0ZWQgb3JcbiAgICAgICAgICogaWYgdGhleSBuZWVkIHRvIGJlIHBhc3NlZCBpbiB0aGUgZmlyc3QgdGltZS4gVGhpcyBvbmx5IGRvZXMgd29yayBpZiBhbiBvblJlc29sdmVPcHRpb25zXG4gICAgICAgICAqIGNhbGxiYWNrIHdhcyBwYXNzZWQgaW5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblJlc29sdmVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uUmVzb2x2ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF90aGlzLnByb3BzLm9uUmVzb2x2ZU9wdGlvbnMoX19zcHJlYWRBcnJheXMoX3RoaXMuc3RhdGUuY3VycmVudE9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHJldHVybmVkIHZhbHVlIGlzIGFuIGFycmF5LCBpZiBpdCBpcyB1cGRhdGUgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybmVkIHZhbHVlIGlzIG5vdCBhbiBhcnJheSB0aGVuIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGEgcHJvbWlzZSBvciBQcm9taXNlTGlrZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyB0aGVuIHJlc29sdmUgaXQgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3T3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wdGlvbnM6IG5ld09wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdPcHRpb25zICYmIG5ld09wdGlvbnMudGhlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJvbWlzZSB3aWxsIG9ubHkgdXNlIHRoZSBjYWxsYmFjayBpZiBpdCB3YXMgdGhlIG1vc3QgcmVjZW50IG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdXBkYXRlIHRoZSBzdGF0ZSB3aGVuIHRoZSBwcm9taXNlIHJldHVybnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VfMSA9IChfdGhpcy5fY3VycmVudFByb21pc2UgPSBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV8xLnRoZW4oZnVuY3Rpb24gKG5ld09wdGlvbnNGcm9tUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VfMSA9PT0gX3RoaXMuX2N1cnJlbnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3B0aW9uczogbmV3T3B0aW9uc0Zyb21Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbkJsdXIgaGFuZGxlci4gU2V0IHRoZSBmb2N1c2VkIHN0YXRlIHRvIGZhbHNlXG4gICAgICAgICAqIGFuZCBzdWJtaXQgYW55IHBlbmRpbmcgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICBfdGhpcy5fb25CbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBibHVyIGlzIGNvbWluZyBmcm9tIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBjb21ib0JveCByb290IG9yIHRoZSBjb21ib0JveCBtZW51IHNpbmNlXG4gICAgICAgICAgICAvLyBpdCB3ZSBhcmUgbm90IHJlYWxseSBibHVyaW5nIGZyb20gdGhlIHdob2xlIGNvbWJvQm94XG4gICAgICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEluIElFMTEsIGR1ZSB0byBsYWNrIG9mIHN1cHBvcnQsIGV2ZW50LnJlbGF0ZWRUYXJnZXQgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gbnVsbCBtYWtpbmcgZXZlcnkgb25CbHVyIGNhbGwgdG8gYmUgXCJvdXRzaWRlXCIgb2YgdGhlIENvbWJvQm94XG4gICAgICAgICAgICAgICAgLy8gZXZlbiB3aGVuIGl0J3Mgbm90LiBVc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIGFub3RoZXIgd2F5XG4gICAgICAgICAgICAgICAgLy8gZm9yIHVzIHRvIGJlIGFibGUgdG8gZ2V0IHdoYXQgdGhlIHJlbGF0ZWRUYXJnZXQgd2l0aG91dCByZWx5aW5nXG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVsYXRlZFRhcmdldCAmJlxuICAgICAgICAgICAgICAgIC8vIHdoZW4gZXZlbnQgY29taW5nIGZyb20gd2l0aGluZyB0aGUgY29tYm9Cb3ggdGl0bGVcbiAgICAgICAgICAgICAgICAoKF90aGlzLl9yb290LmN1cnJlbnQgJiYgX3RoaXMuX3Jvb3QuY3VycmVudC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBldmVudCBjb21pbmcgZnJvbSB3aXRoaW4gdGhlIGNvbWJvQm94IGxpc3QgbWVudVxuICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX2NvbWJvQm94TWVudS5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX2NvbWJvQm94TWVudS5jdXJyZW50LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBldmVudCBjb21pbmcgZnJvbSB0aGUgY2FsbG91dCBjb250YWluaW5nIHRoZSBjb21ib0JveCBsaXN0IG1lbnUgKGV4OiB3aGVuIHNjcm9sbEJhciBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsb3V0IGlzIGNsaWNrZWQpIGNoZWNrcyBpZiB0aGUgcmVsYXRlZFRhcmdldCBpcyBhIHBhcmVudCBvZiBfY29tYm9Cb3hNZW51XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZEVsZW1lbnRSZWN1cnNpdmUoX3RoaXMuX2NvbWJvQm94TWVudS5jdXJyZW50LCBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudCA9PT0gcmVsYXRlZFRhcmdldDsgfSkpKSkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5faGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9jdXNTdGF0ZTogJ25vbmUnIH0pO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMubXVsdGlTZWxlY3QgfHwgX3RoaXMucHJvcHMuYWxsb3dGcmVlZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3VibWl0UGVuZGluZ1ZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbmRlciBDYWxsb3V0IGNvbnRhaW5lciBhbmQgcGFzcyBpbiBsaXN0XG4gICAgICAgIF90aGlzLl9vblJlbmRlckNvbnRhaW5lciA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdmFyIG9uUmVuZGVyTGlzdCA9IHByb3BzLm9uUmVuZGVyTGlzdCwgY2FsbG91dFByb3BzID0gcHJvcHMuY2FsbG91dFByb3BzLCBkcm9wZG93bldpZHRoID0gcHJvcHMuZHJvcGRvd25XaWR0aCwgZHJvcGRvd25NYXhXaWR0aCA9IHByb3BzLmRyb3Bkb3duTWF4V2lkdGgsIF9hID0gcHJvcHMub25SZW5kZXJVcHBlckNvbnRlbnQsIG9uUmVuZGVyVXBwZXJDb250ZW50ID0gX2EgPT09IHZvaWQgMCA/IF90aGlzLl9vblJlbmRlclVwcGVyQ29udGVudCA6IF9hLCBfYiA9IHByb3BzLm9uUmVuZGVyTG93ZXJDb250ZW50LCBvblJlbmRlckxvd2VyQ29udGVudCA9IF9iID09PSB2b2lkIDAgPyBfdGhpcy5fb25SZW5kZXJMb3dlckNvbnRlbnQgOiBfYiwgdXNlQ29tYm9Cb3hBc01lbnVXaWR0aCA9IHByb3BzLnVzZUNvbWJvQm94QXNNZW51V2lkdGgsIHBlcnNpc3RNZW51ID0gcHJvcHMucGVyc2lzdE1lbnUsIF9jID0gcHJvcHMuc2hvdWxkUmVzdG9yZUZvY3VzLCBzaG91bGRSZXN0b3JlRm9jdXMgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jO1xuICAgICAgICAgICAgdmFyIGlzT3BlbiA9IF90aGlzLnN0YXRlLmlzT3BlbjtcbiAgICAgICAgICAgIHZhciBjb21ib0JveE1lbnVXaWR0aCA9IHVzZUNvbWJvQm94QXNNZW51V2lkdGggJiYgX3RoaXMuX2NvbWJvQm94V3JhcHBlci5jdXJyZW50XG4gICAgICAgICAgICAgICAgPyBfdGhpcy5fY29tYm9Cb3hXcmFwcGVyLmN1cnJlbnQuY2xpZW50V2lkdGggKyAyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbG91dCwgX19hc3NpZ24oeyBpc0JlYWtWaXNpYmxlOiBmYWxzZSwgZ2FwU3BhY2U6IDAsIGRvTm90TGF5ZXI6IGZhbHNlLCBkaXJlY3Rpb25hbEhpbnQ6IERpcmVjdGlvbmFsSGludC5ib3R0b21MZWZ0RWRnZSwgZGlyZWN0aW9uYWxIaW50Rml4ZWQ6IGZhbHNlIH0sIGNhbGxvdXRQcm9wcywgeyBvbkxheWVyTW91bnRlZDogX3RoaXMuX29uTGF5ZXJNb3VudGVkLCBjbGFzc05hbWU6IGNzcyhfdGhpcy5fY2xhc3NOYW1lcy5jYWxsb3V0LCBjYWxsb3V0UHJvcHMgPyBjYWxsb3V0UHJvcHMuY2xhc3NOYW1lIDogdW5kZWZpbmVkKSwgdGFyZ2V0OiBfdGhpcy5fY29tYm9Cb3hXcmFwcGVyLmN1cnJlbnQsIG9uRGlzbWlzczogX3RoaXMuX29uRGlzbWlzcywgb25Nb3VzZURvd246IF90aGlzLl9vbkNhbGxvdXRNb3VzZURvd24sIG9uU2Nyb2xsOiBfdGhpcy5fb25TY3JvbGwsIHNldEluaXRpYWxGb2N1czogZmFsc2UsIGNhbGxvdXRXaWR0aDogdXNlQ29tYm9Cb3hBc01lbnVXaWR0aCAmJiBfdGhpcy5fY29tYm9Cb3hXcmFwcGVyLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21ib0JveE1lbnVXaWR0aCAmJiBjb21ib0JveE1lbnVXaWR0aFxuICAgICAgICAgICAgICAgICAgICA6IGRyb3Bkb3duV2lkdGgsIGNhbGxvdXRNYXhXaWR0aDogZHJvcGRvd25NYXhXaWR0aCA/IGRyb3Bkb3duTWF4V2lkdGggOiBjb21ib0JveE1lbnVXaWR0aCwgaGlkZGVuOiBwZXJzaXN0TWVudSA/ICFpc09wZW4gOiB1bmRlZmluZWQsIHNob3VsZFJlc3RvcmVGb2N1czogc2hvdWxkUmVzdG9yZUZvY3VzIH0pLFxuICAgICAgICAgICAgICAgIG9uUmVuZGVyVXBwZXJDb250ZW50KF90aGlzLnByb3BzLCBfdGhpcy5fb25SZW5kZXJVcHBlckNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IF90aGlzLl9jbGFzc05hbWVzLm9wdGlvbnNDb250YWluZXJXcmFwcGVyLCByZWY6IF90aGlzLl9jb21ib0JveE1lbnUgfSwgb25SZW5kZXJMaXN0KF9fYXNzaWduKHt9LCBwcm9wcyksIF90aGlzLl9vblJlbmRlckxpc3QpKSxcbiAgICAgICAgICAgICAgICBvblJlbmRlckxvd2VyQ29udGVudChfdGhpcy5wcm9wcywgX3RoaXMuX29uUmVuZGVyTG93ZXJDb250ZW50KSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25MYXllck1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25DYWxsb3V0TGF5ZXJNb3VudGVkKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY2FsbG91dFByb3BzICYmIF90aGlzLnByb3BzLmNhbGxvdXRQcm9wcy5vbkxheWVyTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmNhbGxvdXRQcm9wcy5vbkxheWVyTW91bnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25SZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIChvblJlbmRlckxhYmVsUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG9uUmVuZGVyTGFiZWxQcm9wcy5wcm9wcywgbGFiZWwgPSBfYS5sYWJlbCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgcmVxdWlyZWQgPSBfYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChMYWJlbCwgeyBpZDogX3RoaXMuX2lkICsgJy1sYWJlbCcsIGRpc2FibGVkOiBkaXNhYmxlZCwgcmVxdWlyZWQ6IHJlcXVpcmVkLCBjbGFzc05hbWU6IF90aGlzLl9jbGFzc05hbWVzLmxhYmVsIH0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBvblJlbmRlckxhYmVsUHJvcHMubXVsdGlzZWxlY3RBY2Nlc3NpYmxlVGV4dCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IF90aGlzLl9jbGFzc05hbWVzLnNjcmVlblJlYWRlclRleHQgfSwgb25SZW5kZXJMYWJlbFByb3BzLm11bHRpc2VsZWN0QWNjZXNzaWJsZVRleHQpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbmRlciBMaXN0IG9mIGl0ZW1zXG4gICAgICAgIF90aGlzLl9vblJlbmRlckxpc3QgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBvblJlbmRlckl0ZW0gPSBwcm9wcy5vblJlbmRlckl0ZW0sIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMuX2lkO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGlkICsgJy1saXN0JywgY2xhc3NOYW1lOiBfdGhpcy5fY2xhc3NOYW1lcy5vcHRpb25zQ29udGFpbmVyLCBcImFyaWEtbGFiZWxsZWRieVwiOiBpZCArICctbGFiZWwnLCByb2xlOiBcImxpc3Rib3hcIiB9LCBvcHRpb25zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gb25SZW5kZXJJdGVtKGl0ZW0sIF90aGlzLl9vblJlbmRlckl0ZW0pOyB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZW5kZXIgaXRlbXNcbiAgICAgICAgX3RoaXMuX29uUmVuZGVySXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uaXRlbVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNlbGVjdGFibGVPcHRpb25NZW51SXRlbVR5cGUuRGl2aWRlcjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZW5kZXJTZXBhcmF0b3IoaXRlbSk7XG4gICAgICAgICAgICAgICAgY2FzZSBTZWxlY3RhYmxlT3B0aW9uTWVudUl0ZW1UeXBlLkhlYWRlcjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZW5kZXJIZWFkZXIoaXRlbSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZW5kZXJPcHRpb24oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIERlZmF1bHQgX29uUmVuZGVyTG93ZXJDb250ZW50IGZ1bmN0aW9uIHJldHVybnMgbm90aGluZ1xuICAgICAgICBfdGhpcy5fb25SZW5kZXJMb3dlckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRGVmYXVsdCBfb25SZW5kZXJVcHBlckNvbnRlbnQgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nXG4gICAgICAgIF90aGlzLl9vblJlbmRlclVwcGVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVuZGVyT3B0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLm9uUmVuZGVyT3B0aW9uLCBvblJlbmRlck9wdGlvbiA9IF9hID09PSB2b2lkIDAgPyBfdGhpcy5fb25SZW5kZXJPcHRpb25Db250ZW50IDogX2E7XG4gICAgICAgICAgICB2YXIgaWQgPSBfdGhpcy5faWQ7XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IF90aGlzLl9pc09wdGlvblNlbGVjdGVkKGl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IF90aGlzLl9pc09wdGlvbkNoZWNrZWQoaXRlbS5pbmRleCk7XG4gICAgICAgICAgICB2YXIgb3B0aW9uU3R5bGVzID0gX3RoaXMuX2dldEN1cnJlbnRPcHRpb25TdHlsZXMoaXRlbSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9uQ2xhc3NOYW1lcyA9IGdldENvbWJvQm94T3B0aW9uQ2xhc3NOYW1lcyhfdGhpcy5fZ2V0Q3VycmVudE9wdGlvblN0eWxlcyhpdGVtKSk7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBfdGhpcy5fZ2V0UHJldmlld1RleHQoaXRlbSk7XG4gICAgICAgICAgICB2YXIgb25SZW5kZXJDaGVja2JveExhYmVsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25SZW5kZXJPcHRpb24oaXRlbSwgX3RoaXMuX29uUmVuZGVyT3B0aW9uQ29udGVudCk7IH07XG4gICAgICAgICAgICB2YXIgZ2V0T3B0aW9uQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhX3RoaXMucHJvcHMubXVsdGlTZWxlY3QgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21tYW5kQnV0dG9uLCB7IGlkOiBpZCArICctbGlzdCcgKyBpdGVtLmluZGV4LCBrZXk6IGl0ZW0ua2V5LCBcImRhdGEtaW5kZXhcIjogaXRlbS5pbmRleCwgc3R5bGVzOiBvcHRpb25TdHlsZXMsIGNoZWNrZWQ6IGlzU2VsZWN0ZWQsIGNsYXNzTmFtZTogJ21zLUNvbWJvQm94LW9wdGlvbicsIG9uQ2xpY2s6IF90aGlzLl9vbkl0ZW1DbGljayhpdGVtKSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtbm8tYmluZFxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI6IF90aGlzLl9vbk9wdGlvbk1vdXNlRW50ZXIuYmluZChfdGhpcywgaXRlbS5pbmRleCksIFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LW5vLWJpbmRcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU6IF90aGlzLl9vbk9wdGlvbk1vdXNlTW92ZS5iaW5kKF90aGlzLCBpdGVtLmluZGV4KSwgb25Nb3VzZUxlYXZlOiBfdGhpcy5fb25PcHRpb25Nb3VzZUxlYXZlLCByb2xlOiBcIm9wdGlvblwiLCBcImFyaWEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZCA/ICd0cnVlJyA6ICdmYWxzZScsIGFyaWFMYWJlbDogX3RoaXMuX2dldFByZXZpZXdUZXh0KGl0ZW0pLCBkaXNhYmxlZDogaXRlbS5kaXNhYmxlZCwgdGl0bGU6IHRpdGxlIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBvcHRpb25DbGFzc05hbWVzLm9wdGlvblRleHRXcmFwcGVyLCByZWY6IGlzU2VsZWN0ZWQgPyBfdGhpcy5fc2VsZWN0ZWRFbGVtZW50IDogdW5kZWZpbmVkIH0sIG9uUmVuZGVyT3B0aW9uKGl0ZW0sIF90aGlzLl9vblJlbmRlck9wdGlvbkNvbnRlbnQpKSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tib3gsIHsgaWQ6IGlkICsgJy1saXN0JyArIGl0ZW0uaW5kZXgsIGFyaWFMYWJlbDogX3RoaXMuX2dldFByZXZpZXdUZXh0KGl0ZW0pLCBrZXk6IGl0ZW0ua2V5LCBcImRhdGEtaW5kZXhcIjogaXRlbS5pbmRleCwgc3R5bGVzOiBvcHRpb25TdHlsZXMsIGNsYXNzTmFtZTogJ21zLUNvbWJvQm94LW9wdGlvbicsIFwiZGF0YS1pcy1mb2N1c2FibGVcIjogdHJ1ZSwgb25DaGFuZ2U6IF90aGlzLl9vbkl0ZW1DbGljayhpdGVtKSwgbGFiZWw6IGl0ZW0udGV4dCwgcm9sZTogXCJvcHRpb25cIiwgY2hlY2tlZDogaXNDaGVja2VkLCB0aXRsZTogdGl0bGUsIGRpc2FibGVkOiBpdGVtLmRpc2FibGVkLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1uby1iaW5kXG4gICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyTGFiZWw6IG9uUmVuZGVyQ2hlY2tib3hMYWJlbCwgaW5wdXRQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBpc1NlbGVjdGVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENvbWJvQm94T3B0aW9uV3JhcHBlciwgeyBrZXk6IGl0ZW0ua2V5LCBpbmRleDogaXRlbS5pbmRleCwgZGlzYWJsZWQ6IGl0ZW0uZGlzYWJsZWQsIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsIGlzQ2hlY2tlZDogaXNDaGVja2VkLCB0ZXh0OiBpdGVtLnRleHQsIFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtbm8tYmluZFxuICAgICAgICAgICAgICAgIHJlbmRlcjogZ2V0T3B0aW9uQ29tcG9uZW50LCBkYXRhOiBpdGVtLmRhdGEgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY2xpY2tzIHRvIGhlYWRlcnMsIGRpdmlkZXJzIGFuZCBzY3JvbGxiYXIgc2hvdWxkIG5vdCBtYWtlIGlucHV0IGxvc2UgZm9jdXNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbkNhbGxvdXRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgaGFuZGxlciBmb3IgdGhlIGNhbGxvdXQgdG8gbWFrZSBzdXJlIHRoZSBtb3VzZSBldmVudHNcbiAgICAgICAgICogZm9yIHVwZGF0aW5nIGZvY3VzIGFyZSBub3QgaW50ZXJhY3RpbmcgZHVyaW5nIHNjcm9sbFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNTY3JvbGxJZGxlICYmIF90aGlzLl9zY3JvbGxJZGxlVGltZW91dElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXN5bmMuY2xlYXJUaW1lb3V0KF90aGlzLl9zY3JvbGxJZGxlVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsSWRsZVRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pc1Njcm9sbElkbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9zY3JvbGxJZGxlVGltZW91dElkID0gX3RoaXMuX2FzeW5jLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pc1Njcm9sbElkbGUgPSB0cnVlO1xuICAgICAgICAgICAgfSwgU2Nyb2xsSWRsZURlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uUmVuZGVyT3B0aW9uQ29udGVudCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uQ2xhc3NOYW1lcyA9IGdldENvbWJvQm94T3B0aW9uQ2xhc3NOYW1lcyhfdGhpcy5fZ2V0Q3VycmVudE9wdGlvblN0eWxlcyhpdGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IG9wdGlvbkNsYXNzTmFtZXMub3B0aW9uVGV4dCB9LCBpdGVtLnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBkaXNtaXNzaW5nIChjYW5jZWxsaW5nKSB0aGUgbWVudVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uRGlzbWlzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbk1lbnVEaXNtaXNzID0gX3RoaXMucHJvcHMub25NZW51RGlzbWlzcztcbiAgICAgICAgICAgIGlmIChvbk1lbnVEaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgb25NZW51RGlzbWlzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gcGVyc2lzdE1vZGUgd2UgbmVlZCB0byBzaW11bGF0ZSBjYWxsb3V0IGxheWVyIG1vdW50XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGF0IG9ubHkgaGFwcGVucyBvbmNlLiBXZSBkbyBpdCBvbiBkaXNtaXNzIHNpbmNlXG4gICAgICAgICAgICAvLyBpdCB3b3JrcyBlaXRoZXIgd2F5LlxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnBlcnNpc3RNZW51KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX29uQ2FsbG91dExheWVyTW91bnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIG1lbnVcbiAgICAgICAgICAgIF90aGlzLl9zZXRPcGVuU3RhdGVBbmRGb2N1c09uQ2xvc2UoZmFsc2UgLyogaXNPcGVuICovLCBmYWxzZSAvKiBmb2N1c0lucHV0QWZ0ZXJDbG9zZSAqLyk7XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgICAgIC8vIHRvIHRoZSBsYXN0IHZhbHVlIHN0YXRlXG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRTZWxlY3RlZEluZGV4KCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vbkFmdGVyQ2xlYXJQZW5kaW5nSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzaW5nQ2xlYXJQZW5kaW5nSW5mbyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGtleWRvd24gb24gdGhlIGlucHV0XG4gICAgICAgICAqIEBwYXJhbSBldiAtIFRoZSBrZXlib2FyZCBldmVudCB0aGF0IHdhcyBmaXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uSW5wdXRLZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgYWxsb3dGcmVlZm9ybSA9IF9hLmFsbG93RnJlZWZvcm0sIGF1dG9Db21wbGV0ZSA9IF9hLmF1dG9Db21wbGV0ZTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnN0YXRlLCBpc09wZW4gPSBfYi5pc09wZW4sIGN1cnJlbnRPcHRpb25zID0gX2IuY3VycmVudE9wdGlvbnMsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlciA9IF9iLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlcjtcbiAgICAgICAgICAgIC8vIFRha2Ugbm90ZSBpZiB3ZSBhcmUgcHJvY2Vzc2luZyBhbiBhbHQgKG9wdGlvbikgb3IgbWV0YSAoY29tbWFuZCkga2V5ZG93bi5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGluIF9vbklucHV0S2V5VXAgZm9yIHJlYXNvbmluZy5cbiAgICAgICAgICAgIF90aGlzLl9sYXN0S2V5RG93bldhc0FsdE9yTWV0YSA9IF90aGlzLl9pc0FsdE9yTWV0YShldik7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlSW5wdXRXaGVuRGlzYWJsZWQoZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9nZXRQZW5kaW5nU2VsZWN0ZWRJbmRleChmYWxzZSAvKiBpbmNsdWRlQ3VycmVudFBlbmRpbmdWYWx1ZSAqLyk7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2LndoaWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlDb2Rlcy5lbnRlcjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hdXRvZmlsbC5jdXJyZW50ICYmIF90aGlzLl9hdXRvZmlsbC5jdXJyZW50LmlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2F1dG9maWxsLmN1cnJlbnQuaW5wdXRFbGVtZW50LnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJtaXRQZW5kaW5nVmFsdWUoZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMubXVsdGlTZWxlY3QgJiYgaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBlbnRlciBzdWJtaXQgdGhlIHBlbmRpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCFhbGxvd0ZyZWVmb3JtIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5jdXJyZW50UGVuZGluZ1ZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWUubGVuZ3RoIDw9IDApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4IDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb3BlbiBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgYWxsb3dpbmcgZnJlZWZvcm0gb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgd2UgaGF2ZSBubyBwZW5kaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vIHZhbGlkIHBlbmRpbmcgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbGlwIHRoZSBvcGVuIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09wZW46ICFpc09wZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlDb2Rlcy50YWI6XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uIGVudGVyIHN1Ym1pdCB0aGUgcGVuZGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3VibWl0UGVuZGluZ1ZhbHVlKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIHRoZSBjb21ib0JveCBpcyBvcGVuLCBmbGlwIHRoZSBvcGVuIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPcGVuU3RhdGVBbmRGb2N1c09uQ2xvc2UoIWlzT3BlbiwgZmFsc2UgLyogZm9jdXNJbnB1dEFmdGVyQ2xvc2UgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IFRBQiB0byBwcm9waWdhdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5Q29kZXMuZXNjYXBlOlxuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U2VsZWN0ZWRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGUgbWVudSBpZiBvcGVuZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLnVwOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gY2xlYXJBbGwgc3RhdGUgKGUuZy4gdGhlIHVzZXIgYXMgaG92ZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGhhcyBzaW5jZSBtb3VzZWRPdXQgb2YgdGhlIG1lbnUgaXRlbXMpLFxuICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byB0aGUgbGFzdCBpbmRleFxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyID09PSBIb3ZlclN0YXR1cy5jbGVhckFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBfdGhpcy5zdGF0ZS5jdXJyZW50T3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmFsdEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGUgbWVudSBpZiBpdCBpcyBvcGVuIGFuZCBicmVhayBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgZXZlbnQgZ2V0IHN0b3BQcm9wYWdhdGlvbiBhbmQgcHJldmVudCBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGxldCB0aGUgZXZlbnQgY29udGludWUgdG8gcHJvcGFnYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldE9wZW5TdGF0ZUFuZEZvY3VzT25DbG9zZSghaXNPcGVuLCB0cnVlIC8qIGZvY3VzSW5wdXRBZnRlckNsb3NlICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHbyB0byB0aGUgcHJldmlvdXMgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRQZW5kaW5nSW5mb0Zyb21JbmRleEFuZERpcmVjdGlvbihpbmRleCwgU2VhcmNoRGlyZWN0aW9uLmJhY2t3YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlDb2Rlcy5kb3duOlxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIGNvbWJvQm94IG9uIEFMVCArIERvd25BcnJvd1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXYuYWx0S2V5IHx8IGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPcGVuU3RhdGVBbmRGb2N1c09uQ2xvc2UodHJ1ZSAvKiBpc09wZW4gKi8sIHRydWUgLyogZm9jdXNJbnB1dEFmdGVyQ2xvc2UgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIGNsZWFyQWxsIHN0YXRlIChlLmcuIHRoZSB1c2VyIGFzIGhvdmVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaGFzIHNpbmNlIG1vdXNlZE91dCBvZiB0aGUgbWVudSBpdGVtcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byB0aGUgZmlyc3QgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIgPT09IEhvdmVyU3RhdHVzLmNsZWFyQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvdCB0byB0aGUgbmV4dCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRQZW5kaW5nSW5mb0Zyb21JbmRleEFuZERpcmVjdGlvbihpbmRleCwgU2VhcmNoRGlyZWN0aW9uLmZvcndhcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5Q29kZXMuaG9tZTpcbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLmVuZDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93RnJlZWZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGluaXRpYWwgdmFsdWVzIHRvIHJlc3BvbmQgdG8gSE9NRVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBnb2VzIHRvIHRoZSBmaXJzdCBzZWxlY3RhYmxlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uVG9TZWFyY2ggPSBTZWFyY2hEaXJlY3Rpb24uZm9yd2FyZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZW5kLCB1cGRhdGUgdGhlIHZhbHVlcyB0byByZXNwb25kIHRvIEVORFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBnb2VzIHRvIHRoZSBsYXN0IHNlbGVjdGFibGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi53aGljaCA9PT0gS2V5Q29kZXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGN1cnJlbnRPcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvblRvU2VhcmNoID0gU2VhcmNoRGlyZWN0aW9uLmJhY2t3YXJkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRQZW5kaW5nSW5mb0Zyb21JbmRleEFuZERpcmVjdGlvbihpbmRleCwgZGlyZWN0aW9uVG9TZWFyY2gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5Q29kZXMuc3BhY2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZWQgaW4gX29uQ29tYm9Cb3hLZXlVcFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93RnJlZWZvcm0gJiYgYXV0b0NvbXBsZXRlID09PSAnb2ZmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSB3ZSBwcm9jZXNzaW5nIGEgZnVuY3Rpb24ga2V5PyBpZiBzbyBiYWlsIG91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYud2hpY2ggPj0gMTEyIC8qIEYxICovICYmIGV2LndoaWNoIDw9IDEyMyAvKiBGMTIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgd2UgZ290IGVpdGhlciBhbmQgQUxUIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBtZXRhIGtleSwgbGV0IHRoZSBldmVudCBwcm9wYWdhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT09IEtleUNvZGVzLmFsdCB8fCBldi5rZXkgPT09ICdNZXRhJyAvKiAmJiBpc09wZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd2luZyBhdXRvQ29tcGxldGUsIGhhbmRsZSB0aGUgaW5wdXQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBoYXZlIG1hcmtlZCB0aGUgaW5wdXQgYXMgcmVhZG9ubHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0ZyZWVmb3JtICYmIGF1dG9Db21wbGV0ZSA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uSW5wdXRDaGFuZ2UoZXYua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBrZXkgdG8gcHJvcGFnYXRlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGtleXVwIG9uIHRoZSBpbnB1dFxuICAgICAgICAgKiBAcGFyYW0gZXYgLSB0aGUga2V5Ym9hcmQgZXZlbnQgdGhhdCB3YXMgZmlyZWRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbklucHV0S2V5VXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBhbGxvd0ZyZWVmb3JtID0gX2EuYWxsb3dGcmVlZm9ybSwgYXV0b0NvbXBsZXRlID0gX2EuYXV0b0NvbXBsZXRlO1xuICAgICAgICAgICAgdmFyIGlzT3BlbiA9IF90aGlzLnN0YXRlLmlzT3BlbjtcbiAgICAgICAgICAgIC8vIFdlIGNsb3NlIHRoZSBtZW51IG9uIGtleSB1cCBvbmx5IGlmIEFMTCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlOlxuICAgICAgICAgICAgLy8gLSBNb3N0IHJlY2VudCBrZXkgZG93biB3YXMgYWx0IG9yIG1ldGEgKGNvbW1hbmQpXG4gICAgICAgICAgICAvLyAtIFRoZSBhbHQvbWV0YSBrZXkgZG93biB3YXMgTk9UIGZvbGxvd2VkIGJ5IHNvbWUgb3RoZXIga2V5IChzdWNoIGFzIGRvd24vdXAgYXJyb3cgdG9cbiAgICAgICAgICAgIC8vICAgZXhwYW5kL2NvbGxhcHNlIHRoZSBtZW51KVxuICAgICAgICAgICAgLy8gLSBXZSdyZSBub3Qgb24gYSBNYWMgKG9yIGlPUylcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBvbiBXaW5kb3dzLCBwcmVzc2luZyBhbHQgbW92ZXMgZm9jdXMgdG8gdGhlIGFwcGxpY2F0aW9uIG1lbnUgYmFyIG9yIHNpbWlsYXIsXG4gICAgICAgICAgICAvLyBjbG9zaW5nIGFueSBvcGVuIGNvbnRleHQgbWVudXMuIFRoZXJlIGlzIG5vdCBhIHNpbWlsYXIgYmVoYXZpb3Igb24gTWFjcy5cbiAgICAgICAgICAgIHZhciBrZXlQcmVzc0lzQWx0T3JNZXRhQWxvbmUgPSBfdGhpcy5fbGFzdEtleURvd25XYXNBbHRPck1ldGEgJiYgX3RoaXMuX2lzQWx0T3JNZXRhKGV2KTtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0S2V5RG93bldhc0FsdE9yTWV0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNob3VsZEhhbmRsZUtleSA9IGtleVByZXNzSXNBbHRPck1ldGFBbG9uZSAmJiAhKGlzTWFjKCkgfHwgaXNJT1MoKSk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlSW5wdXRXaGVuRGlzYWJsZWQoZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZXYud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLnNwYWNlOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtIGFuZCBhcmUgbm90IGF1dG9Db21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHNwYWNlIGV4cGFuZC9jb2xsYXBzZSB0aGUgY29tYm9Cb3hcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGFsbG93IHRoZSBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0ZyZWVmb3JtICYmIGF1dG9Db21wbGV0ZSA9PT0gJ29mZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPcGVuU3RhdGVBbmRGb2N1c09uQ2xvc2UoIWlzT3BlbiwgISFpc09wZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlS2V5ICYmIGlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldE9wZW5TdGF0ZUFuZEZvY3VzT25DbG9zZSghaXNPcGVuLCB0cnVlIC8qIGZvY3VzSW5wdXRBZnRlckNsb3NlICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5mb2N1c1N0YXRlID09PSAnZm9jdXNpbmcnICYmIF90aGlzLnByb3BzLm9wZW5PbktleWJvYXJkRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5mb2N1c1N0YXRlICE9PSAnZm9jdXNlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvY3VzU3RhdGU6ICdmb2N1c2VkJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vbk9wdGlvbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Nob3VsZElnbm9yZU1vdXNlRXZlbnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaW4gcGVyc2lzdE1lbnUgbW9kZSBpZiB0aGUgY2FsbG91dCBoYXNcbiAgICAgICAgICAgIC8vIGNsb3NlZC4gVGhpcyBpcyB0byBhdm9pZCBjbGVhcmluZyB0aGUgdmlzdWFscyBvbiBpdGVtIGNsaWNrLlxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnBlcnNpc3RNZW51ICYmICFfdGhpcy5zdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyOiBIb3ZlclN0YXR1cy5jbGVhckFsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xpY2sgaGFuZGxlciBmb3IgdGhlIGJ1dHRvbiBvZiB0aGUgY29tYm9Cb3hcbiAgICAgICAgICogYW5kIHRoZSBpbnB1dCB3aGVuIG5vdCBhbGxvd2luZyBmcmVlZm9ybS4gVGhpc1xuICAgICAgICAgKiB0b2dnbGVzIHRoZSBleHBhbmQvY29sbGFwc2Ugc3RhdGUgb2YgdGhlIGNvbWJvQm94IChpZiBlbmJsZWQpXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25Db21ib0JveENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMucHJvcHMuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgaXNPcGVuID0gX3RoaXMuc3RhdGUuaXNPcGVuO1xuICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPcGVuU3RhdGVBbmRGb2N1c09uQ2xvc2UoIWlzT3BlbiwgZmFsc2UgLyogZm9jdXNJbnB1dEFmdGVyQ2xvc2UgKi8pO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9jdXNTdGF0ZTogJ2ZvY3VzZWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xpY2sgaGFuZGxlciBmb3IgdGhlIGF1dG9maWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uQXV0b2ZpbGxDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBhbGxvd0ZyZWVmb3JtID0gX2EuYWxsb3dGcmVlZm9ybTtcbiAgICAgICAgICAgIGlmIChhbGxvd0ZyZWVmb3JtICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzKF90aGlzLnN0YXRlLmlzT3BlbiB8fCBfdGhpcy5fcHJvY2Vzc2luZ1RvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vbkNvbWJvQm94Q2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uVG91Y2hTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fY29tYm9Cb3hXcmFwcGVyLmN1cnJlbnQgJiYgISgnb25wb2ludGVyZG93bicgaW4gX3RoaXMuX2NvbWJvQm94V3JhcHBlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlVG91Y2hBbmRQb2ludGVyRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUb3VjaEFuZFBvaW50ZXJFdmVudCgpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXYuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGluaXRpYWxpemVDb21wb25lbnRSZWYoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fYXN5bmMgPSBuZXcgQXN5bmMoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50R3JvdXAoX3RoaXMpO1xuICAgICAgICB3YXJuTXV0dWFsbHlFeGNsdXNpdmUoQ09NUE9ORU5UX05BTUUsIHByb3BzLCB7XG4gICAgICAgICAgICBkZWZhdWx0U2VsZWN0ZWRLZXk6ICdzZWxlY3RlZEtleScsXG4gICAgICAgICAgICB0ZXh0OiAnZGVmYXVsdFNlbGVjdGVkS2V5JyxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5OiAndmFsdWUnLFxuICAgICAgICAgICAgZHJvcGRvd25XaWR0aDogJ3VzZUNvbWJvQm94QXNNZW51V2lkdGgnLFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX2lkID0gcHJvcHMuaWQgfHwgZ2V0SWQoJ0NvbWJvQm94Jyk7XG4gICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSBfdGhpcy5fYnVpbGREZWZhdWx0U2VsZWN0ZWRLZXlzKHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSwgcHJvcHMuc2VsZWN0ZWRLZXkpO1xuICAgICAgICBfdGhpcy5faXNTY3JvbGxJZGxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX3Byb2Nlc3NpbmdUb3VjaCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZ290TW91c2VNb3ZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9wcm9jZXNzaW5nQ2xlYXJQZW5kaW5nSW5mbyA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5pdGlhbFNlbGVjdGVkSW5kaWNlcyA9IF90aGlzLl9nZXRTZWxlY3RlZEluZGljZXMocHJvcHMub3B0aW9ucywgc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzOiBpbml0aWFsU2VsZWN0ZWRJbmRpY2VzLFxuICAgICAgICAgICAgZm9jdXNTdGF0ZTogJ25vbmUnLFxuICAgICAgICAgICAgc3VnZ2VzdGVkRGlzcGxheVZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXJyZW50T3B0aW9uczogX3RoaXMucHJvcHMub3B0aW9ucyxcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4OiAtMSxcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlcjogSG92ZXJTdGF0dXMuZGVmYXVsdCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tYm9Cb3gucHJvdG90eXBlLCBcInNlbGVjdGVkT3B0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBjdXJyZW50T3B0aW9ucyA9IF9hLmN1cnJlbnRPcHRpb25zLCBzZWxlY3RlZEluZGljZXMgPSBfYS5zZWxlY3RlZEluZGljZXM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxsU2VsZWN0ZWRPcHRpb25zKGN1cnJlbnRPcHRpb25zLCBzZWxlY3RlZEluZGljZXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb21ib0JveC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21ib0JveFdyYXBwZXIuY3VycmVudCAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgLy8gaG9vayB1cCByZXNvbHZpbmcgdGhlIG9wdGlvbnMgaWYgbmVlZGVkIG9uIGZvY3VzXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMub24odGhpcy5fY29tYm9Cb3hXcmFwcGVyLmN1cnJlbnQsICdmb2N1cycsIHRoaXMuX29uUmVzb2x2ZU9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCdvbnBvaW50ZXJkb3duJyBpbiB0aGlzLl9jb21ib0JveFdyYXBwZXIuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBDb21ib0JveGVzLCB0b3VjaGluZyBhbnl3aGVyZSBpbiB0aGUgY29tYm8gYm94IHNob3VsZCBkcm9wIHRoZSBkcm9wZG93biwgaW5jbHVkaW5nIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgbW9yZSBoaXQgdGFyZ2V0IHNwYWNlIGZvciB0b3VjaCBlbnZpcm9ubWVudHMuIFdlJ3JlIHNldHRpbmcgdGhlIG9ucG9pbnRlcmRvd24gaGVyZSwgYmVjYXVzZSBSZWFjdFxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgUG9pbnRlciBldmVudHMgeWV0LlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5vbih0aGlzLl9jb21ib0JveFdyYXBwZXIuY3VycmVudCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGVkSW5kZXggYW5kIGN1cnJlbnRPcHRpb25zIHN0YXRlIGlmXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZEtleSwgdmFsdWUsIG9yIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGlmIChuZXdQcm9wcy5zZWxlY3RlZEtleSAhPT0gdGhpcy5wcm9wcy5zZWxlY3RlZEtleSB8fFxuICAgICAgICAgICAgbmV3UHJvcHMudGV4dCAhPT0gdGhpcy5wcm9wcy50ZXh0IHx8XG4gICAgICAgICAgICBuZXdQcm9wcy5vcHRpb25zICE9PSB0aGlzLnByb3BzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSB0aGlzLl9idWlsZFNlbGVjdGVkS2V5cyhuZXdQcm9wcy5zZWxlY3RlZEtleSk7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuX2dldFNlbGVjdGVkSW5kaWNlcyhuZXdQcm9wcy5vcHRpb25zLCBzZWxlY3RlZEtleXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzOiBpbmRpY2VzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPcHRpb25zOiBuZXdQcm9wcy5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobmV3UHJvcHMuc2VsZWN0ZWRLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkRGlzcGxheVZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgYWxsb3dGcmVlZm9ybSA9IF9hLmFsbG93RnJlZWZvcm0sIHRleHQgPSBfYS50ZXh0LCBvbk1lbnVPcGVuID0gX2Eub25NZW51T3Blbiwgb25NZW51RGlzbWlzc2VkID0gX2Eub25NZW51RGlzbWlzc2VkO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBpc09wZW4gPSBfYi5pc09wZW4sIHNlbGVjdGVkSW5kaWNlcyA9IF9iLnNlbGVjdGVkSW5kaWNlcywgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggPSBfYi5jdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleDtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5ld2x5IG9wZW4gb3IgYXJlIG9wZW4gYW5kIHRoZSBwZW5kaW5nIHZhbGlkIGluZGV4IGNoYW5nZWQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkL3BlbmRpbmcgb3B0aW9uIGlzIHNjcm9sbGVkIGludG8gdmlld1xuICAgICAgICBpZiAoaXNPcGVuICYmICghcHJldlN0YXRlLmlzT3BlbiB8fCBwcmV2U3RhdGUuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggIT09IGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4KSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0aGlzIHRpbWVvdXQgc28gdGhhdCB0aGUgc2VsZWN0ZWRFbGVtZW50IHJlZiBpcyBjb3JyZWN0bHkgdXBkYXRlZFxuICAgICAgICAgICAgdGhpcy5fYXN5bmMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2Nyb2xsSW50b1ZpZXcoKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYW4gYWN0aW9uIGlzIHRha2VuIHRoYXQgcHV0IGZvY3VzIGluIHRoZSBDb21ib0JveFxuICAgICAgICAvLyBhbmQgSWYgd2UgYXJlIG9wZW4gb3Igd2UgYXJlIGp1c3QgY2xvc2VkLCBzaG91bGRGb2N1c0FmdGVyQ2xvc2UgaXMgc2V0LFxuICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB0aGUgYWN0aXZlRWxlbWVudCBzZXQgZm9jdXMgb24gdGhlIGlucHV0XG4gICAgICAgIGlmICh0aGlzLl9oYXNGb2N1cygpICYmXG4gICAgICAgICAgICAoaXNPcGVuIHx8XG4gICAgICAgICAgICAgICAgKHByZXZTdGF0ZS5pc09wZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzT3BlbiAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c0lucHV0QWZ0ZXJDbG9zZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvZmlsbC5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuX2F1dG9maWxsLmN1cnJlbnQuaW5wdXRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXModW5kZWZpbmVkIC8qc2hvdWxkT3Blbk9uRm9jdXMqLywgdHJ1ZSAvKnVzZUZvY3VzQXN5bmMqLyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2Ugc2hvdWxkIGZvY3VzQWZ0ZXJDbG9zZSBBTkRcbiAgICAgICAgLy8gICBqdXN0IG9wZW5lZC9jbG9zZWQgdGhlIG1lbnUgT1JcbiAgICAgICAgLy8gICBhcmUgZm9jdXNlZCBBTkRcbiAgICAgICAgLy8gICAgIHVwZGF0ZWQgdGhlIHNlbGVjdGVkSW5kZXggd2l0aCB0aGUgbWVudSBjbG9zZWQgT1JcbiAgICAgICAgLy8gICAgIGFyZSBub3QgYWxsb3dpbmcgZnJlZWZvcm0gT1JcbiAgICAgICAgLy8gICAgIHRoZSB2YWx1ZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5fZm9jdXNJbnB1dEFmdGVyQ2xvc2UgJiZcbiAgICAgICAgICAgICgocHJldlN0YXRlLmlzT3BlbiAmJiAhaXNPcGVuKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9oYXNGb2N1cygpICYmXG4gICAgICAgICAgICAgICAgICAgICgoIWlzT3BlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMucHJvcHMubXVsdGlTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZS5zZWxlY3RlZEluZGljZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kaWNlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlLnNlbGVjdGVkSW5kaWNlc1swXSAhPT0gc2VsZWN0ZWRJbmRpY2VzWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWFsbG93RnJlZWZvcm0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgIT09IHByZXZQcm9wcy50ZXh0KSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm90aWZ5UGVuZGluZ1ZhbHVlQ2hhbmdlZChwcmV2U3RhdGUpO1xuICAgICAgICBpZiAoaXNPcGVuICYmICFwcmV2U3RhdGUuaXNPcGVuICYmIG9uTWVudU9wZW4pIHtcbiAgICAgICAgICAgIG9uTWVudU9wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT3BlbiAmJiBwcmV2U3RhdGUuaXNPcGVuICYmIG9uTWVudURpc21pc3NlZCkge1xuICAgICAgICAgICAgb25NZW51RGlzbWlzc2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYXN5bmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9ldmVudHMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgLy8gUHJpbWFyeSBSZW5kZXJcbiAgICBDb21ib0JveC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZUlkID0gaWQgKyAnLWVycm9yJztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCByZXF1aXJlZCA9IF9hLnJlcXVpcmVkLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIF9iID0gX2Eub25SZW5kZXJDb250YWluZXIsIG9uUmVuZGVyQ29udGFpbmVyID0gX2IgPT09IHZvaWQgMCA/IHRoaXMuX29uUmVuZGVyQ29udGFpbmVyIDogX2IsIF9jID0gX2Eub25SZW5kZXJMYWJlbCwgb25SZW5kZXJMYWJlbCA9IF9jID09PSB2b2lkIDAgPyB0aGlzLl9vblJlbmRlckxhYmVsIDogX2MsIF9kID0gX2Eub25SZW5kZXJMaXN0LCBvblJlbmRlckxpc3QgPSBfZCA9PT0gdm9pZCAwID8gdGhpcy5fb25SZW5kZXJMaXN0IDogX2QsIF9lID0gX2Eub25SZW5kZXJJdGVtLCBvblJlbmRlckl0ZW0gPSBfZSA9PT0gdm9pZCAwID8gdGhpcy5fb25SZW5kZXJJdGVtIDogX2UsIF9mID0gX2Eub25SZW5kZXJPcHRpb24sIG9uUmVuZGVyT3B0aW9uID0gX2YgPT09IHZvaWQgMCA/IHRoaXMuX29uUmVuZGVyT3B0aW9uQ29udGVudCA6IF9mLCBhbGxvd0ZyZWVmb3JtID0gX2EuYWxsb3dGcmVlZm9ybSwgY3VzdG9tU3R5bGVzID0gX2Euc3R5bGVzLCB0aGVtZSA9IF9hLnRoZW1lLCBrZXl0aXBQcm9wcyA9IF9hLmtleXRpcFByb3BzLCBwZXJzaXN0TWVudSA9IF9hLnBlcnNpc3RNZW51LCBtdWx0aVNlbGVjdCA9IF9hLm11bHRpU2VsZWN0O1xuICAgICAgICB2YXIgX2cgPSB0aGlzLnN0YXRlLCBpc09wZW4gPSBfZy5pc09wZW4sIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSA9IF9nLnN1Z2dlc3RlZERpc3BsYXlWYWx1ZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFZpc2libGVWYWx1ZSA9IHRoaXMuX2dldFZpc2libGVWYWx1ZSgpO1xuICAgICAgICAvLyBTaW5nbGUgc2VsZWN0IGlzIGFscmVhZHkgYWNjZXNzaWJsZSBzaW5jZSB0aGUgd2hvbGUgdGV4dCBpcyBzZWxlY3RlZFxuICAgICAgICAvLyB3aGVuIGZvY3VzIGVudGVycyB0aGUgaW5wdXQuIFNpbmNlIG11bHRpc2VsZWN0IGFwcGVhcnMgdG8gY2xlYXIgdGhlIGlucHV0XG4gICAgICAgIC8vIGl0IG5lZWRzIHNwZWNpYWwgYWNjZXNzaWJsZSB0ZXh0XG4gICAgICAgIHZhciBtdWx0aXNlbGVjdEFjY2Vzc2libGVUZXh0ID0gbXVsdGlTZWxlY3RcbiAgICAgICAgICAgID8gdGhpcy5fZ2V0TXVsdGlzZWxlY3REaXNwbGF5U3RyaW5nKHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRpY2VzLCB0aGlzLnN0YXRlLmN1cnJlbnRPcHRpb25zLCBzdWdnZXN0ZWREaXNwbGF5VmFsdWUpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGRpdlByb3BzID0gZ2V0TmF0aXZlUHJvcHModGhpcy5wcm9wcywgZGl2UHJvcGVydGllcywgW1xuICAgICAgICAgICAgJ29uQ2hhbmdlJyxcbiAgICAgICAgICAgICd2YWx1ZScsXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgaGFzRXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlICYmIGVycm9yTWVzc2FnZS5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGFzc05hbWVzID0gdGhpcy5wcm9wcy5nZXRDbGFzc05hbWVzXG4gICAgICAgICAgICA/IHRoaXMucHJvcHMuZ2V0Q2xhc3NOYW1lcyh0aGVtZSwgISFpc09wZW4sICEhZGlzYWJsZWQsICEhcmVxdWlyZWQsICEhdGhpcy5faGFzRm9jdXMoKSwgISFhbGxvd0ZyZWVmb3JtLCAhIWhhc0Vycm9yTWVzc2FnZSwgY2xhc3NOYW1lKVxuICAgICAgICAgICAgOiBnZXRDbGFzc05hbWVzKGdldFN0eWxlcyh0aGVtZSwgY3VzdG9tU3R5bGVzKSwgY2xhc3NOYW1lLCAhIWlzT3BlbiwgISFkaXNhYmxlZCwgISFyZXF1aXJlZCwgISF0aGlzLl9oYXNGb2N1cygpLCAhIWFsbG93RnJlZWZvcm0sICEhaGFzRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgdmFyIGNvbWJvQm94V3JhcHBlciA9IGtleXRpcFByb3BzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2V5dGlwRGF0YSwgeyBrZXl0aXBQcm9wczoga2V5dGlwUHJvcHMsIGRpc2FibGVkOiBkaXNhYmxlZCB9LCBmdW5jdGlvbiAoa2V5dGlwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZW5kZXJDb21ib0JveFdyYXBwZXIobXVsdGlzZWxlY3RBY2Nlc3NpYmxlVGV4dCwgZXJyb3JNZXNzYWdlSWQsIGtleXRpcEF0dHJpYnV0ZXMpO1xuICAgICAgICB9KSkgOiAodGhpcy5fcmVuZGVyQ29tYm9Cb3hXcmFwcGVyKG11bHRpc2VsZWN0QWNjZXNzaWJsZVRleHQsIGVycm9yTWVzc2FnZUlkKSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZGl2UHJvcHMsIHsgcmVmOiB0aGlzLl9yb290LCBjbGFzc05hbWU6IHRoaXMuX2NsYXNzTmFtZXMuY29udGFpbmVyIH0pLFxuICAgICAgICAgICAgb25SZW5kZXJMYWJlbCh7IHByb3BzOiB0aGlzLnByb3BzLCBtdWx0aXNlbGVjdEFjY2Vzc2libGVUZXh0OiBtdWx0aXNlbGVjdEFjY2Vzc2libGVUZXh0IH0sIHRoaXMuX29uUmVuZGVyTGFiZWwpLFxuICAgICAgICAgICAgY29tYm9Cb3hXcmFwcGVyLFxuICAgICAgICAgICAgKHBlcnNpc3RNZW51IHx8IGlzT3BlbikgJiZcbiAgICAgICAgICAgICAgICBvblJlbmRlckNvbnRhaW5lcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcyksIHsgb25SZW5kZXJMaXN0OiBvblJlbmRlckxpc3QsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVuZGVySXRlbTogb25SZW5kZXJJdGVtLFxuICAgICAgICAgICAgICAgICAgICBvblJlbmRlck9wdGlvbjogb25SZW5kZXJPcHRpb24sIG9wdGlvbnM6IHRoaXMuc3RhdGUuY3VycmVudE9wdGlvbnMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtKSwgeyBpbmRleDogaW5kZXggfSkpOyB9KSwgb25EaXNtaXNzOiB0aGlzLl9vbkRpc21pc3MgfSksIHRoaXMuX29uUmVuZGVyQ29udGFpbmVyKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByb2xlOiBcInJlZ2lvblwiLCBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiLCBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiLCBpZDogZXJyb3JNZXNzYWdlSWQsIGNsYXNzTmFtZTogaGFzRXJyb3JNZXNzYWdlID8gdGhpcy5fY2xhc3NOYW1lcy5lcnJvck1lc3NhZ2UgOiAnJyB9LCBlcnJvck1lc3NhZ2UgIT09IHVuZGVmaW5lZCA/IGVycm9yTWVzc2FnZSA6ICcnKSkpO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRQZW5kaW5nU3RyaW5nID0gZnVuY3Rpb24gKGN1cnJlbnRQZW5kaW5nVmFsdWUsIGN1cnJlbnRPcHRpb25zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFBlbmRpbmdWYWx1ZSAhPT0gbnVsbCAmJiBjdXJyZW50UGVuZGluZ1ZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gY3VycmVudFBlbmRpbmdWYWx1ZVxuICAgICAgICAgICAgOiB0aGlzLl9pbmRleFdpdGhpbkJvdW5kcyhjdXJyZW50T3B0aW9ucywgaW5kZXgpXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50T3B0aW9uc1tpbmRleF0udGV4dFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgY29uY2F0ZW5hdGVzIGFsbCBvZiB0aGUgc2VsZWN0ZWQgdmFsdWVzXG4gICAgICogZm9yIG11bHRpc2VsZWN0IGNvbWJvYm94LlxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fZ2V0TXVsdGlzZWxlY3REaXNwbGF5U3RyaW5nID0gZnVuY3Rpb24gKHNlbGVjdGVkSW5kaWNlcywgY3VycmVudE9wdGlvbnMsIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSkge1xuICAgICAgICB2YXIgZGlzcGxheVZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBzZWxlY3RlZEluZGljZXMgJiYgaWR4IDwgc2VsZWN0ZWRJbmRpY2VzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkSW5kaWNlc1tpZHhdO1xuICAgICAgICAgICAgZGlzcGxheVZhbHVlcy5wdXNoKHRoaXMuX2luZGV4V2l0aGluQm91bmRzKGN1cnJlbnRPcHRpb25zLCBpbmRleClcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRPcHRpb25zW2luZGV4XS50ZXh0XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9ub3JtYWxpemVUb1N0cmluZyhzdWdnZXN0ZWREaXNwbGF5VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLm11bHRpU2VsZWN0RGVsaW1pdGVyLCBtdWx0aVNlbGVjdERlbGltaXRlciA9IF9hID09PSB2b2lkIDAgPyAnLCAnIDogX2E7XG4gICAgICAgIHJldHVybiBkaXNwbGF5VmFsdWVzLmpvaW4obXVsdGlTZWxlY3REZWxpbWl0ZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXMgdGhlIGluZGV4IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBhcnJheT9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY2hlY2sgaWYgdGhlIGluZGV4IGlzIHZhbGlkIGZvclxuICAgICAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIC0gdHJ1ZSBpZiB0aGUgaW5kZXggaXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBvcHRpb25zLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2luZGV4V2l0aGluQm91bmRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGluZGV4KSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBuZXcgaW5wdXQncyBuZXcgdmFsdWUgd2hlbiB0aGUgY29tYm9Cb3hcbiAgICAgKiBhbGxvd3MgZnJlZWZvcm0gZW50cnlcbiAgICAgKiBAcGFyYW0gdXBkYXRlZFZhbHVlIC0gdGhlIGlucHV0J3MgbmV3bHkgY2hhbmdlZCB2YWx1ZVxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fcHJvY2Vzc0lucHV0Q2hhbmdlV2l0aEZyZWVmb3JtID0gZnVuY3Rpb24gKHVwZGF0ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudE9wdGlvbnMgPSB0aGlzLnN0YXRlLmN1cnJlbnRPcHRpb25zO1xuICAgICAgICB2YXIgbmV3Q3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggPSAtMTtcbiAgICAgICAgLy8gaWYgdGhlIG5ldyB2YWx1ZSBpcyBlbXB0eSwgc2VlIGlmIHdlIGhhdmUgYW4gZXhhY3QgbWF0Y2hcbiAgICAgICAgLy8gYW5kIHRoZW4gc2V0IHRoZSBwZW5kaW5nIGluZm9cbiAgICAgICAgaWYgKHVwZGF0ZWRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGN1cnJlbnRPcHRpb25zXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5pdGVtVHlwZSAhPT0gU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZS5IZWFkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLml0ZW1UeXBlICE9PSBTZWxlY3RhYmxlT3B0aW9uTWVudUl0ZW1UeXBlLkRpdmlkZXI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gX3RoaXMuX2dldFByZXZpZXdUZXh0KG9wdGlvbikgPT09IHVwZGF0ZWRWYWx1ZTsgfSk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3VuZCBhIG1hdGNoIHJlbWVtYmVyIHRoZSBpbmRleFxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0N1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nSW5mbyh1cGRhdGVkVmFsdWUsIG5ld0N1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4LCB1cGRhdGVkVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZSBhbmQgdGhlbixcbiAgICAgICAgLy8gbWFrZSB0aGUgdmFsdWUgbG93ZXJjYXNlIGZvciBjb21wYXJpc29uXG4gICAgICAgIHZhciBvcmlnaW5hbFVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZWRWYWx1ZTtcbiAgICAgICAgdXBkYXRlZFZhbHVlID0gdXBkYXRlZFZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBuZXdTdWdnZXN0ZWREaXNwbGF5VmFsdWUgPSAnJztcbiAgICAgICAgLy8gSWYgYXV0b0NvbXBsZXRlIGlzIG9uLCBhdHRlbXB0IHRvIGZpbmQgYSBtYXRjaCBmcm9tIHRoZSBhdmFpbGFibGUgb3B0aW9uc1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hdXRvQ29tcGxldGUgPT09ICdvbicpIHtcbiAgICAgICAgICAgIC8vIElmIGF1dG9Db21wbGV0ZSBpcyBvbiwgYXR0ZW1wdCB0byBmaW5kIGEgbWF0Y2ggd2hlcmUgdGhlIHRleHQgb2YgYW4gb3B0aW9uIHN0YXJ0cyB3aXRoIHRoZSB1cGRhdGVkIHZhbHVlXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBjdXJyZW50T3B0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtKSwgeyBpbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uaXRlbVR5cGUgIT09IFNlbGVjdGFibGVPcHRpb25NZW51SXRlbVR5cGUuSGVhZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5pdGVtVHlwZSAhPT0gU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZS5EaXZpZGVyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldFByZXZpZXdUZXh0KG9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YodXBkYXRlZFZhbHVlKSA9PT0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgYXJpYUxhYmVsIGFzIHRoZSB2YWx1ZSB3aGVuIHRoZSBvcHRpb24gaXMgc2V0XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9nZXRQcmV2aWV3VGV4dChpdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgdHlwZWQgb3V0IHRoZSBjb21wbGV0ZSBvcHRpb24gdGV4dCwgd2UgZG9uJ3QgbmVlZCBhbnkgc3VnZ2VzdGVkIGRpc3BsYXkgdGV4dCBhbnltb3JlXG4gICAgICAgICAgICAgICAgbmV3U3VnZ2VzdGVkRGlzcGxheVZhbHVlID0gdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpICE9PSB1cGRhdGVkVmFsdWUgPyB0ZXh0IDogJyc7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGluZGV4IG9mIHRoZSBtYXRjaCB3ZSBmb3VuZFxuICAgICAgICAgICAgICAgIG5ld0N1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhdXRvQ29tcGxldGUgaXMgb2ZmLCBhdHRlbXB0IHRvIGZpbmQgYSBtYXRjaCBvbmx5IHdoZW4gdGhlIHZhbHVlIGlzIGV4YWN0bHkgZXF1YWwgdG8gdGhlIHRleHQgb2YgYW4gb3B0aW9uXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBjdXJyZW50T3B0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtKSwgeyBpbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uaXRlbVR5cGUgIT09IFNlbGVjdGFibGVPcHRpb25NZW51SXRlbVR5cGUuSGVhZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5pdGVtVHlwZSAhPT0gU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZS5EaXZpZGVyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIF90aGlzLl9nZXRQcmV2aWV3VGV4dChvcHRpb24pLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHVwZGF0ZWRWYWx1ZTsgfSk7XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3VuZCBhIG1hdGNoIHJlbWVtYmVyIHRoZSBpbmRleFxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0N1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSB1cGRhdGVkIHN0YXRlXG4gICAgICAgIHRoaXMuX3NldFBlbmRpbmdJbmZvKG9yaWdpbmFsVXBkYXRlZFZhbHVlLCBuZXdDdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCwgbmV3U3VnZ2VzdGVkRGlzcGxheVZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIG5ldyBpbnB1dCdzIG5ldyB2YWx1ZSB3aGVuIHRoZSBjb21ib0JveFxuICAgICAqIGRvZXMgbm90IGFsbG93IGZyZWVmb3JtIGVudHJ5XG4gICAgICogQHBhcmFtIHVwZGF0ZWRWYWx1ZSAtIHRoZSBpbnB1dCdzIG5ld2x5IGNoYW5nZWQgdmFsdWVcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3Byb2Nlc3NJbnB1dENoYW5nZVdpdGhvdXRGcmVlZm9ybSA9IGZ1bmN0aW9uICh1cGRhdGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgY3VycmVudFBlbmRpbmdWYWx1ZSA9IF9hLmN1cnJlbnRQZW5kaW5nVmFsdWUsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gX2EuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgsIGN1cnJlbnRPcHRpb25zID0gX2EuY3VycmVudE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmF1dG9Db21wbGV0ZSA9PT0gJ29uJykge1xuICAgICAgICAgICAgLy8gSWYgYXV0b0NvbXBsZXRlIGlzIG9uIHdoaWxlIGFsbG93IGZyZWVmb3JtIGlzIG9mZixcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVtZW1iZXIgdGhlIGtleXByZXNzZXMgYW5kIGJ1aWxkIHVwIGEgc3RyaW5nIHRvIGF0dGVtcHQgdG8gbWF0Y2hcbiAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgY2hhcmFjdGVycyBhcmUgdHlwZWQgd2l0aGluIGEgdGhlIHRpbWVvdXQgc3BhbiBvZiBlYWNoIG90aGVyLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgY2xlYXIgdGhlIHN0cmluZyBhbmQgc3RhcnQgYnVpbGRpbmcgYSBuZXcgb25lIG9uIHRoZSBuZXh0IGtleXByZXNzLlxuICAgICAgICAgICAgLy8gQWxzbywgb25seSBkbyB0aGlzIHByb2Nlc3NpbmcgaWYgd2UgaGF2ZSBhIG5vbi1lbXB0eSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHVwZGF0ZWRWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhdXRvY29tcGxldGUgY2xlYXJpbmcgdGFzayxcbiAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIHVzZXIgaXMgdHlwaW5nIHdpdGgga2V5cHJlc3NlcyBoYXBwZW5pbmdcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gdGhlIHRpbWVvdXQgb2YgZWFjaCBvdGhlciBzbyByZW1vdmUgdGhlIGNsZWFyaW5nIHRhc2tcbiAgICAgICAgICAgICAgICAvLyBhbmQgY29udGludWUgYnVpbGRpbmcgdGhlIHBlbmRpbmcgdmFsdWUgd2l0aCB0aGUgdWRwYXRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0UmVhZE9ubHlBdXRvQ29tcGxldGVDaGFuZ2VUaW1lb3V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hc3luYy5jbGVhclRpbWVvdXQodGhpcy5fbGFzdFJlYWRPbmx5QXV0b0NvbXBsZXRlQ2hhbmdlVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJlYWRPbmx5QXV0b0NvbXBsZXRlQ2hhbmdlVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkVmFsdWUgPSB0aGlzLl9ub3JtYWxpemVUb1N0cmluZyhjdXJyZW50UGVuZGluZ1ZhbHVlKSArIHVwZGF0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsVXBkYXRlZFZhbHVlID0gdXBkYXRlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZWRWYWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIElmIGF1dG9Db21wbGV0ZSBpcyBvbiwgYXR0ZW1wdCB0byBmaW5kIGEgbWF0Y2ggd2hlcmUgdGhlIHRleHQgb2YgYW4gb3B0aW9uIHN0YXJ0cyB3aXRoIHRoZSB1cGRhdGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gY3VycmVudE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IGluZGV4OiBpIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLml0ZW1UeXBlICE9PSBTZWxlY3RhYmxlT3B0aW9uTWVudUl0ZW1UeXBlLkhlYWRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLml0ZW1UeXBlICE9PSBTZWxlY3RhYmxlT3B0aW9uTWVudUl0ZW1UeXBlLkRpdmlkZXI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24udGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YodXBkYXRlZFZhbHVlKSA9PT0gMDsgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBtYXRjaCwgdWRwZGF0ZSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nSW5mbyhvcmlnaW5hbFVwZGF0ZWRWYWx1ZSwgaXRlbXNbMF0uaW5kZXgsIHRoaXMuX2dldFByZXZpZXdUZXh0KGl0ZW1zWzBdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgdGltZW91dCB0byBjbGVhciB0aGUgcGVuZGluZyB2YWx1ZSBhZnRlciB0aGUgdGltZW91dCBzcGFuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJlYWRPbmx5QXV0b0NvbXBsZXRlQ2hhbmdlVGltZW91dElkID0gdGhpcy5fYXN5bmMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0UmVhZE9ubHlBdXRvQ29tcGxldGVDaGFuZ2VUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSwgUmVhZE9ubHlQZW5kaW5nQXV0b0NvbXBsZXRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBlaXRoZXIgYXV0b0NvbXBsZXRlIGlzIG9uIG9yIHdlIGRpZCBub3QgZmluZCBhIG1hdGNoIHdpdGggYXV0b0NvbXBsZXRlIG9uLlxuICAgICAgICAvLyBSZW1lbWJlciB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtLCBzbyBhdCB0aGlzIHBvaW50LCBpZiB3ZSBoYXZlIGEgcGVuZGluZyB2YWxpZCB2YWx1ZSBpbmRleFxuICAgICAgICAvLyB1c2UgdGhhdDsgb3RoZXJ3aXNlIHVzZSB0aGUgc2VsZWN0ZWRJbmRleFxuICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCA+PSAwID8gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggOiB0aGlzLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgLy8gU2luY2Ugd2UgYXJlIG5vdCBhbGxvd2luZyBmcmVlZm9ybSwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBzZXQgYm90aCB0aGUgcGVuZGluZyBhbmQgc3VnZ2VzdGVkIHZhbHVlcy9pbmRleFxuICAgICAgICAvLyB0byBhbGxvdyB1cyB0byBzZWxlY3QgYWxsIGNvbnRlbnQgaW4gdGhlIGlucHV0IHRvXG4gICAgICAgIC8vIGdpdmUgdGhlIGlsbHVzaW9uIHRoYXQgd2UgYXJlIHJlYWRvbmx5IChlLmcuIGZyZWVmb3JtIG9mZilcbiAgICAgICAgdGhpcy5fc2V0UGVuZGluZ0luZm9Gcm9tSW5kZXgoaW5kZXgpO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kaWNlcyAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kaWNlcy5sZW5ndGggPiAwID8gdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGljZXNbMF0gOiAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhbGsgYWxvbmcgdGhlIG9wdGlvbnMgc3RhcnRpbmcgYXQgdGhlIGluZGV4LCBzdGVwcGluZyBieSB0aGUgZGVsdGEgKHBvc2l0aXZlIG9yIG5lZ2F0aXZlKVxuICAgICAqIGxvb2tpbmcgZm9yIHRoZSBuZXh0IHZhbGlkIHNlbGVjdGFibGUgaW5kZXggKGUuZy4gc2tpcHBpbmcgaGVhZGluZ3MgYW5kIGRpdmlkZXJzKVxuICAgICAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCB0byBnZXQgdGhlIG5leHQgc2VsZWN0YWJsZSBpbmRleCBmcm9tXG4gICAgICogQHBhcmFtIGRlbHRhIC0gb3B0aW9uYWwgZGVsdGEgdG8gc3RlcCBieSB3aGVuIGZpbmRpbmcgdGhlIG5leHQgaW5kZXgsIGRlZmF1bHRzIHRvIDBcbiAgICAgKiBAcmV0dXJucyAtIHRoZSBuZXh0IHZhbGlkIHNlbGVjdGFibGUgaW5kZXguIElmIHRoZSBuZXcgaW5kZXggaXMgb3V0c2lkZSBvZiB0aGUgYm91bmRzLFxuICAgICAqIGl0IHdpbGwgc25hcCB0byB0aGUgZWRnZSBvZiB0aGUgb3B0aW9ucyBhcnJheS4gSWYgZGVsdGEgPT0gMCBhbmQgdGhlIGdpdmVuIGluZGV4IGlzIG5vdCBzZWxlY3RhYmxlXG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXROZXh0U2VsZWN0YWJsZUluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBzZWFyY2hEaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnRPcHRpb25zID0gdGhpcy5zdGF0ZS5jdXJyZW50T3B0aW9ucztcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gaW5kZXggKyBzZWFyY2hEaXJlY3Rpb247XG4gICAgICAgIG5ld0luZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3VycmVudE9wdGlvbnMubGVuZ3RoIC0gMSwgbmV3SW5kZXgpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbmRleFdpdGhpbkJvdW5kcyhjdXJyZW50T3B0aW9ucywgbmV3SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbiA9IGN1cnJlbnRPcHRpb25zW25ld0luZGV4XTtcbiAgICAgICAgaWYgKG9wdGlvbi5pdGVtVHlwZSA9PT0gU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZS5IZWFkZXIgfHxcbiAgICAgICAgICAgIG9wdGlvbi5pdGVtVHlwZSA9PT0gU2VsZWN0YWJsZU9wdGlvbk1lbnVJdGVtVHlwZS5EaXZpZGVyIHx8XG4gICAgICAgICAgICBvcHRpb24uaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgY29udGludWUgbG9va2luZyBmb3IgYW4gaW5kZXggdG8gc2VsZWN0P1xuICAgICAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiAhPT0gU2VhcmNoRGlyZWN0aW9uLm5vbmUgJiZcbiAgICAgICAgICAgICAgICAoKG5ld0luZGV4ID4gMCAmJiBzZWFyY2hEaXJlY3Rpb24gPCBTZWFyY2hEaXJlY3Rpb24ubm9uZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5ld0luZGV4ID49IDAgJiYgbmV3SW5kZXggPCBjdXJyZW50T3B0aW9ucy5sZW5ndGggJiYgc2VhcmNoRGlyZWN0aW9uID4gU2VhcmNoRGlyZWN0aW9uLm5vbmUpKSkge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gdGhpcy5fZ2V0TmV4dFNlbGVjdGFibGVJbmRleChuZXdJbmRleCwgc2VhcmNoRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBwZXJmb3JtIGEgdXNlZnVsIHNlYXJjaCBqdXN0IHJldHVybiB0aGUgaW5kZXggd2Ugd2VyZSBnaXZlblxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHRoZSBuZXh0IHZhbGlkIHNlbGVjdGFibGUgaW5kZXgsIHJldHVybiBpdFxuICAgICAgICByZXR1cm4gbmV3SW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGVkIGluZGV4LiBOb3RlLCB0aGlzIGlzXG4gICAgICogdGhlIFwicmVhbFwiIHNlbGVjdGVkIGluZGV4LCBub3QgdGhlIHBlbmRpbmcgc2VsZWN0ZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggdG8gc2V0IChvciB0aGUgaW5kZXggdG8gc2V0IGZyb20gaWYgYSBzZWFyY2ggZGlyZWN0aW9uIGlzIHByb3ZpZGVkKVxuICAgICAqIEBwYXJhbSBzZWFyY2hEaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIHRvIHNlYXJjaCBhbG9uZyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBnaXZlbiBpbmRleFxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fc2V0U2VsZWN0ZWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgc3VibWl0UGVuZGluZ1ZhbHVlRXZlbnQsIHNlYXJjaERpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSB2b2lkIDApIHsgc2VhcmNoRGlyZWN0aW9uID0gU2VhcmNoRGlyZWN0aW9uLm5vbmU7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgb25QZW5kaW5nVmFsdWVDaGFuZ2VkID0gX2Eub25QZW5kaW5nVmFsdWVDaGFuZ2VkO1xuICAgICAgICB2YXIgY3VycmVudE9wdGlvbnMgPSB0aGlzLnN0YXRlLmN1cnJlbnRPcHRpb25zO1xuICAgICAgICB2YXIgaW5pdGlhbEluZGljZXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kaWNlcztcbiAgICAgICAgLy8gQ2xvbmUgc2VsZWN0ZWRJbmRpY2VzIHNvIHdlIGRvbid0IG11dGF0ZSBzdGF0ZVxuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRpY2VzID0gaW5pdGlhbEluZGljZXMgPyBpbml0aWFsSW5kaWNlcy5zbGljZSgpIDogW107XG4gICAgICAgIC8vIEZpbmQgdGhlIG5leHQgc2VsZWN0YWJsZSBpbmRleCwgaWYgc2VhcmNoRGlyZWN0aW9uIGlzIG5vbmVcbiAgICAgICAgLy8gd2Ugd2lsbCBnZXQgb3VyIHN0YXJ0aW5nIGluZGV4IGJhY2tcbiAgICAgICAgaW5kZXggPSB0aGlzLl9nZXROZXh0U2VsZWN0YWJsZUluZGV4KGluZGV4LCBzZWFyY2hEaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXRoaXMuX2luZGV4V2l0aGluQm91bmRzKGN1cnJlbnRPcHRpb25zLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgd2UgYXQgYSBuZXcgaW5kZXg/IElmIHNvLCB1cGRhdGUgdGhlIHN0YXRlLCBvdGhlcndpc2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tdWx0aVNlbGVjdCB8fFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzLmxlbmd0aCA8IDEgfHxcbiAgICAgICAgICAgIChzZWxlY3RlZEluZGljZXMubGVuZ3RoID09PSAxICYmIHNlbGVjdGVkSW5kaWNlc1swXSAhPT0gaW5kZXgpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uXzEgPSBfX2Fzc2lnbih7fSwgY3VycmVudE9wdGlvbnNbaW5kZXhdKTtcbiAgICAgICAgICAgIC8vIGlmIG9wdGlvbiBkb2Vzbid0IGV4aXN0aW5nLCBvciBvcHRpb24gaXMgZGlzYWJsZWQsIHdlIG5vb3BcbiAgICAgICAgICAgIGlmICghb3B0aW9uXzEgfHwgb3B0aW9uXzEuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGluaXRpYWwgc3RhdGUgb2Ygb3B0aW9uLnNlbGVjdGVkIGluIE11bHRpLXNlbGVjdCBjb21ib2JveCBieSBjaGVja2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RlZEluZGljZXMgYXJyYXkgYW5kIG92ZXJyaWRpbmcgdGhlIHVuZGVmaW5lZCBpc3N1ZVxuICAgICAgICAgICAgICAgIG9wdGlvbl8xLnNlbGVjdGVkID0gb3B0aW9uXzEuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25fMS5zZWxlY3RlZCA6IHNlbGVjdGVkSW5kaWNlcy5pbmRleE9mKGluZGV4KSA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbl8xLnNlbGVjdGVkICYmIHNlbGVjdGVkSW5kaWNlcy5pbmRleE9mKGluZGV4KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghb3B0aW9uXzEuc2VsZWN0ZWQgJiYgc2VsZWN0ZWRJbmRpY2VzLmluZGV4T2YoaW5kZXgpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzID0gc2VsZWN0ZWRJbmRpY2VzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBpbmRleDsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzWzBdID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJtaXRQZW5kaW5nVmFsdWVFdmVudC5wZXJzaXN0KCk7XG4gICAgICAgICAgICAvLyBPbmx5IHNldHN0YXRlIGlmIGNvbWJvYm94IGlzIHVuY29udHJvbGxlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdGVkS2V5IHx8IHRoaXMucHJvcHMuc2VsZWN0ZWRLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBDb21ib0JveCB2YWx1ZSBpcyBjaGFuZ2VkLCByZXZlcnQgcHJldmlldyBmaXJzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNQZW5kaW5nVmFsdWUgJiYgb25QZW5kaW5nVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUGVuZGluZ1ZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHN1Ym1pdFBlbmRpbmdWYWx1ZUV2ZW50LCBvcHRpb25fMSwgaW5kZXgsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkT3B0aW9ucyA9IGN1cnJlbnRPcHRpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnNbaW5kZXhdID0gb3B0aW9uXzE7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBvbkNoYW5nZSBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kaWNlczogc2VsZWN0ZWRJbmRpY2VzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3B0aW9uczogY2hhbmdlZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBDb21ib0JveCB2YWx1ZSBpcyBjaGFuZ2VkLCByZXZlcnQgcHJldmlldyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2hhc1BlbmRpbmdWYWx1ZSAmJiBvblBlbmRpbmdWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUGVuZGluZ1ZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhc1BlbmRpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoc3VibWl0UGVuZGluZ1ZhbHVlRXZlbnQsIG9wdGlvbl8xLCBpbmRleCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm11bHRpU2VsZWN0ICYmIHRoaXMuc3RhdGUuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgYWxsIG9mIHRoZSBwZW5kaW5nIGluZm9cbiAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nSW5mbygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3VibWl0IGEgcGVuZGluZyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmVcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3N1Ym1pdFBlbmRpbmdWYWx1ZSA9IGZ1bmN0aW9uIChzdWJtaXRQZW5kaW5nVmFsdWVFdmVudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBhbGxvd0ZyZWVmb3JtID0gX2EuYWxsb3dGcmVlZm9ybSwgYXV0b0NvbXBsZXRlID0gX2EuYXV0b0NvbXBsZXRlO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBjdXJyZW50UGVuZGluZ1ZhbHVlID0gX2IuY3VycmVudFBlbmRpbmdWYWx1ZSwgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggPSBfYi5jdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCwgY3VycmVudE9wdGlvbnMgPSBfYi5jdXJyZW50T3B0aW9ucywgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyID0gX2IuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyO1xuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRpY2VzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGljZXM7XG4gICAgICAgIC8vIERvIG5vdCBzdWJtaXQgYW55IHBlbmRpbmcgdmFsdWUgaWYgd2VcbiAgICAgICAgLy8gaGF2ZSBhbHJlYWR5IGluaXRpYXRlZCBjbGVhcmluZyB0aGUgcGVuZGluZyBpbmZvXG4gICAgICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nQ2xlYXJQZW5kaW5nSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFsbG93IGZyZWVmb3JtIHdlIG5lZWQgdG8gaGFuZGxlIHRoYXRcbiAgICAgICAgaWYgKGFsbG93RnJlZWZvcm0pIHtcbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRQZW5kaW5nVmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgdGhlIHVzZXIgZGlkIG5vdCBzdWJtaXQgYW55dGhpbmdcbiAgICAgICAgICAgIC8vIChub3QgZXZlbiBlbXB0eSBiZWNhdXNlIHdlIHdvdWxkIGhhdmUgc3RvcmVkIHRoYXQgYXMgdGhlIHBlbmRpbmcgdmFsdWUpXG4gICAgICAgICAgICBpZiAoY3VycmVudFBlbmRpbmdWYWx1ZSA9PT0gbnVsbCB8fCBjdXJyZW50UGVuZGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHVzZXIgZGlkIG5vdCB0eXBlIGFueXRoaW5nIHRoZXkgbWF5IGp1c3QgaG92ZXJlZCBvdmVyIGFuIGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWRJbmRleChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIsIHN1Ym1pdFBlbmRpbmdWYWx1ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nSW5mbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHVzZXIgdHlwZWQgYW4gZXhhY3QgbWF0Y2hcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleFdpdGhpbkJvdW5kcyhjdXJyZW50T3B0aW9ucywgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdPcHRpb25UZXh0ID0gdGhpcy5fZ2V0UHJldmlld1RleHQoY3VycmVudE9wdGlvbnNbY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhdKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIEJ5IGV4YWN0IG1hdGNoLCB0aGF0IG1lYW5zOiBvdXIgcGVuZGluZyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcGVuZGluZyBvcHRpb24gdGV4dCBPUlxuICAgICAgICAgICAgICAgIC8vIHRoZSBwZW5kaW5nIG9wdGlvbiBzdGFydHMgd2l0aCB0aGUgcGVuZGluZyB2YWx1ZSBhbmQgd2UgaGF2ZSBhbiBcImF1dG9Db21wbGV0ZVwiIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRoZSB0b3RhbCBsZW5ndGggaXMgZXF1YWwgdG8gcGVuZGluZyBvcHRpb24gbGVuZ3RoIE9SXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpdmUgdmFsdWUgaW4gdGhlIHVuZGVybHlpbmcgaW5wdXQgbWF0Y2hlcyB0aGUgcGVuZGluZyBvcHRpb247IHVwZGF0ZSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlbmRpbmdWYWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBwZW5kaW5nT3B0aW9uVGV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAoYXV0b0NvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nT3B0aW9uVGV4dC5pbmRleE9mKGN1cnJlbnRQZW5kaW5nVmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9maWxsLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9maWxsLmN1cnJlbnQuaXNWYWx1ZVNlbGVjdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVuZGluZ1ZhbHVlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2F1dG9maWxsLmN1cnJlbnQuc2VsZWN0aW9uRW5kIC0gdGhpcy5fYXV0b2ZpbGwuY3VycmVudC5zZWxlY3Rpb25TdGFydCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ09wdGlvblRleHQubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fYXV0b2ZpbGwuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0b2ZpbGwuY3VycmVudC5pbnB1dEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9maWxsLmN1cnJlbnQuaW5wdXRFbGVtZW50LnZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHBlbmRpbmdPcHRpb25UZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEluZGV4KGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4LCBzdWJtaXRQZW5kaW5nVmFsdWVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm11bHRpU2VsZWN0ICYmIHRoaXMuc3RhdGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgb25DaGFuZ2UgdG8gY2xlYXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoc3VibWl0UGVuZGluZ1ZhbHVlRXZlbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjdXJyZW50UGVuZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGNvbnRyb2xsZWQsIGNyZWF0ZSBhIG5ldyBzZWxlY3RlZCBvcHRpb25cbiAgICAgICAgICAgICAgICB2YXIgbmV3T3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGN1cnJlbnRQZW5kaW5nVmFsdWUgfHwgZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fbm9ybWFsaXplVG9TdHJpbmcoY3VycmVudFBlbmRpbmdWYWx1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG11bHRpc2VsZWN0LCBzZXQgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gY3VycmVudE9wdGlvbnMuY29uY2F0KFtuZXdPcHRpb25dKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRpY2VzLnB1c2gobmV3T3B0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcHRpb25zOiBuZXdPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGljZXM6IHNlbGVjdGVkSW5kaWNlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgbm90IGFsbG93aW5nIGZyZWVmb3JtLCB3ZSBtdXN0IGhhdmUgYSBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gdG8gYmUgYWJsZSB0byB1cGRhdGUgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkSW5kZXgoY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgsIHN1Ym1pdFBlbmRpbmdWYWx1ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIgPj0gMCkge1xuICAgICAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbGVkIGFuZCB3ZSB3ZXJlIGhvdmVyaW5nIG92ZXIgYW4gaXRlbSwgc2VsZWN0IGl0XG4gICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3RlZEluZGV4KGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3Zlciwgc3VibWl0UGVuZGluZ1ZhbHVlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmFsbHksIGNsZWFyIHRoZSBwZW5kaW5nIGluZm9cbiAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nSW5mbygpO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9vbkNhbGxvdXRMYXllck1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluIHBlcnNpc3RNZW51IG1vZGUgX29uTGF5ZXJNb3VudGVkIGlzIG9ubHkgY2FsbGVkIG9uY2UgZm9yIHRoZSBsaWZldGltZVxuICAgICAgICAvLyBvZiB0aGUgY29tcG9uZW50LiBBbnkgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCBmb3IgY2FsbG91dCBcIm9uIG1vdW50XCIgY2FuXG4gICAgICAgIC8vIGdvIGhlcmUgc28gdGhhdCB3ZSBjYW4gYWxzbyBjYWxsIGl0IGFnYWluIGR1cmluZyBjYWxsb3V0IGRpc21pc3NhbCB0byByZXNldFxuICAgICAgICAvLyBvYmplY3Qgc3RhdGUuXG4gICAgICAgIHRoaXMuX2dvdE1vdXNlTW92ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgLy8gUmVuZGVyIHNlcGFyYXRvclxuICAgIENvbWJvQm94LnByb3RvdHlwZS5fcmVuZGVyU2VwYXJhdG9yID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaXRlbS5pbmRleCwga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgIGlmIChpbmRleCAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogXCJzZXBhcmF0b3JcIiwga2V5OiBrZXksIGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5kaXZpZGVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLm9uUmVuZGVyT3B0aW9uLCBvblJlbmRlck9wdGlvbiA9IF9hID09PSB2b2lkIDAgPyB0aGlzLl9vblJlbmRlck9wdGlvbkNvbnRlbnQgOiBfYTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBpdGVtLmtleSwgY2xhc3NOYW1lOiB0aGlzLl9jbGFzc05hbWVzLmhlYWRlciB9LCBvblJlbmRlck9wdGlvbihpdGVtLCB0aGlzLl9vblJlbmRlck9wdGlvbkNvbnRlbnQpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgY29taW5nIGZyb20gYSBtb3VzZU91dDpcbiAgICAgKiB0aGVyZSBpcyBubyB2aXNpYmxlIHNlbGVjdGVkIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEVsc2UgaWYgV2UgYXJlIGhvdmVyaW5nIG92ZXIgYW4gaXRlbTpcbiAgICAgKiB0aGF0IGdldHMgdGhlIHNlbGVjdGVkIGxvb2suXG4gICAgICpcbiAgICAgKiBFbHNlOlxuICAgICAqIFVzZSB0aGUgY3VycmVudCB2YWxpZCBwZW5kaW5nIGluZGV4IGlmIGl0IGV4aXN0cyBPUlxuICAgICAqIHdlIGRvIG5vdCBoYXZlIGEgdmFsaWQgaW5kZXggYW5kIHdlIGN1cnJlbnRseSBoYXZlIGEgcGVuZGluZyBpbnB1dCB2YWx1ZSxcbiAgICAgKiBvdGhlcndpc2UgdXNlIHRoZSBzZWxlY3RlZCBpbmRleFxuICAgICAqICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9pc09wdGlvblNlbGVjdGVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlcjtcbiAgICAgICAgLy8gSWYgdGhlIGhvdmVyIHN0YXRlIGlzIHNldCB0byBjbGVhckFsbCwgZG9uJ3Qgc2hvdyBhIHNlbGVjdGVkIGluZGV4LlxuICAgICAgICAvLyBOb3RlLCB0aGlzIGhhcHBlbnMgd2hlbiB0aGUgdXNlciBtb3VzZWQgb3V0IG9mIHRoZSBtZW51IGl0ZW1zXG4gICAgICAgIGlmIChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIgPT09IEhvdmVyU3RhdHVzLmNsZWFyQWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFBlbmRpbmdTZWxlY3RlZEluZGV4KHRydWUgLyogaW5jbHVkZVBlbmRpbmdWYWx1ZSAqLykgPT09IGluZGV4ID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9pc09wdGlvbkNoZWNrZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubXVsdGlTZWxlY3QgJiYgaW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN0YXRlLnNlbGVjdGVkSW5kaWNlcykge1xuICAgICAgICAgICAgdmFyIGlkeE9mU2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWR4T2ZTZWxlY3RlZEluZGV4ID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGljZXMuaW5kZXhPZihpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gaWR4T2ZTZWxlY3RlZEluZGV4ID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGVuZGluZyBzZWxlY3RlZCBpbmRleCB0YWtpbmcgaW50byBhY2NvdW50IGhvdmVyLCB2YWx1ZVZhbGlkSW5kZXgsIGFuZCBzZWxlY3RlZEluZGV4XG4gICAgICogQHBhcmFtIGluY2x1ZGVDdXJyZW50UGVuZGluZ1ZhbHVlIC0gU2hvdWxkIHdlIGluY2x1ZGUgdGhlIGN1cnJlbnRQZW5kaW5nVmFsdWUgd2hlblxuICAgICAqIGZpbmRpbmcgdGhlIGluZGV4XG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRQZW5kaW5nU2VsZWN0ZWRJbmRleCA9IGZ1bmN0aW9uIChpbmNsdWRlQ3VycmVudFBlbmRpbmdWYWx1ZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIgPSBfYS5jdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleE9uSG92ZXIsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gX2EuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgsIGN1cnJlbnRQZW5kaW5nVmFsdWUgPSBfYS5jdXJyZW50UGVuZGluZ1ZhbHVlO1xuICAgICAgICByZXR1cm4gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyID49IDBcbiAgICAgICAgICAgID8gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyXG4gICAgICAgICAgICA6IGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID49IDAgfHxcbiAgICAgICAgICAgICAgICAoaW5jbHVkZUN1cnJlbnRQZW5kaW5nVmFsdWUgJiYgY3VycmVudFBlbmRpbmdWYWx1ZSAhPT0gbnVsbCAmJiBjdXJyZW50UGVuZGluZ1ZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleFxuICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5tdWx0aVNlbGVjdFxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgc2VsZWN0ZWQgZWxlbWVudCBpbnRvIHZpZXdcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3Njcm9sbEludG9WaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBvblNjcm9sbFRvSXRlbSA9IF9hLm9uU2Nyb2xsVG9JdGVtLCBzY3JvbGxTZWxlY3RlZFRvVG9wID0gX2Euc2Nyb2xsU2VsZWN0ZWRUb1RvcDtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggPSBfYi5jdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCwgY3VycmVudFBlbmRpbmdWYWx1ZSA9IF9iLmN1cnJlbnRQZW5kaW5nVmFsdWU7XG4gICAgICAgIGlmIChvblNjcm9sbFRvSXRlbSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBjdXN0b20gc2Nyb2xsIGhhbmRsZXJcbiAgICAgICAgICAgIG9uU2Nyb2xsVG9JdGVtKGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID49IDAgfHwgY3VycmVudFBlbmRpbmdWYWx1ZSAhPT0gJydcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0ZWRFbGVtZW50LmN1cnJlbnQgJiYgdGhpcy5fc2VsZWN0ZWRFbGVtZW50LmN1cnJlbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgdXNpbmcgcmVmcywgc2Nyb2xsIHRoZSByZWYgaW50byB2aWV3XG4gICAgICAgICAgICBpZiAoc2Nyb2xsU2VsZWN0ZWRUb1RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRWxlbWVudC5jdXJyZW50Lm9mZnNldFBhcmVudC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhbGlnblRvVG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29tYm9Cb3hNZW51LmN1cnJlbnQgJiYgdGhpcy5fY29tYm9Cb3hNZW51LmN1cnJlbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50UmVjdCA9IHRoaXMuX2NvbWJvQm94TWVudS5jdXJyZW50Lm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkRWxlbWVudFJlY3QgPSB0aGlzLl9zZWxlY3RlZEVsZW1lbnQuY3VycmVudC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBjb21wbGV0ZWx5IGluIHZpZXcgdGhlbiB3ZSBkbyBub3QgbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnRSZWN0LnRvcCA8PSBzZWxlY3RlZEVsZW1lbnRSZWN0LnRvcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudFJlY3QudG9wICsgc2Nyb2xsYWJsZVBhcmVudFJlY3QuaGVpZ2h0ID49XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50UmVjdC50b3AgKyBzZWxlY3RlZEVsZW1lbnRSZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBsb3dlciB0aGFuIHRoZSBzY3JvbGxhYmxlIHBhcmVudCB2aWV3cG9ydCB0aGVuIHdlIHNob3VsZCBhbGlnbiB0byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50UmVjdC50b3AgKyBzY3JvbGxhYmxlUGFyZW50UmVjdC5oZWlnaHQgPD1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudFJlY3QudG9wICsgc2VsZWN0ZWRFbGVtZW50UmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduVG9Ub3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEVsZW1lbnQuY3VycmVudC5vZmZzZXRQYXJlbnQuc2Nyb2xsSW50b1ZpZXcoYWxpZ25Ub1RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIgZm9yIHRoZSBtZW51IGl0ZW1zXG4gICAgICogdG8gc2VsZWN0IHRoZSBpdGVtIGFuZCBhbHNvIGNsb3NlIHRoZSBtZW51XG4gICAgICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgd2FzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX29uSXRlbUNsaWNrID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9uSXRlbUNsaWNrID0gdGhpcy5wcm9wcy5vbkl0ZW1DbGljaztcbiAgICAgICAgdmFyIGluZGV4ID0gaXRlbS5pbmRleDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgb25JdGVtQ2xpY2sgJiYgb25JdGVtQ2xpY2soZXYsIGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIF90aGlzLl9zZXRTZWxlY3RlZEluZGV4KGluZGV4LCBldik7XG4gICAgICAgICAgICAvLyBvbmx5IGNsb3NlIHRoZSBjYWxsb3V0IHdoZW4gaXQncyBpbiBzaW5nbGUtc2VsZWN0IG1vZGVcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBmb2N1cyByZXR1cm5zIHRvIHRoZSBpbnB1dCwgbm90IHRoZSBidXR0b25cbiAgICAgICAgICAgICAgICBfdGhpcy5fYXV0b2ZpbGwuY3VycmVudCAmJiBfdGhpcy5fYXV0b2ZpbGwuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kaWNlcyBvZiB0aGUgb3B0aW9ucyB0aGF0IGFyZSBtYXJrZWQgYXMgc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBjb21ib0JveCBvcHRpb25zXG4gICAgICogQHBhcmFtIHNlbGVjdGVkS2V5cyAtIHRoZSBrbm93biBzZWxlY3RlZCBrZXlzIHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyAtIGFuIGFycmF5IG9mIHRoZSBpbmRpY2VzIG9mIHRoZSBzZWxlY3RlZCBvcHRpb25zLCBlbXB0eSBhcnJheSBpZiBub3RoaW5nIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRTZWxlY3RlZEluZGljZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgc2VsZWN0ZWRLZXlzKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAhc2VsZWN0ZWRLZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kaWNlcyA9IHt9O1xuICAgICAgICBvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGljZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNlbGVjdGVkS2V5KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gb3B0aW9uLmtleSA9PT0gc2VsZWN0ZWRLZXk7IH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGljZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWxlY3RlZEtleXNfMSA9IHNlbGVjdGVkS2V5czsgX2kgPCBzZWxlY3RlZEtleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEtleSA9IHNlbGVjdGVkS2V5c18xW19pXTtcbiAgICAgICAgICAgIF9sb29wXzEoc2VsZWN0ZWRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzZWxlY3RlZEluZGljZXMpXG4gICAgICAgICAgICAubWFwKE51bWJlcilcbiAgICAgICAgICAgIC5zb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgc2VsZWN0ZWQgaW5kZXggYnkgY2xlYXJpbmcgdGhlXG4gICAgICogaW5wdXQgKG9mIGFueSBwZW5kaW5nIHRleHQpLCBjbGVhcmluZyB0aGUgcGVuZGluZyBzdGF0ZSxcbiAgICAgKiBhbmQgc2V0dGluZyB0aGUgc3VnZ2VzdGVkIGRpc3BsYXkgdmFsdWUgdG8gdGhlIGxhc3RcbiAgICAgKiBzZWxlY3RlZCBzdGF0ZSB0ZXh0XG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9yZXNldFNlbGVjdGVkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50T3B0aW9ucyA9IHRoaXMuc3RhdGUuY3VycmVudE9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2NsZWFyUGVuZGluZ0luZm8oKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSB0aGlzLl9nZXRGaXJzdFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPiAwICYmIHNlbGVjdGVkSW5kZXggPCBjdXJyZW50T3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZTogY3VycmVudE9wdGlvbnNbc2VsZWN0ZWRJbmRleF0udGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMudGV4dCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGEgdmFsdWUgaW5pdGlhbGx5LCByZXN0b3JlIGl0XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWREaXNwbGF5VmFsdWU6IHRoaXMucHJvcHMudGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHBlbmRpbmcgaW5mbyBzdGF0ZVxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fY2xlYXJQZW5kaW5nSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NsZWFyUGVuZGluZ0luZm8gPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4OiAtMSxcbiAgICAgICAgICAgIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyOiBIb3ZlclN0YXR1cy5kZWZhdWx0LFxuICAgICAgICB9LCB0aGlzLl9vbkFmdGVyQ2xlYXJQZW5kaW5nSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBlbmRpbmcgaW5mb1xuICAgICAqIEBwYXJhbSBjdXJyZW50UGVuZGluZ1ZhbHVlIC0gbmV3IHBlbmRpbmcgdmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4IC0gbmV3IHBlbmRpbmcgdmFsdWUgaW5kZXggdG8gc2V0XG4gICAgICogQHBhcmFtIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZSAtIG5ldyBzdWdnZXN0IGRpc3BsYXkgdmFsdWUgdG8gc2V0XG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9zZXRQZW5kaW5nSW5mbyA9IGZ1bmN0aW9uIChjdXJyZW50UGVuZGluZ1ZhbHVlLCBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCwgc3VnZ2VzdGVkRGlzcGxheVZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCA9PT0gdm9pZCAwKSB7IGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gLTE7IH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdDbGVhclBlbmRpbmdJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50UGVuZGluZ1ZhbHVlOiB0aGlzLl9ub3JtYWxpemVUb1N0cmluZyhjdXJyZW50UGVuZGluZ1ZhbHVlKSxcbiAgICAgICAgICAgIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4OiBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCxcbiAgICAgICAgICAgIHN1Z2dlc3RlZERpc3BsYXlWYWx1ZTogc3VnZ2VzdGVkRGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyOiBIb3ZlclN0YXR1cy5kZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGVuZGluZyBpbmZvIGZyb20gdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IHRvIHNldCB0aGUgcGVuZGluZyBpbmZvIGZyb21cbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3NldFBlbmRpbmdJbmZvRnJvbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjdXJyZW50T3B0aW9ucyA9IHRoaXMuc3RhdGUuY3VycmVudE9wdGlvbnM7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VycmVudE9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gY3VycmVudE9wdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ0luZm8odGhpcy5fZ2V0UHJldmlld1RleHQob3B0aW9uKSwgaW5kZXgsIHRoaXMuX2dldFByZXZpZXdUZXh0KG9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nSW5mbygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwZW5kaW5nIGluZm8gZm9yIHRoZSBjb21ib0JveFxuICAgICAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqIEBwYXJhbSBzZWFyY2hEaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIHRvIHNlYXJjaFxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fc2V0UGVuZGluZ0luZm9Gcm9tSW5kZXhBbmREaXJlY3Rpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHNlYXJjaERpcmVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudE9wdGlvbnMgPSB0aGlzLnN0YXRlLmN1cnJlbnRPcHRpb25zO1xuICAgICAgICAvLyB1cGRhdGUgaW5kZXggdG8gYWxsb3cgY29udGVudCB0byB3cmFwXG4gICAgICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IFNlYXJjaERpcmVjdGlvbi5mb3J3YXJkICYmIGluZGV4ID49IGN1cnJlbnRPcHRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSBTZWFyY2hEaXJlY3Rpb24uYmFja3dhcmQgJiYgaW5kZXggPD0gMCkge1xuICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50T3B0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IHRoZSBuZXh0IFwidmFsaWRcIiBpbmRleFxuICAgICAgICB2YXIgaW5kZXhVcGRhdGUgPSB0aGlzLl9nZXROZXh0U2VsZWN0YWJsZUluZGV4KGluZGV4LCBzZWFyY2hEaXJlY3Rpb24pO1xuICAgICAgICAvLyBpZiB0aGUgdHdvIGluZGljaWVzIGFyZSBlcXVhbCB3ZSBkaWRuJ3QgbW92ZSBhbmRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgdG8gZ2V0ICBnZXQgdGhlIGZpcnN0L2xhc3QgXCJ2YWxpZFwiIGluZGV4IHRvIHVzZVxuICAgICAgICAvLyAoTm90ZSwgdGhpcyB0YWtlcyBjYXJlIG9mIHRoZSBwb3RlbnRpYWwgY2FzZXMgd2hlcmUgdGhlIGZpcnN0L2xhc3RcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgZm9jdXNhYmxlKSwgb3RoZXJ3aXNlIHVzZSB0aGUgdXBkYXRlZCBpbmRleFxuICAgICAgICBpZiAoaW5kZXggPT09IGluZGV4VXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSBTZWFyY2hEaXJlY3Rpb24uZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fZ2V0TmV4dFNlbGVjdGFibGVJbmRleCgtMSwgc2VhcmNoRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gU2VhcmNoRGlyZWN0aW9uLmJhY2t3YXJkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9nZXROZXh0U2VsZWN0YWJsZUluZGV4KGN1cnJlbnRPcHRpb25zLmxlbmd0aCwgc2VhcmNoRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXhVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luZGV4V2l0aGluQm91bmRzKGN1cnJlbnRPcHRpb25zLCBpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdJbmZvRnJvbUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9ub3RpZnlQZW5kaW5nVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgb25QZW5kaW5nVmFsdWVDaGFuZ2VkID0gdGhpcy5wcm9wcy5vblBlbmRpbmdWYWx1ZUNoYW5nZWQ7XG4gICAgICAgIGlmICghb25QZW5kaW5nVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgY3VycmVudFBlbmRpbmdWYWx1ZSA9IF9hLmN1cnJlbnRQZW5kaW5nVmFsdWUsIGN1cnJlbnRPcHRpb25zID0gX2EuY3VycmVudE9wdGlvbnMsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ID0gX2EuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXgsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlciA9IF9hLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlcjtcbiAgICAgICAgdmFyIG5ld1BlbmRpbmdJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG5ld1BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlciAhPT0gcHJldlN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlciAmJlxuICAgICAgICAgICAgdGhpcy5faW5kZXhXaXRoaW5Cb3VuZHMoY3VycmVudE9wdGlvbnMsIGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4T25Ib3ZlcikpIHtcbiAgICAgICAgICAgIC8vIFNldCBuZXcgcGVuZGluZyBpbmRleCBpZiBob3ZlciBpbmRleCB3YXMgY2hhbmdlZFxuICAgICAgICAgICAgbmV3UGVuZGluZ0luZGV4ID0gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ICE9PSBwcmV2U3RhdGUuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXggJiZcbiAgICAgICAgICAgIHRoaXMuX2luZGV4V2l0aGluQm91bmRzKGN1cnJlbnRPcHRpb25zLCBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCkpIHtcbiAgICAgICAgICAgIC8vIFNldCBuZXcgcGVuZGluZyBpbmRleCBpZiBjdXJyZW50UGVuZGluZ1ZhbHVlVmFsaWRJbmRleCB3YXMgY2hhbmdlZFxuICAgICAgICAgICAgbmV3UGVuZGluZ0luZGV4ID0gY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFBlbmRpbmdWYWx1ZSAhPT0gcHJldlN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBwZW5kaW5nVmFsdWUgaW4gdGhlIGNhc2UgaXQgd2FzIGNoYW5nZWQgYW5kIG5vIGluZGV4IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICBuZXdQZW5kaW5nVmFsdWUgPSBjdXJyZW50UGVuZGluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGlmeSB3aGVuIHRoZXJlIGlzIGEgbmV3IHBlbmRpbmcgaW5kZXgvdmFsdWUuIEFsc28sIGlmIHRoZXJlIGlzIGEgcGVuZGluZyB2YWx1ZSwgaXQgbmVlZHMgdG8gc2VuZCB1bmRlZmluZWQuXG4gICAgICAgIGlmIChuZXdQZW5kaW5nSW5kZXggIT09IHVuZGVmaW5lZCB8fCBuZXdQZW5kaW5nVmFsdWUgIT09IHVuZGVmaW5lZCB8fCB0aGlzLl9oYXNQZW5kaW5nVmFsdWUpIHtcbiAgICAgICAgICAgIG9uUGVuZGluZ1ZhbHVlQ2hhbmdlZChuZXdQZW5kaW5nSW5kZXggIT09IHVuZGVmaW5lZCA/IGN1cnJlbnRPcHRpb25zW25ld1BlbmRpbmdJbmRleF0gOiB1bmRlZmluZWQsIG5ld1BlbmRpbmdJbmRleCwgbmV3UGVuZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdWYWx1ZSA9IG5ld1BlbmRpbmdJbmRleCAhPT0gdW5kZWZpbmVkIHx8IG5ld1BlbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpc09wZW4gc3RhdGUgYW5kIHVwZGF0ZXMgZm9jdXNJbnB1dEFmdGVyQ2xvc2VcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3NldE9wZW5TdGF0ZUFuZEZvY3VzT25DbG9zZSA9IGZ1bmN0aW9uIChpc09wZW4sIGZvY3VzSW5wdXRBZnRlckNsb3NlKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzSW5wdXRBZnRlckNsb3NlID0gZm9jdXNJbnB1dEFmdGVyQ2xvc2U7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgZm9yIHRoZSBldmVudCBpcyBhbHQgKE1hYyBvcHRpb24pIG9yIG1ldGEgKE1hYyBjb21tYW5kKS5cbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2lzQWx0T3JNZXRhID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBldi53aGljaCA9PT0gS2V5Q29kZXMuYWx0IHx8IGV2LmtleSA9PT0gJ01ldGEnO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9vbk9wdGlvbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZElnbm9yZU1vdXNlRXZlbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21ib0JveC5wcm90b3R5cGUuX29uT3B0aW9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2dvdE1vdXNlTW92ZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faXNTY3JvbGxJZGxlIHx8IHRoaXMuc3RhdGUuY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyID09PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY3VycmVudFBlbmRpbmdWYWx1ZVZhbGlkSW5kZXhPbkhvdmVyOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21ib0JveC5wcm90b3R5cGUuX3Nob3VsZElnbm9yZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faXNTY3JvbGxJZGxlIHx8ICF0aGlzLl9nb3RNb3VzZU1vdmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZGlzbWlzc2luZyB0aGUgbWVudSBhbmRcbiAgICAgKiBlYXRpbmcgdGhlIHJlcXVpcmVkIGtleSBldmVudCB3aGVuIGRpc2FibGVkXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGtleWJvYXJkIGV2ZW50IHRoYXQgd2FzIGZpcmVkXG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9oYW5kbGVJbnB1dFdoZW5EaXNhYmxlZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgZGlzYWJsZWQsIGNsb3NlIHRoZSBtZW51IChpZiBuZWVkZWQpXG4gICAgICAgIC8vIGFuZCBlYXQgYWxsIGtleXN0b2tlcyBvdGhlciB0aGFuIFRBQiBvciBFU0NcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBkaXNhYmxlZCBzdG9wIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50IGRlZmF1bHRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBldmVudCB1bmxlc3Mgd2UgaGF2ZSBhIHRhYiwgZXNjYXBlLCBvciBmdW5jdGlvbiBrZXlcbiAgICAgICAgICAgIGlmIChldiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGV2LndoaWNoICE9PSBLZXlDb2Rlcy50YWIgJiZcbiAgICAgICAgICAgICAgICBldi53aGljaCAhPT0gS2V5Q29kZXMuZXNjYXBlICYmXG4gICAgICAgICAgICAgICAgKGV2LndoaWNoIDwgMTEyIC8qIEYxICovIHx8IGV2LndoaWNoID4gMTIzKSAvKiBGMTIgKi8pIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2hhbmRsZVRvdWNoQW5kUG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgdGltZWVvdXQgZnJvbSBhIHByZXZpb3VzIHRvdWNoIGFuZCBwb2ludGVyIGV2ZW50XG4gICAgICAgIC8vIGNhbmNlbCB0aGF0IHRpbWVvdXQgc28gd2UgY2FuIHNldCBhIG53ZSBvbmUuXG4gICAgICAgIGlmICh0aGlzLl9sYXN0VG91Y2hUaW1lb3V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fYXN5bmMuY2xlYXJUaW1lb3V0KHRoaXMuX2xhc3RUb3VjaFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ1RvdWNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoVGltZW91dElkID0gdGhpcy5fYXN5bmMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc2luZ1RvdWNoID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFRvdWNoVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9LCBUb3VjaElkbGVEZWxheSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0eWxlcyBmb3IgdGhlIGN1cnJlbnQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSBpdGVtIC0gSXRlbSBwcm9wcyBmb3IgdGhlIGN1cnJlbnQgb3B0aW9uXG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRDYXJldEJ1dHRvblN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1c3RvbUNhcmV0RG93bkJ1dHRvblN0eWxlcyA9IHRoaXMucHJvcHMuY2FyZXREb3duQnV0dG9uU3R5bGVzO1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXREb3duQnV0dG9uU3R5bGVzKHRoaXMucHJvcHMudGhlbWUsIGN1c3RvbUNhcmV0RG93bkJ1dHRvblN0eWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0eWxlcyBmb3IgdGhlIGN1cnJlbnQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSBpdGVtIC0gSXRlbSBwcm9wcyBmb3IgdGhlIGN1cnJlbnQgb3B0aW9uXG4gICAgICovXG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9nZXRDdXJyZW50T3B0aW9uU3R5bGVzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGN1c3RvbVN0eWxlc0ZvckFsbE9wdGlvbnMgPSB0aGlzLnByb3BzLmNvbWJvQm94T3B0aW9uU3R5bGVzO1xuICAgICAgICB2YXIgY3VzdG9tU3R5bGVzRm9yQ3VycmVudE9wdGlvbiA9IGl0ZW0uc3R5bGVzO1xuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uU3R5bGVzKHRoaXMucHJvcHMudGhlbWUsIGN1c3RvbVN0eWxlc0ZvckFsbE9wdGlvbnMsIGN1c3RvbVN0eWxlc0ZvckN1cnJlbnRPcHRpb24sIHRoaXMuX2lzUGVuZGluZ09wdGlvbihpdGVtKSwgaXRlbS5oaWRkZW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgdmFsdWUgZm9yIHRoZSBjb21ib3hib3guXG4gICAgICogQHJldHVybnMgdGhlIGlkIG9mIHRoZSBjdXJyZW50IGZvY3VzZWQgY29tYm8gaXRlbSwgb3RoZXJ3aXNlIHRoZSBpZCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVsZW1lbnQsXG4gICAgICogbnVsbCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2dldEFyaWFBY3RpdmVEZXNjZW5kYW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXNjZW5kYW50VGV4dCA9IHRoaXMuc3RhdGUuaXNPcGVuICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRpY2VzICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRpY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdGhpcy5faWQgKyAnLWxpc3QnICsgdGhpcy5zdGF0ZS5zZWxlY3RlZEluZGljZXNbMF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pc09wZW4gJiYgdGhpcy5faGFzRm9jdXMoKSAmJiB0aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZGVzY2VuZGFudFRleHQgPSB0aGlzLl9pZCArICctbGlzdCcgKyB0aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50VGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXJpYSBhdXRvY29tcGxldGUgdmFsdWUgZm9yIHRoZSBDb21ib2JveFxuICAgICAqIEByZXR1cm5zICdpbmxpbmUnIGlmIGF1dG8tY29tcGxldGUgYXV0b21hdGljYWxseSBkeW5hbWljLCAnYm90aCcgaWYgd2UgaGF2ZSBhIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzIHRvIHBpY2sgZnJvbVxuICAgICAqIGFuZCBjYW4gZHluYW1pY2FsbHkgcG9wdWxhdGUgaW5wdXQsIGFuZCAnbm9uZScgaWYgYXV0by1jb21wbGV0ZSBpcyBub3QgZW5hYmxlZCBhcyB3ZSBjYW4ndCBnaXZlIHVzZXIgaW5wdXRzLlxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5fZ2V0QXJpYUF1dG9Db21wbGV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXV0b0NvbXBsZXRlID0gIXRoaXMucHJvcHMuZGlzYWJsZWQgJiYgdGhpcy5wcm9wcy5hdXRvQ29tcGxldGUgPT09ICdvbic7XG4gICAgICAgIHJldHVybiBhdXRvQ29tcGxldGUgPyAodGhpcy5wcm9wcy5hbGxvd0ZyZWVmb3JtID8gJ2lubGluZScgOiAnYm90aCcpIDogJ25vbmUnO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9pc1BlbmRpbmdPcHRpb24gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmluZGV4ID09PSB0aGlzLnN0YXRlLmN1cnJlbnRQZW5kaW5nVmFsdWVWYWxpZEluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gZGVmYXVsdCBzZWxlY3RlZCBrZXkocykgYW5kIHNlbGVjdGVkIGtleShzKSwgcmV0dXJuIHRoZSBzZWxlY3RlZCBrZXlzKHMpLlxuICAgICAqIFdoZW4gZGVmYXVsdCBzZWxlY3RlZCBrZXkocykgYXJlIGF2YWlsYWJsZSwgdGhleSB0YWtlIHByZWNlZGVuY2UgYW5kIHJldHVybiB0aGVtIGluc3RlYWQgb2Ygc2VsZWN0ZWQga2V5KHMpLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTm8gbWF0dGVyIHdoYXQgc3BlY2lmaWMgdHlwZXMgdGhlIGlucHV0IHBhcmFtZXRlcnMgYXJlLCBhbHdheXMgcmV0dXJuIGFuIGFycmF5IG9mXG4gICAgICogIGVpdGhlciBzdHJpbmdzIG9yIG51bWJlcnMgaW5zdGVhZCBvZiBwcmVtaXRpdmUgdHlwZS4gIFRoaXMgbm9ybWxpemF0aW9uIG1ha2VzIGNhbGxlcidzIGxvZ2ljIGVhc2llci5cbiAgICAgKi9cbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2J1aWxkRGVmYXVsdFNlbGVjdGVkS2V5cyA9IGZ1bmN0aW9uIChkZWZhdWx0U2VsZWN0ZWRLZXksIHNlbGVjdGVkS2V5KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSB0aGlzLl9idWlsZFNlbGVjdGVkS2V5cyhkZWZhdWx0U2VsZWN0ZWRLZXkpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkS2V5cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWxlY3RlZEtleXMoc2VsZWN0ZWRLZXkpO1xuICAgIH07XG4gICAgQ29tYm9Cb3gucHJvdG90eXBlLl9idWlsZFNlbGVjdGVkS2V5cyA9IGZ1bmN0aW9uIChzZWxlY3RlZEtleSkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgdG8gY2FzdCBoZXJlIHNvIHR5cGVzY3JpcHQgZG9lcyBub3QgY29tcGxhaW5cbiAgICAgICAgcmV0dXJuIChzZWxlY3RlZEtleSBpbnN0YW5jZW9mIEFycmF5ID8gc2VsZWN0ZWRLZXkgOiBbc2VsZWN0ZWRLZXldKTtcbiAgICB9O1xuICAgIC8vIEZvciBzY2VuYXJpb3Mgd2hlcmUgdGhlIG9wdGlvbidzIHRleHQgcHJvcCBjb250YWlucyBlbWJlZGRlZCBzdHlsZXMsIHdlIHVzZSB0aGUgb3B0aW9uJ3NcbiAgICAvLyBhcmlhTGFiZWwgdmFsdWUgYXMgdGhlIHRleHQgaW4gdGhlIGlucHV0IGFuZCBmb3IgYXV0b2NvbXBsZXRlIG1hdGNoaW5nLiBXZSBrbm93IHRvIHVzZSB0aGlzXG4gICAgLy8gd2hlbiB0aGUgdXNlQXJpYUxhYmVsQXNUZXh0IHByb3AgaXMgc2V0IHRvIHRydWVcbiAgICBDb21ib0JveC5wcm90b3R5cGUuX2dldFByZXZpZXdUZXh0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udXNlQXJpYUxhYmVsQXNUZXh0ICYmIGl0ZW0uYXJpYUxhYmVsID8gaXRlbS5hcmlhTGFiZWwgOiBpdGVtLnRleHQ7XG4gICAgfTtcbiAgICBDb21ib0JveC5wcm90b3R5cGUuX25vcm1hbGl6ZVRvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGhhcyBzb21lIGtpbmQgb2YgZm9jdXMuIElmIGl0J3MgZWl0aGVyIGZvY3VzaW5nIG9yIGlmIGl0J3MgZm9jdXNlZFxuICAgICAqL1xuICAgIENvbWJvQm94LnByb3RvdHlwZS5faGFzRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzU3RhdGUgIT09ICdub25lJztcbiAgICB9O1xuICAgIENvbWJvQm94LmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgIGFsbG93RnJlZWZvcm06IGZhbHNlLFxuICAgICAgICBhdXRvQ29tcGxldGU6ICdvbicsXG4gICAgICAgIGJ1dHRvbkljb25Qcm9wczogeyBpY29uTmFtZTogJ0NoZXZyb25Eb3duJyB9LFxuICAgIH07XG4gICAgQ29tYm9Cb3ggPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY3VzdG9taXphYmxlKCdDb21ib0JveCcsIFsndGhlbWUnLCAnc3R5bGVzJ10sIHRydWUpXG4gICAgXSwgQ29tYm9Cb3gpO1xuICAgIHJldHVybiBDb21ib0JveDtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnQgeyBDb21ib0JveCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tYm9Cb3guanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ihU0\n");

/***/ }),

/***/ "l5g6":
/*!****************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ComboBox/ComboBox.styles.js ***!
  \****************************************************************************************/
/*! exports provided: getOptionStyles, getCaretDownButtonStyles, getStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptionStyles\", function() { return getOptionStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCaretDownButtonStyles\", function() { return getCaretDownButtonStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyles\", function() { return getStyles; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Styling */ \"PKiz\");\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\nvar _a, _b;\n\n\n\nvar ComboBoxHeight = 32;\nvar ComboBoxLineHeight = 30;\nvar ComboBoxCaretDownWidth = 32;\nvar ComboBoxOptionHeight = 36;\nvar getDisabledStyles = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"memoizeFunction\"])(function (theme) {\n    var _a;\n    var semanticColors = theme.semanticColors;\n    return {\n        backgroundColor: semanticColors.disabledBackground,\n        color: semanticColors.disabledText,\n        cursor: 'default',\n        selectors: (_a = {\n                ':after': {\n                    borderColor: semanticColors.disabledBackground,\n                }\n            },\n            _a[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                color: 'GrayText',\n                selectors: {\n                    ':after': {\n                        borderColor: 'GrayText',\n                    },\n                },\n            },\n            _a),\n    };\n});\nvar listOptionHighContrastStyles = {\n    selectors: (_a = {},\n        _a[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n            backgroundColor: 'Highlight',\n            borderColor: 'Highlight',\n            color: 'HighlightText',\n            MsHighContrastAdjust: 'none',\n        },\n        _a),\n};\nvar inputHighContrastStyles = {\n    selectors: (_b = {},\n        _b[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n            color: 'WindowText',\n            backgroundColor: 'Window',\n            MsHighContrastAdjust: 'none',\n        },\n        _b),\n};\nvar getOptionStyles = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"memoizeFunction\"])(function (theme, customStylesForAllOptions, customOptionStylesForCurrentOption, isPending, isHidden) {\n    var _a;\n    var palette = theme.palette, semanticColors = theme.semanticColors;\n    var option = {\n        textHoveredColor: semanticColors.menuItemTextHovered,\n        textSelectedColor: palette.neutralDark,\n        textDisabledColor: semanticColors.disabledText,\n        backgroundHoveredColor: semanticColors.menuItemBackgroundHovered,\n        backgroundPressedColor: semanticColors.menuItemBackgroundPressed,\n    };\n    var optionStyles = {\n        root: [\n            theme.fonts.medium,\n            {\n                backgroundColor: isPending ? option.backgroundHoveredColor : 'transparent',\n                boxSizing: 'border-box',\n                cursor: 'pointer',\n                display: isHidden ? 'none' : 'block',\n                width: '100%',\n                height: 'auto',\n                minHeight: ComboBoxOptionHeight,\n                lineHeight: '20px',\n                padding: '0 8px',\n                position: 'relative',\n                borderWidth: '1px',\n                borderStyle: 'solid',\n                borderColor: 'transparent',\n                borderRadius: 0,\n                wordWrap: 'break-word',\n                overflowWrap: 'break-word',\n                textAlign: 'left',\n                selectors: (_a = {},\n                    _a[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                        border: 'none',\n                        borderColor: 'Background',\n                    },\n                    _a['&.ms-Checkbox'] = {\n                        display: 'flex',\n                        alignItems: 'center',\n                    },\n                    _a['&.ms-Button--command:hover:active'] = {\n                        backgroundColor: option.backgroundPressedColor,\n                    },\n                    _a['.ms-Checkbox-label'] = {\n                        width: '100%',\n                    },\n                    _a),\n            },\n        ],\n        rootHovered: {\n            backgroundColor: option.backgroundHoveredColor,\n            color: option.textHoveredColor,\n        },\n        rootFocused: {\n            backgroundColor: option.backgroundHoveredColor,\n        },\n        rootChecked: [\n            {\n                backgroundColor: 'transparent',\n                color: option.textSelectedColor,\n                selectors: {\n                    ':hover': [\n                        {\n                            backgroundColor: option.backgroundHoveredColor,\n                        },\n                        listOptionHighContrastStyles,\n                    ],\n                },\n            },\n            Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getFocusStyle\"])(theme, { inset: -1, isFocusedOnly: false }),\n            listOptionHighContrastStyles,\n        ],\n        rootDisabled: {\n            color: option.textDisabledColor,\n            cursor: 'default',\n        },\n        optionText: {\n            overflow: 'hidden',\n            whiteSpace: 'nowrap',\n            textOverflow: 'ellipsis',\n            minWidth: '0px',\n            maxWidth: '100%',\n            wordWrap: 'break-word',\n            overflowWrap: 'break-word',\n            display: 'inline-block',\n        },\n        optionTextWrapper: {\n            maxWidth: '100%',\n            display: 'flex',\n            alignItems: 'center',\n        },\n    };\n    return Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"concatStyleSets\"])(optionStyles, customStylesForAllOptions, customOptionStylesForCurrentOption);\n});\nvar getCaretDownButtonStyles = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"memoizeFunction\"])(function (theme, customStyles) {\n    var _a, _b;\n    var semanticColors = theme.semanticColors, fonts = theme.fonts;\n    var caret = {\n        buttonTextColor: semanticColors.bodySubtext,\n        buttonTextHoveredCheckedColor: semanticColors.buttonTextChecked,\n        buttonBackgroundHoveredColor: semanticColors.listItemBackgroundHovered,\n        buttonBackgroundCheckedColor: semanticColors.listItemBackgroundChecked,\n        buttonBackgroundCheckedHoveredColor: semanticColors.listItemBackgroundCheckedHovered,\n    };\n    var buttonHighContrastStyles = {\n        selectors: (_a = {},\n            _a[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                backgroundColor: 'Highlight',\n                borderColor: 'Highlight',\n                color: 'HighlightText',\n                MsHighContrastAdjust: 'none',\n            },\n            _a),\n    };\n    var styles = {\n        root: {\n            color: caret.buttonTextColor,\n            fontSize: fonts.small.fontSize,\n            position: 'absolute',\n            top: 0,\n            height: '100%',\n            lineHeight: ComboBoxLineHeight,\n            width: ComboBoxCaretDownWidth,\n            textAlign: 'center',\n            cursor: 'default',\n            selectors: (_b = {},\n                _b[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                    backgroundColor: 'ButtonFace',\n                    borderColor: 'ButtonText',\n                    color: 'ButtonText',\n                    MsHighContrastAdjust: 'none',\n                },\n                _b),\n        },\n        icon: {\n            fontSize: fonts.small.fontSize,\n        },\n        rootHovered: [\n            {\n                backgroundColor: caret.buttonBackgroundHoveredColor,\n                color: caret.buttonTextHoveredCheckedColor,\n                cursor: 'pointer',\n            },\n            buttonHighContrastStyles,\n        ],\n        rootPressed: [\n            {\n                backgroundColor: caret.buttonBackgroundCheckedColor,\n                color: caret.buttonTextHoveredCheckedColor,\n            },\n            buttonHighContrastStyles,\n        ],\n        rootChecked: [\n            {\n                backgroundColor: caret.buttonBackgroundCheckedColor,\n                color: caret.buttonTextHoveredCheckedColor,\n            },\n            buttonHighContrastStyles,\n        ],\n        rootCheckedHovered: [\n            {\n                backgroundColor: caret.buttonBackgroundCheckedHoveredColor,\n                color: caret.buttonTextHoveredCheckedColor,\n            },\n            buttonHighContrastStyles,\n        ],\n        rootDisabled: [\n            getDisabledStyles(theme),\n            {\n                position: 'absolute',\n            },\n        ],\n    };\n    return Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"concatStyleSets\"])(styles, customStyles);\n});\nvar getStyles = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"memoizeFunction\"])(function (theme, customStyles, comboBoxOptionWidth) {\n    var _a, _b, _c, _d, _e, _f;\n    var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;\n    var root = {\n        textColor: semanticColors.inputText,\n        borderColor: semanticColors.inputBorder,\n        borderHoveredColor: semanticColors.inputBorderHovered,\n        borderPressedColor: semanticColors.inputFocusBorderAlt,\n        borderFocusedColor: semanticColors.inputFocusBorderAlt,\n        backgroundColor: semanticColors.inputBackground,\n        erroredColor: semanticColors.errorText,\n    };\n    var option = {\n        headerTextColor: semanticColors.menuHeader,\n        dividerBorderColor: semanticColors.bodyDivider,\n    };\n    // placeholder style variables\n    var placeholderHighContrastStyles = {\n        selectors: (_a = {},\n            _a[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                color: 'GrayText',\n            },\n            _a),\n    };\n    var placeholderStyles = [\n        {\n            color: semanticColors.inputPlaceholderText,\n        },\n        placeholderHighContrastStyles,\n    ];\n    var placeholderStylesHovered = [\n        {\n            color: semanticColors.inputTextHovered,\n        },\n        placeholderHighContrastStyles,\n    ];\n    var disabledPlaceholderStyles = [\n        {\n            color: semanticColors.disabledText,\n        },\n        placeholderHighContrastStyles,\n    ];\n    var ComboBoxRootHighContrastFocused = {\n        color: 'HighlightText',\n        backgroundColor: 'Window',\n        MsHighContrastAdjust: 'none',\n        selectors: {\n            ':after': {\n                borderColor: 'Highlight',\n            },\n        },\n    };\n    var focusBorderStyles = Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getInputFocusStyle\"])(root.borderPressedColor, effects.roundedCorner2, 'border', 0);\n    var styles = {\n        container: {},\n        label: {},\n        labelDisabled: {},\n        root: [\n            theme.fonts.medium,\n            {\n                boxShadow: 'none',\n                marginLeft: '0',\n                paddingRight: ComboBoxCaretDownWidth,\n                paddingLeft: 9,\n                color: root.textColor,\n                position: 'relative',\n                outline: '0',\n                userSelect: 'none',\n                backgroundColor: root.backgroundColor,\n                cursor: 'text',\n                display: 'block',\n                height: ComboBoxHeight,\n                whiteSpace: 'nowrap',\n                textOverflow: 'ellipsis',\n                boxSizing: 'border-box',\n                selectors: {\n                    '.ms-Label': {\n                        display: 'inline-block',\n                        marginBottom: '8px',\n                    },\n                    '&.is-open': {\n                        selectors: (_b = {},\n                            _b[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = ComboBoxRootHighContrastFocused,\n                            _b),\n                    },\n                    // setting border using pseudo-element here in order to\n                    // prevent chevron button to overlap ComboBox border under certain resolutions\n                    ':after': {\n                        pointerEvents: 'none',\n                        content: \"''\",\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        bottom: 0,\n                        right: 0,\n                        borderWidth: '1px',\n                        borderStyle: 'solid',\n                        borderColor: root.borderColor,\n                        borderRadius: effects.roundedCorner2,\n                    },\n                },\n            },\n        ],\n        rootHovered: {\n            selectors: (_c = {\n                    ':after': {\n                        borderColor: root.borderHoveredColor,\n                    },\n                    '.ms-ComboBox-Input': [\n                        {\n                            color: semanticColors.inputTextHovered,\n                        },\n                        Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getPlaceholderStyles\"])(placeholderStylesHovered),\n                        inputHighContrastStyles,\n                    ]\n                },\n                _c[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                    color: 'HighlightText',\n                    backgroundColor: 'Window',\n                    MsHighContrastAdjust: 'none',\n                    selectors: {\n                        ':after': {\n                            borderColor: 'Highlight',\n                        },\n                    },\n                },\n                _c),\n        },\n        rootPressed: [\n            {\n                position: 'relative',\n                selectors: (_d = {},\n                    _d[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = ComboBoxRootHighContrastFocused,\n                    _d),\n            },\n        ],\n        rootFocused: [\n            {\n                selectors: (_e = {\n                        '.ms-ComboBox-Input': [\n                            {\n                                color: semanticColors.inputTextHovered,\n                            },\n                            inputHighContrastStyles,\n                        ]\n                    },\n                    _e[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = ComboBoxRootHighContrastFocused,\n                    _e),\n            },\n            focusBorderStyles,\n        ],\n        rootDisabled: getDisabledStyles(theme),\n        rootError: {\n            selectors: {\n                ':after': {\n                    borderColor: root.erroredColor,\n                },\n                ':hover:after': {\n                    borderColor: semanticColors.inputBorderHovered,\n                },\n            },\n        },\n        rootDisallowFreeForm: {},\n        input: [\n            Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getPlaceholderStyles\"])(placeholderStyles),\n            {\n                backgroundColor: root.backgroundColor,\n                color: root.textColor,\n                boxSizing: 'border-box',\n                width: '100%',\n                height: '100%',\n                borderStyle: 'none',\n                outline: 'none',\n                font: 'inherit',\n                textOverflow: 'ellipsis',\n                padding: '0',\n                selectors: {\n                    '::-ms-clear': {\n                        display: 'none',\n                    },\n                },\n            },\n            inputHighContrastStyles,\n        ],\n        inputDisabled: [getDisabledStyles(theme), Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getPlaceholderStyles\"])(disabledPlaceholderStyles)],\n        errorMessage: [\n            theme.fonts.small,\n            {\n                color: root.erroredColor,\n                marginTop: '5px',\n            },\n        ],\n        callout: {\n            boxShadow: effects.elevation8,\n        },\n        optionsContainerWrapper: {\n            width: comboBoxOptionWidth,\n        },\n        optionsContainer: {\n            display: 'block',\n        },\n        screenReaderText: _Styling__WEBPACK_IMPORTED_MODULE_1__[\"hiddenContentStyle\"],\n        header: [\n            fonts.medium,\n            {\n                fontWeight: _Styling__WEBPACK_IMPORTED_MODULE_1__[\"FontWeights\"].semibold,\n                color: option.headerTextColor,\n                backgroundColor: 'none',\n                borderStyle: 'none',\n                height: ComboBoxOptionHeight,\n                lineHeight: ComboBoxOptionHeight,\n                cursor: 'default',\n                padding: '0 8px',\n                userSelect: 'none',\n                textAlign: 'left',\n                selectors: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])((_f = {}, _f[_Styling__WEBPACK_IMPORTED_MODULE_1__[\"HighContrastSelector\"]] = {\n                    color: 'GrayText',\n                }, _f), Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"getEdgeChromiumNoHighContrastAdjustSelector\"])()),\n            },\n        ],\n        divider: {\n            height: 1,\n            backgroundColor: option.dividerBorderColor,\n        },\n    };\n    return Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"concatStyleSets\"])(styles, customStyles);\n});\n//# sourceMappingURL=ComboBox.styles.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDVnNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbWJvQm94L0NvbWJvQm94LnN0eWxlcy5qcz85Nzk4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfYSwgX2I7XG5pbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRm9udFdlaWdodHMsIGNvbmNhdFN0eWxlU2V0cywgZ2V0Rm9jdXNTdHlsZSwgSGlnaENvbnRyYXN0U2VsZWN0b3IsIGdldFBsYWNlaG9sZGVyU3R5bGVzLCBoaWRkZW5Db250ZW50U3R5bGUsIGdldElucHV0Rm9jdXNTdHlsZSwgZ2V0RWRnZUNocm9taXVtTm9IaWdoQ29udHJhc3RBZGp1c3RTZWxlY3RvciwgfSBmcm9tICcuLi8uLi9TdHlsaW5nJztcbmltcG9ydCB7IG1lbW9pemVGdW5jdGlvbiB9IGZyb20gJy4uLy4uL1V0aWxpdGllcyc7XG52YXIgQ29tYm9Cb3hIZWlnaHQgPSAzMjtcbnZhciBDb21ib0JveExpbmVIZWlnaHQgPSAzMDtcbnZhciBDb21ib0JveENhcmV0RG93bldpZHRoID0gMzI7XG52YXIgQ29tYm9Cb3hPcHRpb25IZWlnaHQgPSAzNjtcbnZhciBnZXREaXNhYmxlZFN0eWxlcyA9IG1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHNlbWFudGljQ29sb3JzID0gdGhlbWUuc2VtYW50aWNDb2xvcnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5kaXNhYmxlZEJhY2tncm91bmQsXG4gICAgICAgIGNvbG9yOiBzZW1hbnRpY0NvbG9ycy5kaXNhYmxlZFRleHQsXG4gICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICBzZWxlY3RvcnM6IChfYSA9IHtcbiAgICAgICAgICAgICAgICAnOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogc2VtYW50aWNDb2xvcnMuZGlzYWJsZWRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYVtIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdHcmF5VGV4dCcsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICc6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ0dyYXlUZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hKSxcbiAgICB9O1xufSk7XG52YXIgbGlzdE9wdGlvbkhpZ2hDb250cmFzdFN0eWxlcyA9IHtcbiAgICBzZWxlY3RvcnM6IChfYSA9IHt9LFxuICAgICAgICBfYVtIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdIaWdobGlnaHQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdIaWdobGlnaHQnLFxuICAgICAgICAgICAgY29sb3I6ICdIaWdobGlnaHRUZXh0JyxcbiAgICAgICAgICAgIE1zSGlnaENvbnRyYXN0QWRqdXN0OiAnbm9uZScsXG4gICAgICAgIH0sXG4gICAgICAgIF9hKSxcbn07XG52YXIgaW5wdXRIaWdoQ29udHJhc3RTdHlsZXMgPSB7XG4gICAgc2VsZWN0b3JzOiAoX2IgPSB7fSxcbiAgICAgICAgX2JbSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xuICAgICAgICAgICAgY29sb3I6ICdXaW5kb3dUZXh0JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ1dpbmRvdycsXG4gICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnLFxuICAgICAgICB9LFxuICAgICAgICBfYiksXG59O1xuZXhwb3J0IHZhciBnZXRPcHRpb25TdHlsZXMgPSBtZW1vaXplRnVuY3Rpb24oZnVuY3Rpb24gKHRoZW1lLCBjdXN0b21TdHlsZXNGb3JBbGxPcHRpb25zLCBjdXN0b21PcHRpb25TdHlsZXNGb3JDdXJyZW50T3B0aW9uLCBpc1BlbmRpbmcsIGlzSGlkZGVuKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBwYWxldHRlID0gdGhlbWUucGFsZXR0ZSwgc2VtYW50aWNDb2xvcnMgPSB0aGVtZS5zZW1hbnRpY0NvbG9ycztcbiAgICB2YXIgb3B0aW9uID0ge1xuICAgICAgICB0ZXh0SG92ZXJlZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5tZW51SXRlbVRleHRIb3ZlcmVkLFxuICAgICAgICB0ZXh0U2VsZWN0ZWRDb2xvcjogcGFsZXR0ZS5uZXV0cmFsRGFyayxcbiAgICAgICAgdGV4dERpc2FibGVkQ29sb3I6IHNlbWFudGljQ29sb3JzLmRpc2FibGVkVGV4dCxcbiAgICAgICAgYmFja2dyb3VuZEhvdmVyZWRDb2xvcjogc2VtYW50aWNDb2xvcnMubWVudUl0ZW1CYWNrZ3JvdW5kSG92ZXJlZCxcbiAgICAgICAgYmFja2dyb3VuZFByZXNzZWRDb2xvcjogc2VtYW50aWNDb2xvcnMubWVudUl0ZW1CYWNrZ3JvdW5kUHJlc3NlZCxcbiAgICB9O1xuICAgIHZhciBvcHRpb25TdHlsZXMgPSB7XG4gICAgICAgIHJvb3Q6IFtcbiAgICAgICAgICAgIHRoZW1lLmZvbnRzLm1lZGl1bSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGlzUGVuZGluZyA/IG9wdGlvbi5iYWNrZ3JvdW5kSG92ZXJlZENvbG9yIDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpc0hpZGRlbiA/ICdub25lJyA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IENvbWJvQm94T3B0aW9uSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMCA4cHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAnMXB4JyxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnQmFja2dyb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF9hWycmLm1zLUNoZWNrYm94J10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2FbJyYubXMtQnV0dG9uLS1jb21tYW5kOmhvdmVyOmFjdGl2ZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb24uYmFja2dyb3VuZFByZXNzZWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2FbJy5tcy1DaGVja2JveC1sYWJlbCddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2EpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcm9vdEhvdmVyZWQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9uLmJhY2tncm91bmRIb3ZlcmVkQ29sb3IsXG4gICAgICAgICAgICBjb2xvcjogb3B0aW9uLnRleHRIb3ZlcmVkQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RGb2N1c2VkOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbi5iYWNrZ3JvdW5kSG92ZXJlZENvbG9yLFxuICAgICAgICB9LFxuICAgICAgICByb290Q2hlY2tlZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBjb2xvcjogb3B0aW9uLnRleHRTZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9uLmJhY2tncm91bmRIb3ZlcmVkQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdE9wdGlvbkhpZ2hDb250cmFzdFN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZvY3VzU3R5bGUodGhlbWUsIHsgaW5zZXQ6IC0xLCBpc0ZvY3VzZWRPbmx5OiBmYWxzZSB9KSxcbiAgICAgICAgICAgIGxpc3RPcHRpb25IaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgICAgIF0sXG4gICAgICAgIHJvb3REaXNhYmxlZDoge1xuICAgICAgICAgICAgY29sb3I6IG9wdGlvbi50ZXh0RGlzYWJsZWRDb2xvcixcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25UZXh0OiB7XG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICAgIG1pbldpZHRoOiAnMHB4JyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxuICAgICAgICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uVGV4dFdyYXBwZXI6IHtcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBjb25jYXRTdHlsZVNldHMob3B0aW9uU3R5bGVzLCBjdXN0b21TdHlsZXNGb3JBbGxPcHRpb25zLCBjdXN0b21PcHRpb25TdHlsZXNGb3JDdXJyZW50T3B0aW9uKTtcbn0pO1xuZXhwb3J0IHZhciBnZXRDYXJldERvd25CdXR0b25TdHlsZXMgPSBtZW1vaXplRnVuY3Rpb24oZnVuY3Rpb24gKHRoZW1lLCBjdXN0b21TdHlsZXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBzZW1hbnRpY0NvbG9ycyA9IHRoZW1lLnNlbWFudGljQ29sb3JzLCBmb250cyA9IHRoZW1lLmZvbnRzO1xuICAgIHZhciBjYXJldCA9IHtcbiAgICAgICAgYnV0dG9uVGV4dENvbG9yOiBzZW1hbnRpY0NvbG9ycy5ib2R5U3VidGV4dCxcbiAgICAgICAgYnV0dG9uVGV4dEhvdmVyZWRDaGVja2VkQ29sb3I6IHNlbWFudGljQ29sb3JzLmJ1dHRvblRleHRDaGVja2VkLFxuICAgICAgICBidXR0b25CYWNrZ3JvdW5kSG92ZXJlZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5saXN0SXRlbUJhY2tncm91bmRIb3ZlcmVkLFxuICAgICAgICBidXR0b25CYWNrZ3JvdW5kQ2hlY2tlZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5saXN0SXRlbUJhY2tncm91bmRDaGVja2VkLFxuICAgICAgICBidXR0b25CYWNrZ3JvdW5kQ2hlY2tlZEhvdmVyZWRDb2xvcjogc2VtYW50aWNDb2xvcnMubGlzdEl0ZW1CYWNrZ3JvdW5kQ2hlY2tlZEhvdmVyZWQsXG4gICAgfTtcbiAgICB2YXIgYnV0dG9uSGlnaENvbnRyYXN0U3R5bGVzID0ge1xuICAgICAgICBzZWxlY3RvcnM6IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ0hpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdIaWdobGlnaHQnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnSGlnaGxpZ2h0VGV4dCcsXG4gICAgICAgICAgICAgICAgTXNIaWdoQ29udHJhc3RBZGp1c3Q6ICdub25lJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYSksXG4gICAgfTtcbiAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjb2xvcjogY2FyZXQuYnV0dG9uVGV4dENvbG9yLFxuICAgICAgICAgICAgZm9udFNpemU6IGZvbnRzLnNtYWxsLmZvbnRTaXplLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IENvbWJvQm94TGluZUhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBDb21ib0JveENhcmV0RG93bldpZHRoLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2IgPSB7fSxcbiAgICAgICAgICAgICAgICBfYltIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ0J1dHRvbkZhY2UnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ0J1dHRvblRleHQnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ0J1dHRvblRleHQnLFxuICAgICAgICAgICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2IpLFxuICAgICAgICB9LFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogZm9udHMuc21hbGwuZm9udFNpemUsXG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RIb3ZlcmVkOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYXJldC5idXR0b25CYWNrZ3JvdW5kSG92ZXJlZENvbG9yLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjYXJldC5idXR0b25UZXh0SG92ZXJlZENoZWNrZWRDb2xvcixcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25IaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgICAgIF0sXG4gICAgICAgIHJvb3RQcmVzc2VkOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYXJldC5idXR0b25CYWNrZ3JvdW5kQ2hlY2tlZENvbG9yLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjYXJldC5idXR0b25UZXh0SG92ZXJlZENoZWNrZWRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25IaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgICAgIF0sXG4gICAgICAgIHJvb3RDaGVja2VkOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYXJldC5idXR0b25CYWNrZ3JvdW5kQ2hlY2tlZENvbG9yLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjYXJldC5idXR0b25UZXh0SG92ZXJlZENoZWNrZWRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b25IaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgICAgIF0sXG4gICAgICAgIHJvb3RDaGVja2VkSG92ZXJlZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY2FyZXQuYnV0dG9uQmFja2dyb3VuZENoZWNrZWRIb3ZlcmVkQ29sb3IsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNhcmV0LmJ1dHRvblRleHRIb3ZlcmVkQ2hlY2tlZENvbG9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbkhpZ2hDb250cmFzdFN0eWxlcyxcbiAgICAgICAgXSxcbiAgICAgICAgcm9vdERpc2FibGVkOiBbXG4gICAgICAgICAgICBnZXREaXNhYmxlZFN0eWxlcyh0aGVtZSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH07XG4gICAgcmV0dXJuIGNvbmNhdFN0eWxlU2V0cyhzdHlsZXMsIGN1c3RvbVN0eWxlcyk7XG59KTtcbmV4cG9ydCB2YXIgZ2V0U3R5bGVzID0gbWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSwgY3VzdG9tU3R5bGVzLCBjb21ib0JveE9wdGlvbldpZHRoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgdmFyIHNlbWFudGljQ29sb3JzID0gdGhlbWUuc2VtYW50aWNDb2xvcnMsIGZvbnRzID0gdGhlbWUuZm9udHMsIGVmZmVjdHMgPSB0aGVtZS5lZmZlY3RzO1xuICAgIHZhciByb290ID0ge1xuICAgICAgICB0ZXh0Q29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0VGV4dCxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0Qm9yZGVyLFxuICAgICAgICBib3JkZXJIb3ZlcmVkQ29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0Qm9yZGVySG92ZXJlZCxcbiAgICAgICAgYm9yZGVyUHJlc3NlZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5pbnB1dEZvY3VzQm9yZGVyQWx0LFxuICAgICAgICBib3JkZXJGb2N1c2VkQ29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0Rm9jdXNCb3JkZXJBbHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogc2VtYW50aWNDb2xvcnMuaW5wdXRCYWNrZ3JvdW5kLFxuICAgICAgICBlcnJvcmVkQ29sb3I6IHNlbWFudGljQ29sb3JzLmVycm9yVGV4dCxcbiAgICB9O1xuICAgIHZhciBvcHRpb24gPSB7XG4gICAgICAgIGhlYWRlclRleHRDb2xvcjogc2VtYW50aWNDb2xvcnMubWVudUhlYWRlcixcbiAgICAgICAgZGl2aWRlckJvcmRlckNvbG9yOiBzZW1hbnRpY0NvbG9ycy5ib2R5RGl2aWRlcixcbiAgICB9O1xuICAgIC8vIHBsYWNlaG9sZGVyIHN0eWxlIHZhcmlhYmxlc1xuICAgIHZhciBwbGFjZWhvbGRlckhpZ2hDb250cmFzdFN0eWxlcyA9IHtcbiAgICAgICAgc2VsZWN0b3JzOiAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0hpZ2hDb250cmFzdFNlbGVjdG9yXSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ0dyYXlUZXh0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYSksXG4gICAgfTtcbiAgICB2YXIgcGxhY2Vob2xkZXJTdHlsZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbG9yOiBzZW1hbnRpY0NvbG9ycy5pbnB1dFBsYWNlaG9sZGVyVGV4dCxcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2Vob2xkZXJIaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgXTtcbiAgICB2YXIgcGxhY2Vob2xkZXJTdHlsZXNIb3ZlcmVkID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBjb2xvcjogc2VtYW50aWNDb2xvcnMuaW5wdXRUZXh0SG92ZXJlZCxcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2Vob2xkZXJIaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgXTtcbiAgICB2YXIgZGlzYWJsZWRQbGFjZWhvbGRlclN0eWxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgY29sb3I6IHNlbWFudGljQ29sb3JzLmRpc2FibGVkVGV4dCxcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2Vob2xkZXJIaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgXTtcbiAgICB2YXIgQ29tYm9Cb3hSb290SGlnaENvbnRyYXN0Rm9jdXNlZCA9IHtcbiAgICAgICAgY29sb3I6ICdIaWdobGlnaHRUZXh0JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnV2luZG93JyxcbiAgICAgICAgTXNIaWdoQ29udHJhc3RBZGp1c3Q6ICdub25lJyxcbiAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAnOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnSGlnaGxpZ2h0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgZm9jdXNCb3JkZXJTdHlsZXMgPSBnZXRJbnB1dEZvY3VzU3R5bGUocm9vdC5ib3JkZXJQcmVzc2VkQ29sb3IsIGVmZmVjdHMucm91bmRlZENvcm5lcjIsICdib3JkZXInLCAwKTtcbiAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICBjb250YWluZXI6IHt9LFxuICAgICAgICBsYWJlbDoge30sXG4gICAgICAgIGxhYmVsRGlzYWJsZWQ6IHt9LFxuICAgICAgICByb290OiBbXG4gICAgICAgICAgICB0aGVtZS5mb250cy5tZWRpdW0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJzAnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogQ29tYm9Cb3hDYXJldERvd25XaWR0aCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogOSxcbiAgICAgICAgICAgICAgICBjb2xvcjogcm9vdC50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgb3V0bGluZTogJzAnLFxuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJvb3QuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBDb21ib0JveEhlaWdodCxcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICcubXMtTGFiZWwnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzhweCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICcmLmlzLW9wZW4nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IChfYiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iW0hpZ2hDb250cmFzdFNlbGVjdG9yXSA9IENvbWJvQm94Um9vdEhpZ2hDb250cmFzdEZvY3VzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGJvcmRlciB1c2luZyBwc2V1ZG8tZWxlbWVudCBoZXJlIGluIG9yZGVyIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgY2hldnJvbiBidXR0b24gdG8gb3ZlcmxhcCBDb21ib0JveCBib3JkZXIgdW5kZXIgY2VydGFpbiByZXNvbHV0aW9uc1xuICAgICAgICAgICAgICAgICAgICAnOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogJzFweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByb290LmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBlZmZlY3RzLnJvdW5kZWRDb3JuZXIyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICByb290SG92ZXJlZDoge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICc6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcm9vdC5ib3JkZXJIb3ZlcmVkQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICcubXMtQ29tYm9Cb3gtSW5wdXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0VGV4dEhvdmVyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGxhY2Vob2xkZXJTdHlsZXMocGxhY2Vob2xkZXJTdHlsZXNIb3ZlcmVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0SGlnaENvbnRyYXN0U3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY1tIaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnSGlnaGxpZ2h0VGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ1dpbmRvdycsXG4gICAgICAgICAgICAgICAgICAgIE1zSGlnaENvbnRyYXN0QWRqdXN0OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJzphZnRlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ0hpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2MpLFxuICAgICAgICB9LFxuICAgICAgICByb290UHJlc3NlZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczogKF9kID0ge30sXG4gICAgICAgICAgICAgICAgICAgIF9kW0hpZ2hDb250cmFzdFNlbGVjdG9yXSA9IENvbWJvQm94Um9vdEhpZ2hDb250cmFzdEZvY3VzZWQsXG4gICAgICAgICAgICAgICAgICAgIF9kKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHJvb3RGb2N1c2VkOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnLm1zLUNvbWJvQm94LUlucHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHNlbWFudGljQ29sb3JzLmlucHV0VGV4dEhvdmVyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEhpZ2hDb250cmFzdFN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2VbSGlnaENvbnRyYXN0U2VsZWN0b3JdID0gQ29tYm9Cb3hSb290SGlnaENvbnRyYXN0Rm9jdXNlZCxcbiAgICAgICAgICAgICAgICAgICAgX2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzQm9yZGVyU3R5bGVzLFxuICAgICAgICBdLFxuICAgICAgICByb290RGlzYWJsZWQ6IGdldERpc2FibGVkU3R5bGVzKHRoZW1lKSxcbiAgICAgICAgcm9vdEVycm9yOiB7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAnOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcm9vdC5lcnJvcmVkQ29sb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnOmhvdmVyOmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogc2VtYW50aWNDb2xvcnMuaW5wdXRCb3JkZXJIb3ZlcmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByb290RGlzYWxsb3dGcmVlRm9ybToge30sXG4gICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICBnZXRQbGFjZWhvbGRlclN0eWxlcyhwbGFjZWhvbGRlclN0eWxlcyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByb290LmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogcm9vdC50ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBmb250OiAnaW5oZXJpdCcsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJzo6LW1zLWNsZWFyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRIaWdoQ29udHJhc3RTdHlsZXMsXG4gICAgICAgIF0sXG4gICAgICAgIGlucHV0RGlzYWJsZWQ6IFtnZXREaXNhYmxlZFN0eWxlcyh0aGVtZSksIGdldFBsYWNlaG9sZGVyU3R5bGVzKGRpc2FibGVkUGxhY2Vob2xkZXJTdHlsZXMpXSxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBbXG4gICAgICAgICAgICB0aGVtZS5mb250cy5zbWFsbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogcm9vdC5lcnJvcmVkQ29sb3IsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnNXB4JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNhbGxvdXQ6IHtcbiAgICAgICAgICAgIGJveFNoYWRvdzogZWZmZWN0cy5lbGV2YXRpb244LFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zQ29udGFpbmVyV3JhcHBlcjoge1xuICAgICAgICAgICAgd2lkdGg6IGNvbWJvQm94T3B0aW9uV2lkdGgsXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNDb250YWluZXI6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlblJlYWRlclRleHQ6IGhpZGRlbkNvbnRlbnRTdHlsZSxcbiAgICAgICAgaGVhZGVyOiBbXG4gICAgICAgICAgICBmb250cy5tZWRpdW0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogRm9udFdlaWdodHMuc2VtaWJvbGQsXG4gICAgICAgICAgICAgICAgY29sb3I6IG9wdGlvbi5oZWFkZXJUZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IENvbWJvQm94T3B0aW9uSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IENvbWJvQm94T3B0aW9uSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwIDhweCcsXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczogX19hc3NpZ24oKF9mID0ge30sIF9mW0hpZ2hDb250cmFzdFNlbGVjdG9yXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdHcmF5VGV4dCcsXG4gICAgICAgICAgICAgICAgfSwgX2YpLCBnZXRFZGdlQ2hyb21pdW1Ob0hpZ2hDb250cmFzdEFkanVzdFNlbGVjdG9yKCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGl2aWRlcjoge1xuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb24uZGl2aWRlckJvcmRlckNvbG9yLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGNvbmNhdFN0eWxlU2V0cyhzdHlsZXMsIGN1c3RvbVN0eWxlcyk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbWJvQm94LnN0eWxlcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///l5g6\n");

/***/ }),

/***/ "m9Am":
/*!********************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ComboBox/ComboBox.classNames.js ***!
  \********************************************************************************************/
/*! exports provided: getClassNames, getComboBoxOptionClassNames */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getClassNames\", function() { return getClassNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getComboBoxOptionClassNames\", function() { return getComboBoxOptionClassNames; });\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\n/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Styling */ \"PKiz\");\n\n\nvar getClassNames = Object(_Utilities__WEBPACK_IMPORTED_MODULE_0__[\"memoizeFunction\"])(function (styles, className, isOpen, disabled, required, focused, allowFreeForm, hasErrorMessage) {\n    return {\n        container: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-container', className, styles.container),\n        label: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])(styles.label, disabled && styles.labelDisabled),\n        root: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox', hasErrorMessage ? styles.rootError : isOpen && 'is-open', required && 'is-required', styles.root, !allowFreeForm && styles.rootDisallowFreeForm, hasErrorMessage && !focused ? styles.rootError : !disabled && focused && styles.rootFocused, !disabled && {\n            selectors: {\n                ':hover': hasErrorMessage ? styles.rootError : !isOpen && !focused && styles.rootHovered,\n                ':active': hasErrorMessage ? styles.rootError : styles.rootPressed,\n                ':focus': hasErrorMessage ? styles.rootError : styles.rootFocused,\n            },\n        }, disabled && ['is-disabled', styles.rootDisabled]),\n        input: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-Input', styles.input, disabled && styles.inputDisabled),\n        errorMessage: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])(styles.errorMessage),\n        callout: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-callout', styles.callout),\n        optionsContainerWrapper: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-optionsContainerWrapper', styles.optionsContainerWrapper),\n        optionsContainer: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-optionsContainer', styles.optionsContainer),\n        header: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-header', styles.header),\n        divider: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-divider', styles.divider),\n        screenReaderText: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])(styles.screenReaderText),\n    };\n});\nvar getComboBoxOptionClassNames = Object(_Utilities__WEBPACK_IMPORTED_MODULE_0__[\"memoizeFunction\"])(function (styles) {\n    return {\n        optionText: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-optionText', styles.optionText),\n        root: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])('ms-ComboBox-option', styles.root, {\n            selectors: {\n                ':hover': styles.rootHovered,\n                ':focus': styles.rootFocused,\n                ':active': styles.rootPressed,\n            },\n        }),\n        optionTextWrapper: Object(_Styling__WEBPACK_IMPORTED_MODULE_1__[\"mergeStyles\"])(styles.optionTextWrapper),\n    };\n});\n//# sourceMappingURL=ComboBox.classNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibTlBbS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbWJvQm94L0NvbWJvQm94LmNsYXNzTmFtZXMuanM/OWJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vaXplRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9VdGlsaXRpZXMnO1xuaW1wb3J0IHsgbWVyZ2VTdHlsZXMgfSBmcm9tICcuLi8uLi9TdHlsaW5nJztcbmV4cG9ydCB2YXIgZ2V0Q2xhc3NOYW1lcyA9IG1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAoc3R5bGVzLCBjbGFzc05hbWUsIGlzT3BlbiwgZGlzYWJsZWQsIHJlcXVpcmVkLCBmb2N1c2VkLCBhbGxvd0ZyZWVGb3JtLCBoYXNFcnJvck1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IG1lcmdlU3R5bGVzKCdtcy1Db21ib0JveC1jb250YWluZXInLCBjbGFzc05hbWUsIHN0eWxlcy5jb250YWluZXIpLFxuICAgICAgICBsYWJlbDogbWVyZ2VTdHlsZXMoc3R5bGVzLmxhYmVsLCBkaXNhYmxlZCAmJiBzdHlsZXMubGFiZWxEaXNhYmxlZCksXG4gICAgICAgIHJvb3Q6IG1lcmdlU3R5bGVzKCdtcy1Db21ib0JveCcsIGhhc0Vycm9yTWVzc2FnZSA/IHN0eWxlcy5yb290RXJyb3IgOiBpc09wZW4gJiYgJ2lzLW9wZW4nLCByZXF1aXJlZCAmJiAnaXMtcmVxdWlyZWQnLCBzdHlsZXMucm9vdCwgIWFsbG93RnJlZUZvcm0gJiYgc3R5bGVzLnJvb3REaXNhbGxvd0ZyZWVGb3JtLCBoYXNFcnJvck1lc3NhZ2UgJiYgIWZvY3VzZWQgPyBzdHlsZXMucm9vdEVycm9yIDogIWRpc2FibGVkICYmIGZvY3VzZWQgJiYgc3R5bGVzLnJvb3RGb2N1c2VkLCAhZGlzYWJsZWQgJiYge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgJzpob3Zlcic6IGhhc0Vycm9yTWVzc2FnZSA/IHN0eWxlcy5yb290RXJyb3IgOiAhaXNPcGVuICYmICFmb2N1c2VkICYmIHN0eWxlcy5yb290SG92ZXJlZCxcbiAgICAgICAgICAgICAgICAnOmFjdGl2ZSc6IGhhc0Vycm9yTWVzc2FnZSA/IHN0eWxlcy5yb290RXJyb3IgOiBzdHlsZXMucm9vdFByZXNzZWQsXG4gICAgICAgICAgICAgICAgJzpmb2N1cyc6IGhhc0Vycm9yTWVzc2FnZSA/IHN0eWxlcy5yb290RXJyb3IgOiBzdHlsZXMucm9vdEZvY3VzZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBkaXNhYmxlZCAmJiBbJ2lzLWRpc2FibGVkJywgc3R5bGVzLnJvb3REaXNhYmxlZF0pLFxuICAgICAgICBpbnB1dDogbWVyZ2VTdHlsZXMoJ21zLUNvbWJvQm94LUlucHV0Jywgc3R5bGVzLmlucHV0LCBkaXNhYmxlZCAmJiBzdHlsZXMuaW5wdXREaXNhYmxlZCksXG4gICAgICAgIGVycm9yTWVzc2FnZTogbWVyZ2VTdHlsZXMoc3R5bGVzLmVycm9yTWVzc2FnZSksXG4gICAgICAgIGNhbGxvdXQ6IG1lcmdlU3R5bGVzKCdtcy1Db21ib0JveC1jYWxsb3V0Jywgc3R5bGVzLmNhbGxvdXQpLFxuICAgICAgICBvcHRpb25zQ29udGFpbmVyV3JhcHBlcjogbWVyZ2VTdHlsZXMoJ21zLUNvbWJvQm94LW9wdGlvbnNDb250YWluZXJXcmFwcGVyJywgc3R5bGVzLm9wdGlvbnNDb250YWluZXJXcmFwcGVyKSxcbiAgICAgICAgb3B0aW9uc0NvbnRhaW5lcjogbWVyZ2VTdHlsZXMoJ21zLUNvbWJvQm94LW9wdGlvbnNDb250YWluZXInLCBzdHlsZXMub3B0aW9uc0NvbnRhaW5lciksXG4gICAgICAgIGhlYWRlcjogbWVyZ2VTdHlsZXMoJ21zLUNvbWJvQm94LWhlYWRlcicsIHN0eWxlcy5oZWFkZXIpLFxuICAgICAgICBkaXZpZGVyOiBtZXJnZVN0eWxlcygnbXMtQ29tYm9Cb3gtZGl2aWRlcicsIHN0eWxlcy5kaXZpZGVyKSxcbiAgICAgICAgc2NyZWVuUmVhZGVyVGV4dDogbWVyZ2VTdHlsZXMoc3R5bGVzLnNjcmVlblJlYWRlclRleHQpLFxuICAgIH07XG59KTtcbmV4cG9ydCB2YXIgZ2V0Q29tYm9Cb3hPcHRpb25DbGFzc05hbWVzID0gbWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25UZXh0OiBtZXJnZVN0eWxlcygnbXMtQ29tYm9Cb3gtb3B0aW9uVGV4dCcsIHN0eWxlcy5vcHRpb25UZXh0KSxcbiAgICAgICAgcm9vdDogbWVyZ2VTdHlsZXMoJ21zLUNvbWJvQm94LW9wdGlvbicsIHN0eWxlcy5yb290LCB7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLnJvb3RIb3ZlcmVkLFxuICAgICAgICAgICAgICAgICc6Zm9jdXMnOiBzdHlsZXMucm9vdEZvY3VzZWQsXG4gICAgICAgICAgICAgICAgJzphY3RpdmUnOiBzdHlsZXMucm9vdFByZXNzZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgb3B0aW9uVGV4dFdyYXBwZXI6IG1lcmdlU3R5bGVzKHN0eWxlcy5vcHRpb25UZXh0V3JhcHBlciksXG4gICAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tYm9Cb3guY2xhc3NOYW1lcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///m9Am\n");

/***/ }),

/***/ "mFm4":
/*!*********************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/index.js ***!
  \*********************************************************************************/
/*! exports provided: ColorPicker, ColorPickerBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColorPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorPicker */ \"qZiu\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ColorPicker\", function() { return _ColorPicker__WEBPACK_IMPORTED_MODULE_0__[\"ColorPicker\"]; });\n\n/* harmony import */ var _ColorPicker_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorPicker.base */ \"xYHk\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ColorPickerBase\", function() { return _ColorPicker_base__WEBPACK_IMPORTED_MODULE_1__[\"ColorPickerBase\"]; });\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibUZtNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL2luZGV4LmpzPzk4NTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9Db2xvclBpY2tlcic7XG5leHBvcnQgKiBmcm9tICcuL0NvbG9yUGlja2VyLmJhc2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///mFm4\n");

/***/ }),

/***/ "pLre":
/*!**********************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorPicker.styles.js ***!
  \**********************************************************************************************/
/*! exports provided: getStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyles\", function() { return getStyles; });\nvar getStyles = function (props) {\n    var className = props.className, theme = props.theme, alphaType = props.alphaType;\n    return {\n        root: [\n            'ms-ColorPicker',\n            theme.fonts.medium,\n            {\n                position: 'relative',\n                maxWidth: 300,\n            },\n            className,\n        ],\n        panel: [\n            'ms-ColorPicker-panel',\n            {\n                padding: '16px',\n            },\n        ],\n        table: [\n            'ms-ColorPicker-table',\n            {\n                tableLayout: 'fixed',\n                width: '100%',\n                selectors: {\n                    'tbody td:last-of-type .ms-ColorPicker-input': {\n                        paddingRight: 0,\n                    },\n                },\n            },\n        ],\n        tableHeader: [\n            theme.fonts.small,\n            {\n                selectors: {\n                    td: {\n                        paddingBottom: 4,\n                    },\n                },\n            },\n        ],\n        tableHexCell: {\n            width: '25%',\n        },\n        // Account for \"Transparency\" being a longer word\n        tableAlphaCell: alphaType === 'transparency' && {\n            width: '22%',\n        },\n        colorSquare: [\n            'ms-ColorPicker-colorSquare',\n            {\n                width: 48,\n                height: 48,\n                margin: '0 0 0 8px',\n                border: '1px solid #c8c6c4',\n            },\n        ],\n        flexContainer: {\n            display: 'flex',\n        },\n        flexSlider: {\n            flexGrow: '1',\n        },\n        flexPreviewBox: {\n            flexGrow: '0',\n        },\n        input: [\n            'ms-ColorPicker-input',\n            {\n                width: '100%',\n                border: 'none',\n                boxSizing: 'border-box',\n                height: 30,\n                selectors: {\n                    '&.ms-TextField': {\n                        paddingRight: 4,\n                    },\n                    '& .ms-TextField-field': {\n                        minWidth: 'auto',\n                        padding: 5,\n                        textOverflow: 'clip',\n                    },\n                },\n            },\n        ],\n    };\n};\n//# sourceMappingURL=ColorPicker.styles.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicExyZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUGlja2VyLnN0eWxlcy5qcz9hNGJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSwgdGhlbWUgPSBwcm9wcy50aGVtZSwgYWxwaGFUeXBlID0gcHJvcHMuYWxwaGFUeXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IFtcbiAgICAgICAgICAgICdtcy1Db2xvclBpY2tlcicsXG4gICAgICAgICAgICB0aGVtZS5mb250cy5tZWRpdW0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IDMwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIF0sXG4gICAgICAgIHBhbmVsOiBbXG4gICAgICAgICAgICAnbXMtQ29sb3JQaWNrZXItcGFuZWwnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcxNnB4JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHRhYmxlOiBbXG4gICAgICAgICAgICAnbXMtQ29sb3JQaWNrZXItdGFibGUnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhYmxlTGF5b3V0OiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICd0Ym9keSB0ZDpsYXN0LW9mLXR5cGUgLm1zLUNvbG9yUGlja2VyLWlucHV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICB0YWJsZUhlYWRlcjogW1xuICAgICAgICAgICAgdGhlbWUuZm9udHMuc21hbGwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICB0YWJsZUhleENlbGw6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnMjUlJyxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgXCJUcmFuc3BhcmVuY3lcIiBiZWluZyBhIGxvbmdlciB3b3JkXG4gICAgICAgIHRhYmxlQWxwaGFDZWxsOiBhbHBoYVR5cGUgPT09ICd0cmFuc3BhcmVuY3knICYmIHtcbiAgICAgICAgICAgIHdpZHRoOiAnMjIlJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JTcXVhcmU6IFtcbiAgICAgICAgICAgICdtcy1Db2xvclBpY2tlci1jb2xvclNxdWFyZScsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDAgOHB4JyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2M4YzZjNCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBmbGV4Q29udGFpbmVyOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIH0sXG4gICAgICAgIGZsZXhTbGlkZXI6IHtcbiAgICAgICAgICAgIGZsZXhHcm93OiAnMScsXG4gICAgICAgIH0sXG4gICAgICAgIGZsZXhQcmV2aWV3Qm94OiB7XG4gICAgICAgICAgICBmbGV4R3JvdzogJzAnLFxuICAgICAgICB9LFxuICAgICAgICBpbnB1dDogW1xuICAgICAgICAgICAgJ21zLUNvbG9yUGlja2VyLWlucHV0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMzAsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICcmLm1zLVRleHRGaWVsZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJyYgLm1zLVRleHRGaWVsZC1maWVsZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnY2xpcCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclBpY2tlci5zdHlsZXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///pLre\n");

/***/ }),

/***/ "qZiu":
/*!***************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorPicker.js ***!
  \***************************************************************************************/
/*! exports provided: ColorPicker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorPicker\", function() { return ColorPicker; });\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\n/* harmony import */ var _ColorPicker_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorPicker.base */ \"xYHk\");\n/* harmony import */ var _ColorPicker_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColorPicker.styles */ \"pLre\");\n\n\n\nvar ColorPicker = Object(_Utilities__WEBPACK_IMPORTED_MODULE_0__[\"styled\"])(_ColorPicker_base__WEBPACK_IMPORTED_MODULE_1__[\"ColorPickerBase\"], _ColorPicker_styles__WEBPACK_IMPORTED_MODULE_2__[\"getStyles\"], undefined, { scope: 'ColorPicker' });\n//# sourceMappingURL=ColorPicker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicVppdS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUGlja2VyLmpzP2E5OTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSAnLi4vLi4vVXRpbGl0aWVzJztcbmltcG9ydCB7IENvbG9yUGlja2VyQmFzZSB9IGZyb20gJy4vQ29sb3JQaWNrZXIuYmFzZSc7XG5pbXBvcnQgeyBnZXRTdHlsZXMgfSBmcm9tICcuL0NvbG9yUGlja2VyLnN0eWxlcyc7XG5leHBvcnQgdmFyIENvbG9yUGlja2VyID0gc3R5bGVkKENvbG9yUGlja2VyQmFzZSwgZ2V0U3R5bGVzLCB1bmRlZmluZWQsIHsgc2NvcGU6ICdDb2xvclBpY2tlcicgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclBpY2tlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///qZiu\n");

/***/ }),

/***/ "tFdE":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorRectangle/ColorRectangle.base.js ***!
  \**************************************************************************************************************/
/*! exports provided: ColorRectangleBase, _getNewColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorRectangleBase\", function() { return ColorRectangleBase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_getNewColor\", function() { return _getNewColor; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Utilities */ \"LXO1\");\n/* harmony import */ var _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utilities/color/consts */ \"dp4Y\");\n/* harmony import */ var _utilities_color_getFullColorString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utilities/color/getFullColorString */ \"EhTF\");\n/* harmony import */ var _utilities_color_updateSV__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utilities/color/updateSV */ \"dxKp\");\n/* harmony import */ var _utilities_color_clamp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utilities/color/clamp */ \"aMma\");\n\n\n\n\n\n\n\nvar getClassNames = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"classNamesFunction\"])();\n/**\n * {@docCategory ColorPicker}\n */\nvar ColorRectangleBase = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ColorRectangleBase, _super);\n    function ColorRectangleBase(props) {\n        var _this = _super.call(this, props) || this;\n        _this._disposables = [];\n        _this._root = react__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]();\n        _this._isAdjustingSaturation = true;\n        _this._descriptionId = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"getId\"])('ColorRectangle-description');\n        _this._onKeyDown = function (ev) {\n            var color = _this.state.color;\n            var s = color.s, v = color.v;\n            var increment = ev.shiftKey ? 10 : 1;\n            // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n            // and getting all the math and styles flipped correctly is tricky\n            switch (ev.which) {\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].up: {\n                    _this._isAdjustingSaturation = false;\n                    v += increment; // V = 100 (lightest) is at the top\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].down: {\n                    _this._isAdjustingSaturation = false;\n                    v -= increment; // V = 0 (darkest) is at the bottom\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].left: {\n                    _this._isAdjustingSaturation = true;\n                    s -= increment;\n                    break;\n                }\n                case _Utilities__WEBPACK_IMPORTED_MODULE_2__[\"KeyCodes\"].right: {\n                    _this._isAdjustingSaturation = true;\n                    s += increment;\n                    break;\n                }\n                default:\n                    return;\n            }\n            _this._updateColor(ev, Object(_utilities_color_updateSV__WEBPACK_IMPORTED_MODULE_5__[\"updateSV\"])(color, Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_6__[\"clamp\"])(s, _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_SATURATION\"]), Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_6__[\"clamp\"])(v, _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"])));\n        };\n        _this._onMouseDown = function (ev) {\n            _this._disposables.push(Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"on\"])(window, 'mousemove', _this._onMouseMove, true), Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"on\"])(window, 'mouseup', _this._disposeListeners, true));\n            _this._onMouseMove(ev);\n        };\n        _this._onMouseMove = function (ev) {\n            if (!_this._root.current) {\n                return;\n            }\n            // Leaving the following commented code which is sometimes necessary for debugging:\n            // If the primary button (1) isn't pressed, the user is no longer dragging, so turn off\n            // the event handlers and exit.\n            // if (!(ev.buttons & 1)) {\n            //   this._disposeListeners();\n            //   return;\n            // }\n            var newColor = _getNewColor(ev, _this.state.color, _this._root.current);\n            if (newColor) {\n                _this._updateColor(ev, newColor);\n            }\n        };\n        _this._disposeListeners = function () {\n            _this._disposables.forEach(function (dispose) { return dispose(); });\n            _this._disposables = [];\n        };\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"initializeComponentRef\"])(_this);\n        _this.state = { color: props.color };\n        return _this;\n    }\n    Object.defineProperty(ColorRectangleBase.prototype, \"color\", {\n        get: function () {\n            return this.state.color;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorRectangleBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n        // if props changed (as opposed to a state update), set the value\n        // TODO: switch to strict controlled pattern instead\n        if (prevProps !== this.props && this.props.color) {\n            this.setState({ color: this.props.color });\n        }\n    };\n    ColorRectangleBase.prototype.componentWillUnmount = function () {\n        this._disposeListeners();\n    };\n    ColorRectangleBase.prototype.render = function () {\n        var _a = this.props, minSize = _a.minSize, theme = _a.theme, className = _a.className, styles = _a.styles, ariaValueFormat = _a.ariaValueFormat, ariaLabel = _a.ariaLabel, ariaDescription = _a.ariaDescription;\n        var color = this.state.color;\n        var classNames = getClassNames(styles, {\n            theme: theme,\n            className: className,\n            minSize: minSize,\n        });\n        var valueText = ariaValueFormat.replace('{0}', String(color.s)).replace('{1}', String(color.v));\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { ref: this._root, tabIndex: 0, className: classNames.root, style: { backgroundColor: Object(_utilities_color_getFullColorString__WEBPACK_IMPORTED_MODULE_4__[\"getFullColorString\"])(color) }, onMouseDown: this._onMouseDown, onKeyDown: this._onKeyDown, role: \"slider\", \"aria-valuetext\": valueText, \"aria-valuenow\": this._isAdjustingSaturation ? color.s : color.v, \"aria-valuemin\": 0, \"aria-valuemax\": _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"], \"aria-label\": ariaLabel, \"aria-describedby\": this._descriptionId, \"data-is-focusable\": true },\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.description, id: this._descriptionId }, ariaDescription),\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.light }),\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.dark }),\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.thumb, style: { left: color.s + '%', top: _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"] - color.v + '%', backgroundColor: color.str } })));\n    };\n    ColorRectangleBase.prototype._updateColor = function (ev, color) {\n        var onChange = this.props.onChange;\n        var oldColor = this.state.color;\n        if (color.s === oldColor.s && color.v === oldColor.v) {\n            return; // no change\n        }\n        if (onChange) {\n            onChange(ev, color);\n        }\n        if (!ev.defaultPrevented) {\n            this.setState({ color: color });\n            ev.preventDefault();\n        }\n    };\n    ColorRectangleBase.defaultProps = {\n        minSize: 220,\n        ariaLabel: 'Saturation and brightness',\n        ariaValueFormat: 'Saturation {0} brightness {1}',\n        ariaDescription: 'Use left and right arrow keys to set saturation. Use up and down arrow keys to set brightness.',\n    };\n    return ColorRectangleBase;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\n\n/**\n * Exported for testing only.\n * @internal\n */\nfunction _getNewColor(ev, prevColor, root) {\n    var rectSize = root.getBoundingClientRect();\n    var sPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n    var vPercentage = (ev.clientY - rectSize.top) / rectSize.height;\n    return Object(_utilities_color_updateSV__WEBPACK_IMPORTED_MODULE_5__[\"updateSV\"])(prevColor, Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_6__[\"clamp\"])(Math.round(sPercentage * _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_SATURATION\"]), _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_SATURATION\"]), Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_6__[\"clamp\"])(Math.round(_utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"] - vPercentage * _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"]), _utilities_color_consts__WEBPACK_IMPORTED_MODULE_3__[\"MAX_COLOR_VALUE\"]));\n}\n//# sourceMappingURL=ColorRectangle.base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidEZkRS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUmVjdGFuZ2xlL0NvbG9yUmVjdGFuZ2xlLmJhc2UuanM/YjQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsYXNzTmFtZXNGdW5jdGlvbiwgb24sIGluaXRpYWxpemVDb21wb25lbnRSZWYsIEtleUNvZGVzLCBnZXRJZCB9IGZyb20gJy4uLy4uLy4uL1V0aWxpdGllcyc7XG5pbXBvcnQgeyBNQVhfQ09MT1JfU0FUVVJBVElPTiwgTUFYX0NPTE9SX1ZBTFVFIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL2NvbG9yL2NvbnN0cyc7XG5pbXBvcnQgeyBnZXRGdWxsQ29sb3JTdHJpbmcgfSBmcm9tICcuLi8uLi8uLi91dGlsaXRpZXMvY29sb3IvZ2V0RnVsbENvbG9yU3RyaW5nJztcbmltcG9ydCB7IHVwZGF0ZVNWIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL2NvbG9yL3VwZGF0ZVNWJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL2NvbG9yL2NsYW1wJztcbnZhciBnZXRDbGFzc05hbWVzID0gY2xhc3NOYW1lc0Z1bmN0aW9uKCk7XG4vKipcbiAqIHtAZG9jQ2F0ZWdvcnkgQ29sb3JQaWNrZXJ9XG4gKi9cbnZhciBDb2xvclJlY3RhbmdsZUJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbG9yUmVjdGFuZ2xlQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2xvclJlY3RhbmdsZUJhc2UocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fcm9vdCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5faXNBZGp1c3RpbmdTYXR1cmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX2Rlc2NyaXB0aW9uSWQgPSBnZXRJZCgnQ29sb3JSZWN0YW5nbGUtZGVzY3JpcHRpb24nKTtcbiAgICAgICAgX3RoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuc3RhdGUuY29sb3I7XG4gICAgICAgICAgICB2YXIgcyA9IGNvbG9yLnMsIHYgPSBjb2xvci52O1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCA9IGV2LnNoaWZ0S2V5ID8gMTAgOiAxO1xuICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBETyBOT1QgZmxpcCB0aGUgY29sb3IgcGlja2VyIGluIFJUTDogaXRzIG9yaWVudGF0aW9uIGlzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwsXG4gICAgICAgICAgICAvLyBhbmQgZ2V0dGluZyBhbGwgdGhlIG1hdGggYW5kIHN0eWxlcyBmbGlwcGVkIGNvcnJlY3RseSBpcyB0cmlja3lcbiAgICAgICAgICAgIHN3aXRjaCAoZXYud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLnVwOiB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0FkanVzdGluZ1NhdHVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdiArPSBpbmNyZW1lbnQ7IC8vIFYgPSAxMDAgKGxpZ2h0ZXN0KSBpcyBhdCB0aGUgdG9wXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLmRvd246IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzQWRqdXN0aW5nU2F0dXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2IC09IGluY3JlbWVudDsgLy8gViA9IDAgKGRhcmtlc3QpIGlzIGF0IHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgS2V5Q29kZXMubGVmdDoge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNBZGp1c3RpbmdTYXR1cmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcyAtPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEtleUNvZGVzLnJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0FkanVzdGluZ1NhdHVyYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVDb2xvcihldiwgdXBkYXRlU1YoY29sb3IsIGNsYW1wKHMsIE1BWF9DT0xPUl9TQVRVUkFUSU9OKSwgY2xhbXAodiwgTUFYX0NPTE9SX1ZBTFVFKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLl9kaXNwb3NhYmxlcy5wdXNoKG9uKHdpbmRvdywgJ21vdXNlbW92ZScsIF90aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSksIG9uKHdpbmRvdywgJ21vdXNldXAnLCBfdGhpcy5fZGlzcG9zZUxpc3RlbmVycywgdHJ1ZSkpO1xuICAgICAgICAgICAgX3RoaXMuX29uTW91c2VNb3ZlKGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9yb290LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgd2hpY2ggaXMgc29tZXRpbWVzIG5lY2Vzc2FyeSBmb3IgZGVidWdnaW5nOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHByaW1hcnkgYnV0dG9uICgxKSBpc24ndCBwcmVzc2VkLCB0aGUgdXNlciBpcyBubyBsb25nZXIgZHJhZ2dpbmcsIHNvIHR1cm4gb2ZmXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgaGFuZGxlcnMgYW5kIGV4aXQuXG4gICAgICAgICAgICAvLyBpZiAoIShldi5idXR0b25zICYgMSkpIHtcbiAgICAgICAgICAgIC8vICAgdGhpcy5fZGlzcG9zZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgLy8gICByZXR1cm47XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB2YXIgbmV3Q29sb3IgPSBfZ2V0TmV3Q29sb3IoZXYsIF90aGlzLnN0YXRlLmNvbG9yLCBfdGhpcy5fcm9vdC5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChuZXdDb2xvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVDb2xvcihldiwgbmV3Q29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fZGlzcG9zZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kaXNwb3NhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwb3NlKSB7IHJldHVybiBkaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2FibGVzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIGluaXRpYWxpemVDb21wb25lbnRSZWYoX3RoaXMpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgY29sb3I6IHByb3BzLmNvbG9yIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yUmVjdGFuZ2xlQmFzZS5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2xvclJlY3RhbmdsZUJhc2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICAvLyBpZiBwcm9wcyBjaGFuZ2VkIChhcyBvcHBvc2VkIHRvIGEgc3RhdGUgdXBkYXRlKSwgc2V0IHRoZSB2YWx1ZVxuICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gc3RyaWN0IGNvbnRyb2xsZWQgcGF0dGVybiBpbnN0ZWFkXG4gICAgICAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMgJiYgdGhpcy5wcm9wcy5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yOiB0aGlzLnByb3BzLmNvbG9yIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvclJlY3RhbmdsZUJhc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBDb2xvclJlY3RhbmdsZUJhc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbWluU2l6ZSA9IF9hLm1pblNpemUsIHRoZW1lID0gX2EudGhlbWUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgc3R5bGVzID0gX2Euc3R5bGVzLCBhcmlhVmFsdWVGb3JtYXQgPSBfYS5hcmlhVmFsdWVGb3JtYXQsIGFyaWFMYWJlbCA9IF9hLmFyaWFMYWJlbCwgYXJpYURlc2NyaXB0aW9uID0gX2EuYXJpYURlc2NyaXB0aW9uO1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLnN0YXRlLmNvbG9yO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGdldENsYXNzTmFtZXMoc3R5bGVzLCB7XG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1pblNpemU6IG1pblNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmFsdWVUZXh0ID0gYXJpYVZhbHVlRm9ybWF0LnJlcGxhY2UoJ3swfScsIFN0cmluZyhjb2xvci5zKSkucmVwbGFjZSgnezF9JywgU3RyaW5nKGNvbG9yLnYpKTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLl9yb290LCB0YWJJbmRleDogMCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnJvb3QsIHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogZ2V0RnVsbENvbG9yU3RyaW5nKGNvbG9yKSB9LCBvbk1vdXNlRG93bjogdGhpcy5fb25Nb3VzZURvd24sIG9uS2V5RG93bjogdGhpcy5fb25LZXlEb3duLCByb2xlOiBcInNsaWRlclwiLCBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlVGV4dCwgXCJhcmlhLXZhbHVlbm93XCI6IHRoaXMuX2lzQWRqdXN0aW5nU2F0dXJhdGlvbiA/IGNvbG9yLnMgOiBjb2xvci52LCBcImFyaWEtdmFsdWVtaW5cIjogMCwgXCJhcmlhLXZhbHVlbWF4XCI6IE1BWF9DT0xPUl9WQUxVRSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IHRoaXMuX2Rlc2NyaXB0aW9uSWQsIFwiZGF0YS1pcy1mb2N1c2FibGVcIjogdHJ1ZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5kZXNjcmlwdGlvbiwgaWQ6IHRoaXMuX2Rlc2NyaXB0aW9uSWQgfSwgYXJpYURlc2NyaXB0aW9uKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMubGlnaHQgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmRhcmsgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRodW1iLCBzdHlsZTogeyBsZWZ0OiBjb2xvci5zICsgJyUnLCB0b3A6IE1BWF9DT0xPUl9WQUxVRSAtIGNvbG9yLnYgKyAnJScsIGJhY2tncm91bmRDb2xvcjogY29sb3Iuc3RyIH0gfSkpKTtcbiAgICB9O1xuICAgIENvbG9yUmVjdGFuZ2xlQmFzZS5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKGV2LCBjb2xvcikge1xuICAgICAgICB2YXIgb25DaGFuZ2UgPSB0aGlzLnByb3BzLm9uQ2hhbmdlO1xuICAgICAgICB2YXIgb2xkQ29sb3IgPSB0aGlzLnN0YXRlLmNvbG9yO1xuICAgICAgICBpZiAoY29sb3IucyA9PT0gb2xkQ29sb3IucyAmJiBjb2xvci52ID09PSBvbGRDb2xvci52KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIGNoYW5nZVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgb25DaGFuZ2UoZXYsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb2xvcjogY29sb3IgfSk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvclJlY3RhbmdsZUJhc2UuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBtaW5TaXplOiAyMjAsXG4gICAgICAgIGFyaWFMYWJlbDogJ1NhdHVyYXRpb24gYW5kIGJyaWdodG5lc3MnLFxuICAgICAgICBhcmlhVmFsdWVGb3JtYXQ6ICdTYXR1cmF0aW9uIHswfSBicmlnaHRuZXNzIHsxfScsXG4gICAgICAgIGFyaWFEZXNjcmlwdGlvbjogJ1VzZSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHRvIHNldCBzYXR1cmF0aW9uLiBVc2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBzZXQgYnJpZ2h0bmVzcy4nLFxuICAgIH07XG4gICAgcmV0dXJuIENvbG9yUmVjdGFuZ2xlQmFzZTtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnQgeyBDb2xvclJlY3RhbmdsZUJhc2UgfTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldE5ld0NvbG9yKGV2LCBwcmV2Q29sb3IsIHJvb3QpIHtcbiAgICB2YXIgcmVjdFNpemUgPSByb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzUGVyY2VudGFnZSA9IChldi5jbGllbnRYIC0gcmVjdFNpemUubGVmdCkgLyByZWN0U2l6ZS53aWR0aDtcbiAgICB2YXIgdlBlcmNlbnRhZ2UgPSAoZXYuY2xpZW50WSAtIHJlY3RTaXplLnRvcCkgLyByZWN0U2l6ZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHVwZGF0ZVNWKHByZXZDb2xvciwgY2xhbXAoTWF0aC5yb3VuZChzUGVyY2VudGFnZSAqIE1BWF9DT0xPUl9TQVRVUkFUSU9OKSwgTUFYX0NPTE9SX1NBVFVSQVRJT04pLCBjbGFtcChNYXRoLnJvdW5kKE1BWF9DT0xPUl9WQUxVRSAtIHZQZXJjZW50YWdlICogTUFYX0NPTE9SX1ZBTFVFKSwgTUFYX0NPTE9SX1ZBTFVFKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvclJlY3RhbmdsZS5iYXNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///tFdE\n");

/***/ }),

/***/ "xYHk":
/*!********************************************************************************************!*\
  !*** ./node_modules/office-ui-fabric-react/lib/components/ColorPicker/ColorPicker.base.js ***!
  \********************************************************************************************/
/*! exports provided: ColorPickerBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorPickerBase\", function() { return ColorPickerBase; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"mrSG\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utilities */ \"LXO1\");\n/* harmony import */ var _TextField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TextField */ \"hG+n\");\n/* harmony import */ var _ColorRectangle_ColorRectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ColorRectangle/ColorRectangle */ \"bdA+\");\n/* harmony import */ var _ColorSlider_ColorSlider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ColorSlider/ColorSlider */ \"WXXX\");\n/* harmony import */ var _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utilities/color/consts */ \"dp4Y\");\n/* harmony import */ var _utilities_color_getColorFromString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utilities/color/getColorFromString */ \"vgI3\");\n/* harmony import */ var _utilities_color_getColorFromRGBA__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utilities/color/getColorFromRGBA */ \"vSjE\");\n/* harmony import */ var _utilities_color_clamp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/color/clamp */ \"aMma\");\n/* harmony import */ var _utilities_color_updateA__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utilities/color/updateA */ \"LQ6R\");\n/* harmony import */ var _utilities_color_updateT__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/color/updateT */ \"KlH1\");\n/* harmony import */ var _utilities_color_updateH__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/color/updateH */ \"czd/\");\n/* harmony import */ var _utilities_color_correctRGB__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/color/correctRGB */ \"R2YY\");\n/* harmony import */ var _utilities_color_correctHex__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/color/correctHex */ \"eMsR\");\n/* harmony import */ var _ColorRectangle_ColorRectangle_base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ColorRectangle/ColorRectangle.base */ \"tFdE\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar getClassNames = Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"classNamesFunction\"])();\nvar allColorComponents = ['hex', 'r', 'g', 'b', 'a', 't'];\n/**\n * {@docCategory ColorPicker}\n */\nvar ColorPickerBase = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ColorPickerBase, _super);\n    function ColorPickerBase(props) {\n        var _this = _super.call(this, props) || this;\n        _this._onSVChanged = function (ev, color) {\n            _this._updateColor(ev, color);\n        };\n        _this._onHChanged = function (ev, h) {\n            _this._updateColor(ev, Object(_utilities_color_updateH__WEBPACK_IMPORTED_MODULE_12__[\"updateH\"])(_this.state.color, h));\n        };\n        /** Callback for when the alpha/transparency slider changes */\n        _this._onATChanged = function (ev, value) {\n            var updater = _this.props.alphaType === 'transparency' ? _utilities_color_updateT__WEBPACK_IMPORTED_MODULE_11__[\"updateT\"] : _utilities_color_updateA__WEBPACK_IMPORTED_MODULE_10__[\"updateA\"];\n            _this._updateColor(ev, updater(_this.state.color, Math.round(value)));\n        };\n        _this._onBlur = function (event) {\n            var _a;\n            var _b = _this.state, color = _b.color, editingColor = _b.editingColor;\n            if (!editingColor) {\n                return;\n            }\n            // If there was an intermediate incorrect value (such as too large or empty), correct it.\n            var value = editingColor.value, component = editingColor.component;\n            var isHex = component === 'hex';\n            var isAlpha = component === 'a';\n            var isTransparency = component === 't';\n            var minLength = isHex ? _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MIN_HEX_LENGTH\"] : _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MIN_RGBA_LENGTH\"];\n            if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n                // Real value. Clamp to appropriate length (hex) or range (rgba).\n                var newColor = void 0;\n                if (isHex) {\n                    newColor = Object(_utilities_color_getColorFromString__WEBPACK_IMPORTED_MODULE_7__[\"getColorFromString\"])('#' + Object(_utilities_color_correctHex__WEBPACK_IMPORTED_MODULE_14__[\"correctHex\"])(value));\n                }\n                else if (isAlpha || isTransparency) {\n                    var updater = isAlpha ? _utilities_color_updateA__WEBPACK_IMPORTED_MODULE_10__[\"updateA\"] : _utilities_color_updateT__WEBPACK_IMPORTED_MODULE_11__[\"updateT\"];\n                    newColor = updater(color, Object(_utilities_color_clamp__WEBPACK_IMPORTED_MODULE_9__[\"clamp\"])(Number(value), _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_COLOR_ALPHA\"]));\n                }\n                else {\n                    newColor = Object(_utilities_color_getColorFromRGBA__WEBPACK_IMPORTED_MODULE_8__[\"getColorFromRGBA\"])(Object(_utilities_color_correctRGB__WEBPACK_IMPORTED_MODULE_13__[\"correctRGB\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, color), (_a = {}, _a[component] = Number(value), _a))));\n                }\n                // Update state and call onChange\n                _this._updateColor(event, newColor);\n            }\n            else {\n                // Intermediate value was an empty string or too short (hex only).\n                // Just clear the intermediate state and revert to the previous value.\n                _this.setState({ editingColor: undefined });\n            }\n        };\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"initializeComponentRef\"])(_this);\n        var strings = props.strings; // always defined since it's in defaultProps\n        Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"warnDeprecations\"])('ColorPicker', props, {\n            hexLabel: 'strings.hex',\n            redLabel: 'strings.red',\n            greenLabel: 'strings.green',\n            blueLabel: 'strings.blue',\n            alphaLabel: 'strings.alpha',\n            alphaSliderHidden: 'alphaType',\n        });\n        // eslint-disable-next-line deprecation/deprecation\n        if (strings.hue) {\n            // warnDeprecations can't handle nested deprecated props\n            Object(_Utilities__WEBPACK_IMPORTED_MODULE_2__[\"warn\"])(\"ColorPicker property 'strings.hue' was used but has been deprecated. Use 'strings.hueAriaLabel' instead.\");\n        }\n        _this.state = {\n            color: _getColorFromProps(props) || Object(_utilities_color_getColorFromString__WEBPACK_IMPORTED_MODULE_7__[\"getColorFromString\"])('#ffffff'),\n        };\n        _this._textChangeHandlers = {};\n        for (var _i = 0, allColorComponents_1 = allColorComponents; _i < allColorComponents_1.length; _i++) {\n            var component = allColorComponents_1[_i];\n            _this._textChangeHandlers[component] = _this._onTextChange.bind(_this, component);\n        }\n        var defaultStrings = ColorPickerBase.defaultProps.strings;\n        _this._textLabels = {\n            /* eslint-disable deprecation/deprecation */\n            r: props.redLabel || strings.red || defaultStrings.red,\n            g: props.greenLabel || strings.green || defaultStrings.green,\n            b: props.blueLabel || strings.blue || defaultStrings.blue,\n            a: props.alphaLabel || strings.alpha || defaultStrings.alpha,\n            hex: props.hexLabel || strings.hex || defaultStrings.hex,\n            t: strings.transparency || defaultStrings.transparency,\n        };\n        _this._strings = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, defaultStrings), { \n            // these aria labels default to the visible labels\n            alphaAriaLabel: _this._textLabels.a, transparencyAriaLabel: _this._textLabels.t }), strings);\n        return _this;\n    }\n    Object.defineProperty(ColorPickerBase.prototype, \"color\", {\n        get: function () {\n            return this.state.color;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColorPickerBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n        // if props changed (as opposed to a state update), update the color\n        if (prevProps !== this.props) {\n            var color = _getColorFromProps(this.props);\n            if (color) {\n                this._updateColor(undefined, color);\n            }\n        }\n    };\n    ColorPickerBase.prototype.render = function () {\n        var _this = this;\n        var props = this.props;\n        var strings = this._strings;\n        var textLabels = this._textLabels;\n        var theme = props.theme, className = props.className, styles = props.styles, alphaType = props.alphaType, \n        // eslint-disable-next-line deprecation/deprecation\n        _a = props.alphaSliderHidden, \n        // eslint-disable-next-line deprecation/deprecation\n        alphaSliderHidden = _a === void 0 ? alphaType === 'none' : _a;\n        var color = this.state.color;\n        var useTransparency = alphaType === 'transparency';\n        var colorComponents = ['hex', 'r', 'g', 'b', useTransparency ? 't' : 'a'];\n        var atValue = useTransparency ? color.t : color.a;\n        var atLabel = useTransparency ? textLabels.t : textLabels.a;\n        var classNames = getClassNames(styles, {\n            theme: theme,\n            className: className,\n            alphaType: alphaType,\n        });\n        var selectedColorAriaParts = [textLabels.r, color.r, textLabels.g, color.g, textLabels.b, color.b];\n        if (!alphaSliderHidden && typeof atValue === 'number') {\n            selectedColorAriaParts.push(atLabel, atValue + \"%\");\n        }\n        var ariaLabel = strings.rootAriaLabelFormat.replace('{0}', selectedColorAriaParts.join(' '));\n        return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.root, role: \"group\", \"aria-label\": ariaLabel },\n            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.panel },\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_ColorRectangle_ColorRectangle__WEBPACK_IMPORTED_MODULE_4__[\"ColorRectangle\"], { color: color, onChange: this._onSVChanged, ariaLabel: strings.svAriaLabel, ariaDescription: strings.svAriaDescription, ariaValueFormat: strings.svAriaValueFormat, className: classNames.colorRectangle }),\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.flexContainer },\n                    react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.flexSlider },\n                        react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_ColorSlider_ColorSlider__WEBPACK_IMPORTED_MODULE_5__[\"ColorSlider\"], { className: \"is-hue\", type: \"hue\", \n                            // eslint-disable-next-line deprecation/deprecation\n                            ariaLabel: strings.hue || strings.hueAriaLabel, value: color.h, onChange: this._onHChanged }),\n                        !alphaSliderHidden && (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_ColorSlider_ColorSlider__WEBPACK_IMPORTED_MODULE_5__[\"ColorSlider\"], { className: \"is-alpha\", type: alphaType, ariaLabel: useTransparency ? strings.transparencyAriaLabel : strings.alphaAriaLabel, overlayColor: color.hex, value: atValue, onChange: this._onATChanged }))),\n                    props.showPreview && (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.flexPreviewBox },\n                        react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"div\", { className: classNames.colorSquare + ' is-preview', style: {\n                                backgroundColor: color.str,\n                            } })))),\n                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"table\", { className: classNames.table, role: \"group\", cellPadding: \"0\", cellSpacing: \"0\" },\n                    react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"thead\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"tr\", { className: classNames.tableHeader },\n                            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", { className: classNames.tableHexCell }, textLabels.hex),\n                            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", null, textLabels.r),\n                            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", null, textLabels.g),\n                            react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", null, textLabels.b),\n                            !alphaSliderHidden && react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", { className: classNames.tableAlphaCell }, atLabel))),\n                    react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"tbody\", null,\n                        react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"tr\", null, colorComponents.map(function (comp) {\n                            if ((comp === 'a' || comp === 't') && alphaSliderHidden) {\n                                return null;\n                            }\n                            return (react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](\"td\", { key: comp },\n                                react__WEBPACK_IMPORTED_MODULE_1__[\"createElement\"](_TextField__WEBPACK_IMPORTED_MODULE_3__[\"TextField\"], { className: classNames.input, onChange: _this._textChangeHandlers[comp], onBlur: _this._onBlur, value: _this._getDisplayValue(comp), spellCheck: false, ariaLabel: textLabels[comp], autoComplete: \"off\" })));\n                        })))))));\n    };\n    ColorPickerBase.prototype._getDisplayValue = function (component) {\n        var _a = this.state, color = _a.color, editingColor = _a.editingColor;\n        if (editingColor && editingColor.component === component) {\n            return editingColor.value;\n        }\n        if (component === 'hex') {\n            return color[component] || '';\n        }\n        else if (typeof color[component] === 'number' && !isNaN(color[component])) {\n            return String(color[component]);\n        }\n        return '';\n    };\n    ColorPickerBase.prototype._onTextChange = function (component, event, newValue) {\n        var _a;\n        var color = this.state.color;\n        var isHex = component === 'hex';\n        var isAlpha = component === 'a';\n        var isTransparency = component === 't';\n        newValue = (newValue || '').substr(0, isHex ? _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_HEX_LENGTH\"] : _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_RGBA_LENGTH\"]);\n        // Ignore what the user typed if it contains invalid characters\n        var validCharsRegex = isHex ? _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"HEX_REGEX\"] : _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"RGBA_REGEX\"];\n        if (!validCharsRegex.test(newValue)) {\n            return;\n        }\n        // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n        var isValid;\n        if (newValue === '') {\n            // Empty string is obviously not valid\n            isValid = false;\n        }\n        else if (isHex) {\n            // Technically hex values of length 3 are also valid, but committing the value here would\n            // cause it to be automatically converted to a value of length 6, which may not be what the\n            // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n            isValid = newValue.length === _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_HEX_LENGTH\"];\n        }\n        else if (isAlpha || isTransparency) {\n            isValid = Number(newValue) <= _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_COLOR_ALPHA\"];\n        }\n        else {\n            isValid = Number(newValue) <= _utilities_color_consts__WEBPACK_IMPORTED_MODULE_6__[\"MAX_COLOR_RGB\"];\n        }\n        if (!isValid) {\n            // If the new value is an empty string or other invalid value, save that to display.\n            // (if the user still hasn't entered anything on blur, the last value is restored)\n            this.setState({ editingColor: { component: component, value: newValue } });\n        }\n        else if (String(color[component]) === newValue) {\n            // If the new value is the same as the current value, mostly ignore it.\n            // Exception is that if the user was previously editing the value (but hadn't yet entered\n            // a new valid value), we should clear the intermediate value.\n            if (this.state.editingColor) {\n                this.setState({ editingColor: undefined });\n            }\n        }\n        else {\n            // Should be a valid color. Update the value.\n            var newColor = isHex\n                ? Object(_utilities_color_getColorFromString__WEBPACK_IMPORTED_MODULE_7__[\"getColorFromString\"])('#' + newValue)\n                : isTransparency\n                    ? Object(_utilities_color_updateT__WEBPACK_IMPORTED_MODULE_11__[\"updateT\"])(color, Number(newValue))\n                    : Object(_utilities_color_getColorFromRGBA__WEBPACK_IMPORTED_MODULE_8__[\"getColorFromRGBA\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, color), (_a = {}, _a[component] = Number(newValue), _a)));\n            this._updateColor(event, newColor);\n        }\n    };\n    /**\n     * Update the displayed color and call change handlers if appropriate.\n     * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n     * @param newColor - Updated color\n     */\n    ColorPickerBase.prototype._updateColor = function (ev, newColor) {\n        if (!newColor) {\n            return;\n        }\n        var _a = this.state, color = _a.color, editingColor = _a.editingColor;\n        // For black or white, the hue can change without changing the string.\n        var isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n        if (isDifferentColor || editingColor) {\n            // If ev is undefined, it's an update from props (which should be unconditionally respected\n            // and not call onChange).\n            if (ev && this.props.onChange) {\n                this.props.onChange(ev, newColor);\n                if (ev.defaultPrevented) {\n                    return;\n                }\n            }\n            this.setState({ color: newColor, editingColor: undefined });\n        }\n    };\n    ColorPickerBase.defaultProps = {\n        alphaType: 'alpha',\n        strings: {\n            rootAriaLabelFormat: 'Color picker, {0} selected.',\n            hex: 'Hex',\n            red: 'Red',\n            green: 'Green',\n            blue: 'Blue',\n            alpha: 'Alpha',\n            transparency: 'Transparency',\n            hueAriaLabel: 'Hue',\n            svAriaLabel: _ColorRectangle_ColorRectangle_base__WEBPACK_IMPORTED_MODULE_15__[\"ColorRectangleBase\"].defaultProps.ariaLabel,\n            svAriaValueFormat: _ColorRectangle_ColorRectangle_base__WEBPACK_IMPORTED_MODULE_15__[\"ColorRectangleBase\"].defaultProps.ariaValueFormat,\n            svAriaDescription: _ColorRectangle_ColorRectangle_base__WEBPACK_IMPORTED_MODULE_15__[\"ColorRectangleBase\"].defaultProps.ariaDescription,\n        },\n    };\n    return ColorPickerBase;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]));\n\nfunction _getColorFromProps(props) {\n    var color = props.color;\n    return typeof color === 'string' ? Object(_utilities_color_getColorFromString__WEBPACK_IMPORTED_MODULE_7__[\"getColorFromString\"])(color) : color;\n}\n//# sourceMappingURL=ColorPicker.base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieFlIay5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbG9yUGlja2VyL0NvbG9yUGlja2VyLmJhc2UuanM/YzU4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjbGFzc05hbWVzRnVuY3Rpb24sIGluaXRpYWxpemVDb21wb25lbnRSZWYsIHdhcm5EZXByZWNhdGlvbnMsIHdhcm4gfSBmcm9tICcuLi8uLi9VdGlsaXRpZXMnO1xuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi4vLi4vVGV4dEZpZWxkJztcbmltcG9ydCB7IENvbG9yUmVjdGFuZ2xlIH0gZnJvbSAnLi9Db2xvclJlY3RhbmdsZS9Db2xvclJlY3RhbmdsZSc7XG5pbXBvcnQgeyBDb2xvclNsaWRlciB9IGZyb20gJy4vQ29sb3JTbGlkZXIvQ29sb3JTbGlkZXInO1xuaW1wb3J0IHsgTUFYX0NPTE9SX0FMUEhBLCBNQVhfQ09MT1JfUkdCLCBNQVhfSEVYX0xFTkdUSCwgTUFYX1JHQkFfTEVOR1RILCBNSU5fSEVYX0xFTkdUSCwgTUlOX1JHQkFfTEVOR1RILCBIRVhfUkVHRVgsIFJHQkFfUkVHRVgsIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL2NvbG9yL2NvbnN0cyc7XG5pbXBvcnQgeyBnZXRDb2xvckZyb21TdHJpbmcgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvY29sb3IvZ2V0Q29sb3JGcm9tU3RyaW5nJztcbmltcG9ydCB7IGdldENvbG9yRnJvbVJHQkEgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvY29sb3IvZ2V0Q29sb3JGcm9tUkdCQSc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9jb2xvci9jbGFtcCc7XG5pbXBvcnQgeyB1cGRhdGVBIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL2NvbG9yL3VwZGF0ZUEnO1xuaW1wb3J0IHsgdXBkYXRlVCB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9jb2xvci91cGRhdGVUJztcbmltcG9ydCB7IHVwZGF0ZUggfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvY29sb3IvdXBkYXRlSCc7XG5pbXBvcnQgeyBjb3JyZWN0UkdCIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL2NvbG9yL2NvcnJlY3RSR0InO1xuaW1wb3J0IHsgY29ycmVjdEhleCB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9jb2xvci9jb3JyZWN0SGV4JztcbmltcG9ydCB7IENvbG9yUmVjdGFuZ2xlQmFzZSB9IGZyb20gJy4vQ29sb3JSZWN0YW5nbGUvQ29sb3JSZWN0YW5nbGUuYmFzZSc7XG52YXIgZ2V0Q2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNGdW5jdGlvbigpO1xudmFyIGFsbENvbG9yQ29tcG9uZW50cyA9IFsnaGV4JywgJ3InLCAnZycsICdiJywgJ2EnLCAndCddO1xuLyoqXG4gKiB7QGRvY0NhdGVnb3J5IENvbG9yUGlja2VyfVxuICovXG52YXIgQ29sb3JQaWNrZXJCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2xvclBpY2tlckJhc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sb3JQaWNrZXJCYXNlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fb25TVkNoYW5nZWQgPSBmdW5jdGlvbiAoZXYsIGNvbG9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlQ29sb3IoZXYsIGNvbG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uSENoYW5nZWQgPSBmdW5jdGlvbiAoZXYsIGgpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVDb2xvcihldiwgdXBkYXRlSChfdGhpcy5zdGF0ZS5jb2xvciwgaCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIGFscGhhL3RyYW5zcGFyZW5jeSBzbGlkZXIgY2hhbmdlcyAqL1xuICAgICAgICBfdGhpcy5fb25BVENoYW5nZWQgPSBmdW5jdGlvbiAoZXYsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlciA9IF90aGlzLnByb3BzLmFscGhhVHlwZSA9PT0gJ3RyYW5zcGFyZW5jeScgPyB1cGRhdGVUIDogdXBkYXRlQTtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVDb2xvcihldiwgdXBkYXRlcihfdGhpcy5zdGF0ZS5jb2xvciwgTWF0aC5yb3VuZCh2YWx1ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX29uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMuc3RhdGUsIGNvbG9yID0gX2IuY29sb3IsIGVkaXRpbmdDb2xvciA9IF9iLmVkaXRpbmdDb2xvcjtcbiAgICAgICAgICAgIGlmICghZWRpdGluZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGludGVybWVkaWF0ZSBpbmNvcnJlY3QgdmFsdWUgKHN1Y2ggYXMgdG9vIGxhcmdlIG9yIGVtcHR5KSwgY29ycmVjdCBpdC5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVkaXRpbmdDb2xvci52YWx1ZSwgY29tcG9uZW50ID0gZWRpdGluZ0NvbG9yLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBpc0hleCA9IGNvbXBvbmVudCA9PT0gJ2hleCc7XG4gICAgICAgICAgICB2YXIgaXNBbHBoYSA9IGNvbXBvbmVudCA9PT0gJ2EnO1xuICAgICAgICAgICAgdmFyIGlzVHJhbnNwYXJlbmN5ID0gY29tcG9uZW50ID09PSAndCc7XG4gICAgICAgICAgICB2YXIgbWluTGVuZ3RoID0gaXNIZXggPyBNSU5fSEVYX0xFTkdUSCA6IE1JTl9SR0JBX0xFTkdUSDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoICYmIChpc0hleCB8fCAhaXNOYU4oTnVtYmVyKHZhbHVlKSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhbCB2YWx1ZS4gQ2xhbXAgdG8gYXBwcm9wcmlhdGUgbGVuZ3RoIChoZXgpIG9yIHJhbmdlIChyZ2JhKS5cbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yID0gZ2V0Q29sb3JGcm9tU3RyaW5nKCcjJyArIGNvcnJlY3RIZXgodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBbHBoYSB8fCBpc1RyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlciA9IGlzQWxwaGEgPyB1cGRhdGVBIDogdXBkYXRlVDtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgPSB1cGRhdGVyKGNvbG9yLCBjbGFtcChOdW1iZXIodmFsdWUpLCBNQVhfQ09MT1JfQUxQSEEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yID0gZ2V0Q29sb3JGcm9tUkdCQShjb3JyZWN0UkdCKF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb2xvciksIChfYSA9IHt9LCBfYVtjb21wb25lbnRdID0gTnVtYmVyKHZhbHVlKSwgX2EpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGUgYW5kIGNhbGwgb25DaGFuZ2VcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlQ29sb3IoZXZlbnQsIG5ld0NvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSB2YWx1ZSB3YXMgYW4gZW1wdHkgc3RyaW5nIG9yIHRvbyBzaG9ydCAoaGV4IG9ubHkpLlxuICAgICAgICAgICAgICAgIC8vIEp1c3QgY2xlYXIgdGhlIGludGVybWVkaWF0ZSBzdGF0ZSBhbmQgcmV2ZXJ0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGVkaXRpbmdDb2xvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50UmVmKF90aGlzKTtcbiAgICAgICAgdmFyIHN0cmluZ3MgPSBwcm9wcy5zdHJpbmdzOyAvLyBhbHdheXMgZGVmaW5lZCBzaW5jZSBpdCdzIGluIGRlZmF1bHRQcm9wc1xuICAgICAgICB3YXJuRGVwcmVjYXRpb25zKCdDb2xvclBpY2tlcicsIHByb3BzLCB7XG4gICAgICAgICAgICBoZXhMYWJlbDogJ3N0cmluZ3MuaGV4JyxcbiAgICAgICAgICAgIHJlZExhYmVsOiAnc3RyaW5ncy5yZWQnLFxuICAgICAgICAgICAgZ3JlZW5MYWJlbDogJ3N0cmluZ3MuZ3JlZW4nLFxuICAgICAgICAgICAgYmx1ZUxhYmVsOiAnc3RyaW5ncy5ibHVlJyxcbiAgICAgICAgICAgIGFscGhhTGFiZWw6ICdzdHJpbmdzLmFscGhhJyxcbiAgICAgICAgICAgIGFscGhhU2xpZGVySGlkZGVuOiAnYWxwaGFUeXBlJyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICBpZiAoc3RyaW5ncy5odWUpIHtcbiAgICAgICAgICAgIC8vIHdhcm5EZXByZWNhdGlvbnMgY2FuJ3QgaGFuZGxlIG5lc3RlZCBkZXByZWNhdGVkIHByb3BzXG4gICAgICAgICAgICB3YXJuKFwiQ29sb3JQaWNrZXIgcHJvcGVydHkgJ3N0cmluZ3MuaHVlJyB3YXMgdXNlZCBidXQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlICdzdHJpbmdzLmh1ZUFyaWFMYWJlbCcgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb2xvcjogX2dldENvbG9yRnJvbVByb3BzKHByb3BzKSB8fCBnZXRDb2xvckZyb21TdHJpbmcoJyNmZmZmZmYnKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3RleHRDaGFuZ2VIYW5kbGVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFsbENvbG9yQ29tcG9uZW50c18xID0gYWxsQ29sb3JDb21wb25lbnRzOyBfaSA8IGFsbENvbG9yQ29tcG9uZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGFsbENvbG9yQ29tcG9uZW50c18xW19pXTtcbiAgICAgICAgICAgIF90aGlzLl90ZXh0Q2hhbmdlSGFuZGxlcnNbY29tcG9uZW50XSA9IF90aGlzLl9vblRleHRDaGFuZ2UuYmluZChfdGhpcywgY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdFN0cmluZ3MgPSBDb2xvclBpY2tlckJhc2UuZGVmYXVsdFByb3BzLnN0cmluZ3M7XG4gICAgICAgIF90aGlzLl90ZXh0TGFiZWxzID0ge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24gKi9cbiAgICAgICAgICAgIHI6IHByb3BzLnJlZExhYmVsIHx8IHN0cmluZ3MucmVkIHx8IGRlZmF1bHRTdHJpbmdzLnJlZCxcbiAgICAgICAgICAgIGc6IHByb3BzLmdyZWVuTGFiZWwgfHwgc3RyaW5ncy5ncmVlbiB8fCBkZWZhdWx0U3RyaW5ncy5ncmVlbixcbiAgICAgICAgICAgIGI6IHByb3BzLmJsdWVMYWJlbCB8fCBzdHJpbmdzLmJsdWUgfHwgZGVmYXVsdFN0cmluZ3MuYmx1ZSxcbiAgICAgICAgICAgIGE6IHByb3BzLmFscGhhTGFiZWwgfHwgc3RyaW5ncy5hbHBoYSB8fCBkZWZhdWx0U3RyaW5ncy5hbHBoYSxcbiAgICAgICAgICAgIGhleDogcHJvcHMuaGV4TGFiZWwgfHwgc3RyaW5ncy5oZXggfHwgZGVmYXVsdFN0cmluZ3MuaGV4LFxuICAgICAgICAgICAgdDogc3RyaW5ncy50cmFuc3BhcmVuY3kgfHwgZGVmYXVsdFN0cmluZ3MudHJhbnNwYXJlbmN5LFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fc3RyaW5ncyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0U3RyaW5ncyksIHsgXG4gICAgICAgICAgICAvLyB0aGVzZSBhcmlhIGxhYmVscyBkZWZhdWx0IHRvIHRoZSB2aXNpYmxlIGxhYmVsc1xuICAgICAgICAgICAgYWxwaGFBcmlhTGFiZWw6IF90aGlzLl90ZXh0TGFiZWxzLmEsIHRyYW5zcGFyZW5jeUFyaWFMYWJlbDogX3RoaXMuX3RleHRMYWJlbHMudCB9KSwgc3RyaW5ncyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yUGlja2VyQmFzZS5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2xvclBpY2tlckJhc2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICAvLyBpZiBwcm9wcyBjaGFuZ2VkIChhcyBvcHBvc2VkIHRvIGEgc3RhdGUgdXBkYXRlKSwgdXBkYXRlIHRoZSBjb2xvclxuICAgICAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfZ2V0Q29sb3JGcm9tUHJvcHModGhpcy5wcm9wcyk7XG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xvcih1bmRlZmluZWQsIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sb3JQaWNrZXJCYXNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBzdHJpbmdzID0gdGhpcy5fc3RyaW5ncztcbiAgICAgICAgdmFyIHRleHRMYWJlbHMgPSB0aGlzLl90ZXh0TGFiZWxzO1xuICAgICAgICB2YXIgdGhlbWUgPSBwcm9wcy50aGVtZSwgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBzdHlsZXMgPSBwcm9wcy5zdHlsZXMsIGFscGhhVHlwZSA9IHByb3BzLmFscGhhVHlwZSwgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICBfYSA9IHByb3BzLmFscGhhU2xpZGVySGlkZGVuLCBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICAgIGFscGhhU2xpZGVySGlkZGVuID0gX2EgPT09IHZvaWQgMCA/IGFscGhhVHlwZSA9PT0gJ25vbmUnIDogX2E7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuc3RhdGUuY29sb3I7XG4gICAgICAgIHZhciB1c2VUcmFuc3BhcmVuY3kgPSBhbHBoYVR5cGUgPT09ICd0cmFuc3BhcmVuY3knO1xuICAgICAgICB2YXIgY29sb3JDb21wb25lbnRzID0gWydoZXgnLCAncicsICdnJywgJ2InLCB1c2VUcmFuc3BhcmVuY3kgPyAndCcgOiAnYSddO1xuICAgICAgICB2YXIgYXRWYWx1ZSA9IHVzZVRyYW5zcGFyZW5jeSA/IGNvbG9yLnQgOiBjb2xvci5hO1xuICAgICAgICB2YXIgYXRMYWJlbCA9IHVzZVRyYW5zcGFyZW5jeSA/IHRleHRMYWJlbHMudCA6IHRleHRMYWJlbHMuYTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBnZXRDbGFzc05hbWVzKHN0eWxlcywge1xuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICBhbHBoYVR5cGU6IGFscGhhVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbG9yQXJpYVBhcnRzID0gW3RleHRMYWJlbHMuciwgY29sb3IuciwgdGV4dExhYmVscy5nLCBjb2xvci5nLCB0ZXh0TGFiZWxzLmIsIGNvbG9yLmJdO1xuICAgICAgICBpZiAoIWFscGhhU2xpZGVySGlkZGVuICYmIHR5cGVvZiBhdFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2VsZWN0ZWRDb2xvckFyaWFQYXJ0cy5wdXNoKGF0TGFiZWwsIGF0VmFsdWUgKyBcIiVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyaWFMYWJlbCA9IHN0cmluZ3Mucm9vdEFyaWFMYWJlbEZvcm1hdC5yZXBsYWNlKCd7MH0nLCBzZWxlY3RlZENvbG9yQXJpYVBhcnRzLmpvaW4oJyAnKSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5yb290LCByb2xlOiBcImdyb3VwXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMucGFuZWwgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbG9yUmVjdGFuZ2xlLCB7IGNvbG9yOiBjb2xvciwgb25DaGFuZ2U6IHRoaXMuX29uU1ZDaGFuZ2VkLCBhcmlhTGFiZWw6IHN0cmluZ3Muc3ZBcmlhTGFiZWwsIGFyaWFEZXNjcmlwdGlvbjogc3RyaW5ncy5zdkFyaWFEZXNjcmlwdGlvbiwgYXJpYVZhbHVlRm9ybWF0OiBzdHJpbmdzLnN2QXJpYVZhbHVlRm9ybWF0LCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29sb3JSZWN0YW5nbGUgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5mbGV4Q29udGFpbmVyIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuZmxleFNsaWRlciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb2xvclNsaWRlciwgeyBjbGFzc05hbWU6IFwiaXMtaHVlXCIsIHR5cGU6IFwiaHVlXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbDogc3RyaW5ncy5odWUgfHwgc3RyaW5ncy5odWVBcmlhTGFiZWwsIHZhbHVlOiBjb2xvci5oLCBvbkNoYW5nZTogdGhpcy5fb25IQ2hhbmdlZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICFhbHBoYVNsaWRlckhpZGRlbiAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb2xvclNsaWRlciwgeyBjbGFzc05hbWU6IFwiaXMtYWxwaGFcIiwgdHlwZTogYWxwaGFUeXBlLCBhcmlhTGFiZWw6IHVzZVRyYW5zcGFyZW5jeSA/IHN0cmluZ3MudHJhbnNwYXJlbmN5QXJpYUxhYmVsIDogc3RyaW5ncy5hbHBoYUFyaWFMYWJlbCwgb3ZlcmxheUNvbG9yOiBjb2xvci5oZXgsIHZhbHVlOiBhdFZhbHVlLCBvbkNoYW5nZTogdGhpcy5fb25BVENoYW5nZWQgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2hvd1ByZXZpZXcgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuZmxleFByZXZpZXdCb3ggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29sb3JTcXVhcmUgKyAnIGlzLXByZXZpZXcnLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLnN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pKSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy50YWJsZSwgcm9sZTogXCJncm91cFwiLCBjZWxsUGFkZGluZzogXCIwXCIsIGNlbGxTcGFjaW5nOiBcIjBcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhlYWRcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy50YWJsZUhlYWRlciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy50YWJsZUhleENlbGwgfSwgdGV4dExhYmVscy5oZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCB0ZXh0TGFiZWxzLnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCB0ZXh0TGFiZWxzLmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCB0ZXh0TGFiZWxzLmIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhbHBoYVNsaWRlckhpZGRlbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMudGFibGVBbHBoYUNlbGwgfSwgYXRMYWJlbCkpKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCwgY29sb3JDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29tcCA9PT0gJ2EnIHx8IGNvbXAgPT09ICd0JykgJiYgYWxwaGFTbGlkZXJIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsga2V5OiBjb21wIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpZWxkLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5pbnB1dCwgb25DaGFuZ2U6IF90aGlzLl90ZXh0Q2hhbmdlSGFuZGxlcnNbY29tcF0sIG9uQmx1cjogX3RoaXMuX29uQmx1ciwgdmFsdWU6IF90aGlzLl9nZXREaXNwbGF5VmFsdWUoY29tcCksIHNwZWxsQ2hlY2s6IGZhbHNlLCBhcmlhTGFiZWw6IHRleHRMYWJlbHNbY29tcF0sIGF1dG9Db21wbGV0ZTogXCJvZmZcIiB9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSkpKSk7XG4gICAgfTtcbiAgICBDb2xvclBpY2tlckJhc2UucHJvdG90eXBlLl9nZXREaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIGNvbG9yID0gX2EuY29sb3IsIGVkaXRpbmdDb2xvciA9IF9hLmVkaXRpbmdDb2xvcjtcbiAgICAgICAgaWYgKGVkaXRpbmdDb2xvciAmJiBlZGl0aW5nQ29sb3IuY29tcG9uZW50ID09PSBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0aW5nQ29sb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcltjb21wb25lbnRdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xvcltjb21wb25lbnRdID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY29sb3JbY29tcG9uZW50XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoY29sb3JbY29tcG9uZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgQ29sb3JQaWNrZXJCYXNlLnByb3RvdHlwZS5fb25UZXh0Q2hhbmdlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZXZlbnQsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5zdGF0ZS5jb2xvcjtcbiAgICAgICAgdmFyIGlzSGV4ID0gY29tcG9uZW50ID09PSAnaGV4JztcbiAgICAgICAgdmFyIGlzQWxwaGEgPSBjb21wb25lbnQgPT09ICdhJztcbiAgICAgICAgdmFyIGlzVHJhbnNwYXJlbmN5ID0gY29tcG9uZW50ID09PSAndCc7XG4gICAgICAgIG5ld1ZhbHVlID0gKG5ld1ZhbHVlIHx8ICcnKS5zdWJzdHIoMCwgaXNIZXggPyBNQVhfSEVYX0xFTkdUSCA6IE1BWF9SR0JBX0xFTkdUSCk7XG4gICAgICAgIC8vIElnbm9yZSB3aGF0IHRoZSB1c2VyIHR5cGVkIGlmIGl0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyc1xuICAgICAgICB2YXIgdmFsaWRDaGFyc1JlZ2V4ID0gaXNIZXggPyBIRVhfUkVHRVggOiBSR0JBX1JFR0VYO1xuICAgICAgICBpZiAoIXZhbGlkQ2hhcnNSZWdleC50ZXN0KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZW50cnkgaXMgdmFsaWQgKGRpZmZlcmVudCBtZXRob2RzIGZvciBoZXgsIGFscGhhLCBhbmQgUkdCKVxuICAgICAgICB2YXIgaXNWYWxpZDtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5nIGlzIG9idmlvdXNseSBub3QgdmFsaWRcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hleCkge1xuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHkgaGV4IHZhbHVlcyBvZiBsZW5ndGggMyBhcmUgYWxzbyB2YWxpZCwgYnV0IGNvbW1pdHRpbmcgdGhlIHZhbHVlIGhlcmUgd291bGRcbiAgICAgICAgICAgIC8vIGNhdXNlIGl0IHRvIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgdmFsdWUgb2YgbGVuZ3RoIDYsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB0aGVcbiAgICAgICAgICAgIC8vIHVzZXIgd2FudGVkIGlmIHRoZXkncmUgbm90IGZpbmlzaGVkIHR5cGluZy4gKFZhbHVlcyBvZiBsZW5ndGggMyB3aWxsIGJlIGNvbW1pdHRlZCBvbiBibHVyLilcbiAgICAgICAgICAgIGlzVmFsaWQgPSBuZXdWYWx1ZS5sZW5ndGggPT09IE1BWF9IRVhfTEVOR1RIO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQWxwaGEgfHwgaXNUcmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBOdW1iZXIobmV3VmFsdWUpIDw9IE1BWF9DT0xPUl9BTFBIQTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBOdW1iZXIobmV3VmFsdWUpIDw9IE1BWF9DT0xPUl9SR0I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3IHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZyBvciBvdGhlciBpbnZhbGlkIHZhbHVlLCBzYXZlIHRoYXQgdG8gZGlzcGxheS5cbiAgICAgICAgICAgIC8vIChpZiB0aGUgdXNlciBzdGlsbCBoYXNuJ3QgZW50ZXJlZCBhbnl0aGluZyBvbiBibHVyLCB0aGUgbGFzdCB2YWx1ZSBpcyByZXN0b3JlZClcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlZGl0aW5nQ29sb3I6IHsgY29tcG9uZW50OiBjb21wb25lbnQsIHZhbHVlOiBuZXdWYWx1ZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFN0cmluZyhjb2xvcltjb21wb25lbnRdKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXcgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdmFsdWUsIG1vc3RseSBpZ25vcmUgaXQuXG4gICAgICAgICAgICAvLyBFeGNlcHRpb24gaXMgdGhhdCBpZiB0aGUgdXNlciB3YXMgcHJldmlvdXNseSBlZGl0aW5nIHRoZSB2YWx1ZSAoYnV0IGhhZG4ndCB5ZXQgZW50ZXJlZFxuICAgICAgICAgICAgLy8gYSBuZXcgdmFsaWQgdmFsdWUpLCB3ZSBzaG91bGQgY2xlYXIgdGhlIGludGVybWVkaWF0ZSB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmVkaXRpbmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlZGl0aW5nQ29sb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBhIHZhbGlkIGNvbG9yLiBVcGRhdGUgdGhlIHZhbHVlLlxuICAgICAgICAgICAgdmFyIG5ld0NvbG9yID0gaXNIZXhcbiAgICAgICAgICAgICAgICA/IGdldENvbG9yRnJvbVN0cmluZygnIycgKyBuZXdWYWx1ZSlcbiAgICAgICAgICAgICAgICA6IGlzVHJhbnNwYXJlbmN5XG4gICAgICAgICAgICAgICAgICAgID8gdXBkYXRlVChjb2xvciwgTnVtYmVyKG5ld1ZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgOiBnZXRDb2xvckZyb21SR0JBKF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb2xvciksIChfYSA9IHt9LCBfYVtjb21wb25lbnRdID0gTnVtYmVyKG5ld1ZhbHVlKSwgX2EpKSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xvcihldmVudCwgbmV3Q29sb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBjb2xvciBhbmQgY2FsbCBjaGFuZ2UgaGFuZGxlcnMgaWYgYXBwcm9wcmlhdGUuXG4gICAgICogQHBhcmFtIGV2IC0gRXZlbnQgaWYgY2FsbCB3YXMgdHJpZ2dlcmVkIGJ5IGFuIGV2ZW50ICh1bmRlZmluZWQgaWYgdHJpZ2dlcmVkIGJ5IHByb3BzIGNoYW5nZSlcbiAgICAgKiBAcGFyYW0gbmV3Q29sb3IgLSBVcGRhdGVkIGNvbG9yXG4gICAgICovXG4gICAgQ29sb3JQaWNrZXJCYXNlLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAoZXYsIG5ld0NvbG9yKSB7XG4gICAgICAgIGlmICghbmV3Q29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBjb2xvciA9IF9hLmNvbG9yLCBlZGl0aW5nQ29sb3IgPSBfYS5lZGl0aW5nQ29sb3I7XG4gICAgICAgIC8vIEZvciBibGFjayBvciB3aGl0ZSwgdGhlIGh1ZSBjYW4gY2hhbmdlIHdpdGhvdXQgY2hhbmdpbmcgdGhlIHN0cmluZy5cbiAgICAgICAgdmFyIGlzRGlmZmVyZW50Q29sb3IgPSBuZXdDb2xvci5oICE9PSBjb2xvci5oIHx8IG5ld0NvbG9yLnN0ciAhPT0gY29sb3Iuc3RyO1xuICAgICAgICBpZiAoaXNEaWZmZXJlbnRDb2xvciB8fCBlZGl0aW5nQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIElmIGV2IGlzIHVuZGVmaW5lZCwgaXQncyBhbiB1cGRhdGUgZnJvbSBwcm9wcyAod2hpY2ggc2hvdWxkIGJlIHVuY29uZGl0aW9uYWxseSByZXNwZWN0ZWRcbiAgICAgICAgICAgIC8vIGFuZCBub3QgY2FsbCBvbkNoYW5nZSkuXG4gICAgICAgICAgICBpZiAoZXYgJiYgdGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZXYsIG5ld0NvbG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yOiBuZXdDb2xvciwgZWRpdGluZ0NvbG9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbG9yUGlja2VyQmFzZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGFscGhhVHlwZTogJ2FscGhhJyxcbiAgICAgICAgc3RyaW5nczoge1xuICAgICAgICAgICAgcm9vdEFyaWFMYWJlbEZvcm1hdDogJ0NvbG9yIHBpY2tlciwgezB9IHNlbGVjdGVkLicsXG4gICAgICAgICAgICBoZXg6ICdIZXgnLFxuICAgICAgICAgICAgcmVkOiAnUmVkJyxcbiAgICAgICAgICAgIGdyZWVuOiAnR3JlZW4nLFxuICAgICAgICAgICAgYmx1ZTogJ0JsdWUnLFxuICAgICAgICAgICAgYWxwaGE6ICdBbHBoYScsXG4gICAgICAgICAgICB0cmFuc3BhcmVuY3k6ICdUcmFuc3BhcmVuY3knLFxuICAgICAgICAgICAgaHVlQXJpYUxhYmVsOiAnSHVlJyxcbiAgICAgICAgICAgIHN2QXJpYUxhYmVsOiBDb2xvclJlY3RhbmdsZUJhc2UuZGVmYXVsdFByb3BzLmFyaWFMYWJlbCxcbiAgICAgICAgICAgIHN2QXJpYVZhbHVlRm9ybWF0OiBDb2xvclJlY3RhbmdsZUJhc2UuZGVmYXVsdFByb3BzLmFyaWFWYWx1ZUZvcm1hdCxcbiAgICAgICAgICAgIHN2QXJpYURlc2NyaXB0aW9uOiBDb2xvclJlY3RhbmdsZUJhc2UuZGVmYXVsdFByb3BzLmFyaWFEZXNjcmlwdGlvbixcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBDb2xvclBpY2tlckJhc2U7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0IHsgQ29sb3JQaWNrZXJCYXNlIH07XG5mdW5jdGlvbiBfZ2V0Q29sb3JGcm9tUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgY29sb3IgPSBwcm9wcy5jb2xvcjtcbiAgICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyA/IGdldENvbG9yRnJvbVN0cmluZyhjb2xvcikgOiBjb2xvcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yUGlja2VyLmJhc2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///xYHk\n");

/***/ })

}]);